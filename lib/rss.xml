<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[review]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://cs-note-three.vercel.app/</link><image><url>.\https:\\cs-note-three.vercel.app\lib\media\favicon.png</url><title>review</title><link>https://cs-note-three.vercel.app/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 13 Jun 2025 16:10:14 GMT</lastBuildDate><atom:link href=".\https:\\cs-note-three.vercel.app\lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 13 Jun 2025 16:09:47 GMT</pubDate><copyright><![CDATA[Apricity]]></copyright><ttl>60</ttl><dc:creator>Apricity</dc:creator><item><title><![CDATA[1.2：操作系统的运行机制]]></title><description><![CDATA[ 
 <br>对于 CPU 执行的指令来说，分为特权指令和用户指令，CPU 在设计时就可以根据指令区分特权指令还是用户指令，但是 CPU 无法分辨当前程序是内核程序【操作系统的管理者】还是用户程序<br>CPU 的内核是 CPU 最接近硬件的部分<br>为了解决上一问题，CPU 被分为两个状态，用户态、内核态<br>
<br>当 CPU 处于内核态的时候，说明 CPU 再执行内核程序，此时可以执行特权指令
<br>当 CPU 处于用户态的时候，说明 CPU 在执行用户程序，此时只能执行非特权指令<br>
CPU 在 PSW 状态寄存器中有一个标志位，处于 0 时表示 CPU 处于用户态，处于 1 时表示 CPU 处于内核态
<br>
当 CPU 处于用户态执行用户程序时，如果其中有一条特权指令的话，那么 CPU 就会引发一个中断信号，并且将 CPU 从用户态转换为内核态，去执行中断程序，执行完成之后将 CPU 转为用户态，然后再执行用户程序<br>
触发一个中断信号意味着操作系统将强行夺回 CPU 使用权
<br><br>——中断是让操作系统重新夺回 CPU 使用权的唯一途径，产生中断之后 CPU 会从用户态变为内核态<br>用户态到内核态：由中断引发，硬件自动完成变态过程，触发中断信号意味着操作系统强行夺回 CPU 使用权<br>
内核态到用户态：执行一条特权指令，修改 PSW 寄存器中的标记位，使得其转换为用户态<br>如果没有中断机制，CPU 就会一直执行这个程序，也就不会产生并发<br><br>——中断信号来源于 CPU 内部<br>
如果执行的指令是非法的，或者指令的参数是非法的，那么就会产生内中断<br>
<br>执行程序时发现特权指令
<br>执行除法指令发现除数为 0
<br>有时候程序想请求操作系统内核的服务，这是就会执行一条陷入指令（是特殊的指令，并不是特权指令），会引发一个内部中断信号<br>
可以分为陷阱、故障、终止<br>
陷阱：由陷入程序引发的，是应用程序故意引发的。<br>
故障：由错误条件引起的，可能被内核程序修复，内核程序修复故障之后会将 CPU 使用权还给用户程序，让它继续执行下去。<br>
终止：由致命错误引起，内核程序无法修复该程序，因此，不用将 CPU 使用权还给用户程序，而是直接终止该程序。
<br><br>——中断信号来源于 CPU 外部，与 CPU 执行的指令无关<br>
<br>时钟中断：由时钟部件发出的中断信号，时钟部件每隔一段时间就会向 CPU 发出中断信号
<br>IO 中断：由输入/输出设备产生的中断信号
<br><br>——操作系统提供给用户的接口，为程序员请求操作系统内核服务的功能<br>
为什么系统调用是必须的？<br>
如果不适用系统调用的话，那么对于计算机来说，不同程序对统一资源发起的请求就无法统一进行管理，为了方便对系统资源的管理，使用系统调用是必须的，由操作系统统一进行管理，并将处理结果返回给应用程序
<br>按功能分类可以分为以下几类：<br>
<br>设备调用：完成对设备的请求和释放
<br>文件管理：完成对文件的读、写、创建、以及删除等功能
<br>进程控制：完成对进程的创建、撤销、阻塞、唤醒等功能
<br>进程通信：完成进程之间的消息传递或信号传递等功能
<br>内存管理：完成内存的分配、回收，以及获取作业占用内存区大小的起始地址等功能
<br>系统调用的过程<br>
<br>传参过程：用户程序首先会将系统调用的调用号和所需参数压入堆栈
<br>陷入指令的执行：会将 CPU 从用户态转为内核态
<br>保存现场：将 PC、PSW 以及通用寄存器等内容压入堆栈
<br>分析系统调用类型：根据系统调用类型转入相对应的处理子程序（根据维护的系统调用表，根据系统调用编号找到对应的程序入口地址）
<br>根据找到的地址执行对应的系统调用程序
<br>执行完成之后，CPU 转为用户态，对应的恢复现场，然后再执行用户程序<br>
<img alt="Pasted image 20250520193316.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520193316.png">
<br>注意：<br>
<br>trap 指令是在用户态执行的，执行 trap 指令之后立即引发一个中断，使 CPU 进入内核态
<br>发出系统调用请求是在用户态完成的，执行系统调用是在内核态
<br><br>操作系统可以分为两个部分，内核功能区，非内核功能区<br>
内核功能区<br>
<br>进程管理
<br>存储器管理
<br>设备管理
<br>时钟管理
<br>中断管理
<br>原语（再执行过程中不可被中断，要么不执行，要么一口气执行完）<br>
其中包含所有内核功能的部分叫做大内核，只包含时钟管理、中断管理、原语称为微内核<br>
非内核区
<br>GUI 部分
<br>不同内核的操作系统体系结构<br>
<img alt="Pasted image 20250520194816.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520194816.png"><br>分层结构<br>
将操作系统从硬件（最底层）到系统调用（最高层）划分为多个层次，其中每一层可以调用更低一层，但是不能进行跨层调用<br>
优点：<br>
便于调试、验证，因为每一层只能调用来自更低一层的数据，可以分层进行调试<br>
易于扩充和维护，分层操作系统内核已经设置好每一层之间的系统调用是什么，需要哪些参数 （只需保证新添加的一层调用的接口是上一层给出的，给下一层系统调用的接口应该与上一层一样）<br>
缺点：<br>
 尽可以调用低层，难以合理定义各层的边界<br>
 效率低，如果需要调用的内容处于低层时间开销就很大，因为不能直接调用，只能分层调用然后逐层返回<br>模块化<br>
模块化是将操作系统按照功能划分为若干个具有独立功能的模块，每个模块具有某个方面的功能，并规定好各模块间的接口，使得模块之间能够通信，还可以进一步将模块划分为具有一定功能的子模块，也同样规定好接口。<br>内核 = 主模块 + 可加载模块<br>
主模块：只加载核心功能，如进程调度、内存管理<br>
可加载模块：可以动态加载新模块到内核，无需重新编译整个内核<br>优点：<br>
模块之间逻辑清晰，易于维护，确定模块间接口之后即可多模块同时开发<br>
支持动态加载新的内核模块，增强了 OS 的适应性<br>
各个模块之间可以直接调用其他模块，无需采用消息传递进行通信，效率高<br>缺点：<br>
模块之间接口定义未必合理<br>
模块之间相互依赖，更难调试和验证<br>大内核<br>
将内核中的所有功能都集成在一块<br>优点：<br>
性能高，内核内各种功能都可以相互调用<br>缺点：<br>
内核庞大，功能复杂，难以维护<br>
大内核中某个模块出错就可能导致整个系统崩溃<br>微内核<br>
将内核中的部分功能放到内核中，其余功能在用户态<br>
优点：<br>
内核小，功能少，易于维护<br>
内核外的某个模块功能部件出错不会导致整个系统崩溃<br>特点：<br>
可靠性和安全性<br>
扩展性和灵活性<br>
可移植性<br>
分布式计算<br>缺点：<br>
性能低，需要频繁的切换用户态、内核态，在各模块之间只能采用消息传递的方式来进行通信<br>
用户态下的各模块功能不能直接调用，只能采用消息传递的方式进行通信<br>外核<br>
内核负责进程调度，进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核保证硬件数据安全<br>
抽象的硬件资源：在进行内存资源的分配时，进程看到的以为是一段连续的内存空间，但是各个部分是零散的分布在内存中的<br>
未经抽象的硬件资源：在进行内存资源的分配时，实际分配给进程的资源就是连续的空间<br>
优点：<br>
外核可以给进程分配不抽象的资源，进程可以更灵活的使用硬件资源<br>
减少了从虚拟地址到物理地址的转换过程，提升效率<br>缺点：<br>
降低系统的一致性<br>
使系统变得更加复杂<br><br>
<br>激活 CPU，CPU 通电之后会读取 ROM 中的 boot 程序，开始执行 BIOS 指令
<br>硬件自检：BIOS 程序在内存最开始的部分构建中断向量表，加载在后面的自检过程中要用到的中断，然后进行自检，如果硬件出现问题就会发出提示
<br>加载带有操作系统的硬盘：BIOS 读取 Boot sequence 将控制权交给排在第一位的存储设备，将该设备的引导扇区加载进内存中
<br>加载主引导记录 MBR：硬盘会一特定的标识符区分引导盘和非引导盘，若发现设备不是引导盘就会寻找下一个设备，MBR 的作用就是告诉 CPU 去哪个主分区【硬盘】寻找操作系统
<br>扫描硬盘分区表：硬盘中会用标记表明活动分区，加载活动分区到内存，将控制权交给活动分区
<br>加载分区引导记录 PBR：寻找并激活存在根目录下的用于引导操作系统的程序（启动管理程序）
<br>启动管理器：完成操作系统初始化的一系列操作
<br><br>——利用虚拟化技术，将一台物理机虚拟化为多台虚拟机，每台虚拟机上都可以独立的运行操作系统<br>
<img alt="Pasted image 20250520211255.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520211255.png"><br><br>——在一台电脑上运行多种操作系统<br>
对于直接运行在硬件之上的操作系统，只有第一类虚拟机管理程序是运行在内核态的，对于上层的操作系统都是运行在用户态的，当上层的操作系统想要执行特权指令的时候，第一类虚拟机管理程序会将其截获，然后进行一些等价的转换，给上层模拟出已经执行了特权指令一样，实际上上层的操作系统执行特权指令是在虚拟内核空间中<br><br>——类似于 VMware 等软件，在宿主操作系统上运行着很多操作系统，同时也运行着宿主操作系统中的很多进程<br>
当虚拟机需要进行系统调用时，第二类虚拟机管理程序会截获上面的调用请求，然后代替虚拟机完成系统调用并将结果返回给虚拟机【这一类 VMM 管理程序是运行在用户级别的】<br><br><img alt="Pasted image 20250520211242.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520211242.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\1.2：操作系统的运行机制.html</link><guid isPermaLink="false">review/操作系统/1.操作系统概念/1.2：操作系统的运行机制.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 07 Jun 2025 07:08:19 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520193316.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520193316.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.1：操作系统]]></title><description><![CDATA[ 
 <br><br>
<br>操作系统是一个系统资源的管理者
<br>向上层提供方便易用的服务<br>
提供的功能：
<br>处理机管理
<br>存储器管理
<br>文件管理
<br>设备管理<br>
目标：安全、高效
<br>操作系统提供的服务<br>
<br>GUI 服务：图形化用户接口，用户可以图形界面进行操作，不需要再借助复杂的命令、
<br>联机命令接口：（交互式命令接口），用户说一句，操作系统跟着做一句
<br>脱机命令接口：（批处理命令接口），用户说一堆，操作系统做一堆
<br>程序接口：供程序员使用，普通用户不能直接使用程序接口，只能通过代码调用来间接使用程序接口<br>
<img alt="Pasted image 20250520152249.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520152249.png">

解释为什么用户和操作系统之间有连接，而不是通过应用软件与操作系统进行连接，程序员可以通过编写代码进行系统调用，通过程序接口间接的调用操作系统


<br>操作系统需要对硬件机器进行拓展<br>
——操作系统将 CPU、内存、磁盘、显示器、键盘等硬件合理的组织起来，让各种硬件相互协调配合，实现更多更复杂的功能<br>没有任何软件的机器称为裸机，在裸机上安装操作系统，可以提供资源管理和方便用户服务的功能，将裸机改造成更强、更方便的机器<br>通常把覆盖了软件的机器称为扩充机器，也成为虚拟机<br><br>——并发、共享、虚拟、异步<br>
并发和共享是最基本的特征，二者互为存在条件<br>并发：指两个或多个事件在同一时间间隔内发生，宏观上同时发生，但是在微观上交替发生<br>
并行：指两个或多个事件同时发生<br><br>——指的是操作系统中同时运行着多个程序，这些程序在宏观上看是同时运行的，但是在围观上看是交替运行的<br>单核 CPU 同一时刻只能运行一个程序，所以对于单核 CPU 只能并发的执行<br>
多核 CPU 同一时刻可以运行多个程序，所以对于多核 CPU 来说，可以并行执行程序<br><br>——资源共享，是指系统中的资源可供多个并发执行的进程共同使用<br><br>——理论上这个资源可以共享给所有的进程，但是一段时间内只能提供给一个进程<br><br>——计算机中的某些资源允许一个时间段有多个进程“同时”对它们进行访问【分时共享】<br>
并发和共享的关系：举个例子：微信和 QQ 同时进行文件的发送<br>
1：两个进程正在并发的执行<br>
2：都需要共享的进行硬盘数据的访问<br>
如果失去并发性，则系统中只有一个程序正在运行，则共享性失去意义<br>
如果失去共享性，则微信和 QQ 无法同时发送数据，并发也就无法进行
<br><br>——虚拟指的是把一个物理上的实体转换成逻辑上的对应物<br><br>虚拟处理器，将一段时间分成若干个小的片段，在各个微小的片段中交替的执行各种服务进程<br><br>虚拟存储器，将内存空间分成多个部分，在各个部分分别执行对应的程序代码<br>
没有并发性就谈不上虚拟性，也就不需要进行多个程序的执行<br><br>——在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可预知的速度向前推进<br><br><br>用户独占全机，用户与计算机速度不匹配导致计算机资源利用率低<br><br>单道批处理系统<br>
将纸带先写入磁带中，然后由监督程序控制作业的输入输出，主要作用是提高了输入和输出效率，使得计算部分占比更高<br>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升<br>
多道批处理系统<br>
操作系统正式诞生，当计算机在进行计算时，可以读取出第二个作业的内容，等第二个作业进行计算时，可以将第一个作业的结果写在磁带上<br>主要优点：多道程序并发执行，共享计算机资源，资源利用率大幅提升，CPU 和其他资源能保持更加忙碌的状态，系统吞吐量大，IO 设备利用率高<br>主要缺点：不提供人机交互的功能，【用户提交作业任务之后就只能等待计算机处理完成，中间不能控制自己作业的执行、调试等】<br><br>——计算机以时间片为单位，轮流为各个作业进行服务，用户可以通过终端与计算机进行交互<br>主要优点：可以实时相应用户的请求，解决了人机交互的问题，允许多个用户同时使用一台计算机，并且用户对计算机的操作请求相互独立，感受不到别人的存在<br>主要缺点：不能优先处理紧急的任务，操作系统对各个用户/作业是完全公平的，循环的为每个用户进行服务，不区分任务的紧急性<br><br>——实时操作系统能够根据任务的优先级，能够优先的相应一些紧急任务，某些紧急任务不需要时间片排队<br>
在实时操作系统的控制下，计算机系统在接收到紧急的信号之后能够及时进行处理，并且要在严格的时限内处理完成，实时操作系统的主要特点是实时性和可靠性<br>硬实时操作系统<br>
必须在严格的时限内完成处理<br>
软实时操作系统<br>
能接收偶尔违反时间规定]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\1.1：操作系统.html</link><guid isPermaLink="false">review/操作系统/1.操作系统概念/1.1：操作系统.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Tue, 20 May 2025 13:48:44 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520152249.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\1.操作系统概念\img\pasted-image-20250520152249.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[死锁、饥饿、死循环的区别]]></title><description><![CDATA[ 
 <br><br>——死锁就是多个进程因竞争资源造成的僵局（互相等待对方手里的资源），使得各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进<br>
死锁至少有两个或者两个以上的进程发生死锁，发生死锁的进程必定在阻塞态<br>——饥饿指的是长期得不到想要的资源，某些进程无法向前推进的现象<br>
可能只有一个进程发生饥饿，可能长期处于阻塞态（长期无法获取到一个 IO 设备等），也可能长期处于就绪态（长期无法获得处理机）<br>——死循环指的是某个进程在执行的过程中，一直不跳出某个循环的现象，有时是程序 bug 导致的，有的是有意为之<br>
可能只有一个进程发生死循环，死循环可以上处理机运行，可能处于就绪态<br>死锁和饥饿可能是操作系统资源分配不合理导致的，死循环是由写程序的人导致的<br><br>
<br>互斥条件：必须使用互斥方式访问的资源争抢时才可能会导致死锁，向内存、扬声器等这些可以同时让多个进程访问的资源是不会导致死锁的
<br>不可剥夺条件：进程对资源的使用完成之前不能由其他进程强行夺走，只能由进程主动释放
<br>请求和保持资源：进程已经保持了一个资源，但又向另一个新的资源提出请求，但该资源被另一进程占有，此时当前进程的执行被阻塞，但已经获得的资源不释放
<br>循环等待条件：存在一个进程资源的等待链，链中的每个进程已获得的资源同时被下一进程所请求<br>
以哲学家进餐问题为例可以更好的理解上述四个条件
<br>
注意：发生死锁时必定又循环等待，但是有循环等待不一定发生死锁（循环等待是发生死锁的必要不充分条件）<br>
如果等待的同类资源大于 1，那么循环等待不一定导致死锁，但是如果等待的同类资源等于 1，那么循环等待就是死锁的充分必要条件
<br><br>
<br>
系统资源的竞争：各进程对不可剥夺的资源的竞争可能会引发死锁（例如磁带机、打印机），对于可剥夺资源的竞争是不会发生死锁的

<br>
进程推进顺序非法：请求和释放资源的顺序不当，例如并发的进程 P 1、P 2 分别申请了资源 R 1、R 2，但是此时 P 1 再申请 R 2，P 2 再申请 R 1，从而就会发生死锁

<br>
信号量使用不当也会导致死锁：把实现互斥的 P 操作在实现同步的 P 操作之前，可能也会导致死锁

<br><br><br>——破坏死锁的四个必要条件的其中一个或几个<br><br>若将只能互斥访问的资源改为可以共享访问，那么就可以避免死锁的产生，但是有的资源并不能同时访问，例如某些临界资源只能互斥访问，所以破坏互斥预防死锁的方法不太可行<br><br>并不是所有的资源都能够改成可以共享访问的资源，并且为了系统安全，很多地方必须保证这种互斥性，因此很多时候都无法破坏互斥条件<br><br>法一：当一个进程请求资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请，及时某些资源尚未使用完，也需要将资源释放<br>法二：当某个进程所需要的资源被其他进程占有的时候，由操作系统协助将想要的资源强行剥夺，这种方式需要考虑到进程的优先级，优先级高的进程可以剥夺优先级低的进程手中的资源<br><br>
<br>实现起来较为复杂
<br>释放已经获得的资源可能会导致前一段时间的工作失效，这种方法一般适用于易保存和恢复状态的资源，如 CPU 寄存器和内存资源
<br>反复的申请和释放资源会增加系统开销，进而降低了系统吞吐量
<br>如果采用第一种方案，只要得不到某个资源，之前获得的资源就会释放，以后再重新申请，如果一直发生这种情况可能会导致进程饥饿
<br><br>法一：采用静态分配方法：既程序在运行前一次申请完它所需要的全部资源，如果资源条件不满足，就不能投入运行，一旦投入运行之后这些资源就归它所有，该进程就不会再申请其他资源<br>法二：允许进程获取到对应的资源之后，进程在运行过程中依次释放对应资源<br><br>对于有的资源只需要使用很短的时间，如果进程运行的期间占用所有的资源的话，会造成资源的严重浪费，资源利用率低，也可能会导致某些进程饥饿<br>
<img alt="Pasted image 20250528150658.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250528150658.png"><br>
例如：只要资源 1 和资源 2 没有同时释放，那么对应的资源 1 就会给 A 类进程使用，资源 2 会优先给 B 类进程使用，那么 C 类进程长期的不到对应的资源就会造成饥饿现象<br>方法二就改进了这一缺点<br><br>采用顺序资源分配法：将系统中的资源进行编号，规定每个进程只能按照编号递增的顺序进行资源的访问，同类资源以此申请完<br>一个进程只有占有小编号的资源，才能有资格申请大编号的资源，但是占有大编号的资源的进程不能反过来申请小编号的资源。从而就避免了循环等待事件<br>任何时刻总有一个进程占有的资源编号是最大的，那这个进程对后面资源的申请必然是畅通无阻的，不会出现所有进程都阻塞的状态<br><br>不方便新增加设备：因为可能需要重新分配所有的编号<br>
进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费<br><br>——用某种方法避免系统进入不安全的状态，从而避免死锁（银行家算法）<br><br>避免死锁的算法中，允许进程动态的申请资源，但是在系统分配资源之前，应先计算此次分配的安全性，若此次分配不会导致系统进入不安全状态，则允许分配，否则让进程等待<br>安全状态<br>
是指系统能按照某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可以完成，此时称这个进程执行序列为安全序列（可能有多个），如果系统找不到一个对应的安全序列，那么系统处在不安全状态<br>系统处于安全状态一定不会发生死锁，如果系统在不安全状态，可能发生死锁(系统进入不安全状态就未必发生死锁，但是发生死锁时一定在不安全状态)<br><br>——在资源分配之前先判断此次资源分配是否会导致系统进入不安全状态，以决定是否要进行此次的资源分配<br>
如何将算法思想扩展到有多种资源中<br>
可以将单维的数字扩展到多维的向量中，也就是将整体资源看作是一个变量，对多个资源进行分配，然后判断剩余的资源是否能够满足剩下进程的需要
<br>数据结构描述<br>
假设系统中有 n 个进程，m 种资源，在银行家算法中需要定义下面四个数据结构<br>
<br>可利用资源向量：长度为 m 的数组表示当前系统中还有多少可用资源 Available
<br>最大需求矩阵：定义每个进程对每一种资源的最大需求量，n 行 m 列的矩阵，每一行对应一个进程Max
<br>分配矩阵：表示当前系统对进程已经分配的资源数量，n 行 m 列矩阵，每一行对应一个进程Allocation
<br>需求矩阵：表示每个进程还需要多少资源，n 行 m 列矩阵 Need
<br>对于上述三种矩阵存在如下关系：
Need = Max-Allocation

使用一个长度为m的Request数组表示第i个进程所需要请求的对应资源数量
Request[]
1.如果Request[j]&lt;=Need[i][j],那么转到2,否则出错
2.如果Request[j]&lt;=Available[i][j],转到3,否则表示系统中没有足够的资源,必须等待
3.系统试探的将资源分配给对应进程,并修改对应的数据(注意此时并非真正的分配,修改数值只是做预判)
4.Available[j] -= Request[j];Allocation[i][j]+=Request[j];Need[i][j] -= Request[j]
5.操作对应安全部分算法,检查资源分配之后系统是否处于安全状态,如果安全,那么就正式分配,否则恢复相应数据,让进程阻塞等待
<br>银行家算法步骤<br>
<br>检查申请资源数是否超过了之前声明的最大需求
<br>检查此时系统剩余资源是否满足这次请求
<br>试探着分配资源，并且修改对应数据结构
<br>用安全性算法检查这次分配是否会导致系统进入不安全状态
<br>如果不安全，那么就回退，将试探分配的资源回收
<br>安全性检查算法步骤<br>
<br>检查当前资源是否能够满足某个进程的最大需求，如果可以就把它加入安全序列，并把对应进程占有的资源全部回收
<br>不断重复上述过程，查看是否能够将所有的进程都加入安全序列
<br><br>——允许死锁的产生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁<br><br>
<br>用某种数据结构来保存资源的请求和分配
<br>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态<br>
两种节点
<br>进程节点：对应一个进程
<br>资源节点：用于表示一类资源，一类资源可能有多个<br>
两种边：
<br>进程节点----&gt;资源节点：表示进程想申请几个资源(每条边代表一个)
<br>资源节点----&gt;进程节点：表示为进程分配了几个资源 (每条边代表一个)
<br>如果系统种的资源能够满足进程的需求，那么这个进程可以执行，执行完毕之后把资源归还给系统，能使某些等待资源的进程激活，并且顺利执行下去，申请资源时建立进程到资源的边，分配资源时，建立资源到进程的边，释放资源时，擦除进程于资源间的所有边，如果最终能够消除所有的边，那么就说这个图是可简化的，此时一定没有发生死锁<br>简化算法<br>
<br>在资源分配图种找到既不阻塞也不是孤点的进程，首先判断其是否满足执行条件，如果能那么就删除其所有入边和出边，使其称为孤点
<br>然后找到其他的不阻塞和不是孤点的进程重复步骤一
<br>最终查看是否能够将图中所有的边消去，如果能，说明可简化，进程不会发生死锁，如果不能那么就发生死锁
<br><br>——一旦检测出死锁的发生那么就立即解除死锁<br>
并不是系统中所有进程都是死锁进程，只有执行过简化算法之后还存在边的进程称为死锁进程<br>解决方法<br>
<br>
资源剥夺法<br>
将死锁的进程给挂起，释放对应占用的资源，将这些资源分配给其他死锁的进程，但是应当防止挂起时间很长的进程产生饥饿现象

<br>
撤销进程法<br>
强制撤销部分、甚至全部死锁进程，并且剥夺这些进程的资源，将其分配给其他进程，<br>
这种方法实现起来和简单，但是代价会很大，有的进程可能执行很长时间了，如果撤销进程会导致进程的重新执行

<br>
进程回退法<br>
让一个或者多个进程回退到足以避免死锁的地步，这就要求系统记录进程的历史信息，设置还原点

<br>决定优先操作哪个阻塞的进程<br>
<br>进程优先级（优先操作优先级低的）
<br>还要执行多长时间（优先操作执行时间少的）
<br>还有多久能完成（优先操作剩余时间多的）
<br>进程已经使用了多少资源（优先操作占用资源多的）
<br>进程是交互式的还是批处理的（优先操作批处理的）
]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\2.4死锁.html</link><guid isPermaLink="false">review/操作系统/2.进程、线程/2.4死锁.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 28 May 2025 08:33:53 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250528150658.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250528150658.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[基本概念的引入]]></title><description><![CDATA[ 
 <br><br>为什么需要进程同步<br>
答：因为程序异步执行都会以独立的，不可预知的速度向前推进，但是有的进程之间有相互约束，所以需要将进程按照一定顺序执行<br>什么是进程同步<br>
答：同步亦称为直接制约关系，它是指为了完成某个任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系，进程之间的直接相互制约关系就是源于他们之间的相互合作<br>什么是进程互斥<br>
答：在一个时间段内只允许一个进程访问的资源，这种资源也称为临界资源，对临界资源的访问就需要互斥的进行<br>对于临界资源的互斥访问，可以在逻辑上分为四个部分<br>while(true)
{
	entry section;        //进入区
	critical section;     //临界区
	exit section;         //退出区
	remainder section;    //剩余区
}
<br>
<br>进入区：作用就是检查能不能访问这个临界区资源的作用，如果可以的话，就会对临界资源进行上锁的操作，其他进程想要访问临界资源的时候，检查进入区就会发现有进程正在访问临界区资源
<br>临界区：就是实际访问临界区资源的那段代码（例如打印机打印输出，对打印机执行的写操作就是临界区）
<br>退出区：作用就是解除正在访问临界区资源的标志，可以理解为解锁
<br>剩余区：代码中的其余部分

临界区是访问临界资源的代码，进入区和退出区是负责实现互斥的代码段<br>
临界区也可称为临界段


<br>需要遵循的原则<br>
<br>空闲让进：临界区空闲时，可以允许有一个请求进入临界区的进程立即进入临界区【必须实现】
<br>忙则等待：若已有进程在访问临界区的话，那么其余进程就需要等待【必须实现】
<br>有限等待：对于请求访问临界区的进程，需要保证其在有限的时间内能够进入临界区（避免饥饿现象）【必须实现】
<br>让权等待：当进程不能进入临界区时，应该立即释放处理机，防止进程处于忙等待的状态【不一定非得实现】
<br><br><br>算法思想：两个进程在访问完临界区之后会把临界区的权限交给另一个进程，也就是说每个进程进入临界区的权限只能由另一个进程赋予<br>定义一个变量 turn<br>
<br>如果 turn = 0 的话，则允许 0 号进程进入临界区
<br>如果 turn = 1 的话，则允许 1 号进程进入临界区
<br>//进程0
while(turn ！= 0);        //进入区，判断是否允许当前进程访问临界区
critical section;    //临界区：进入临界区访问临界资源
turn = 1;            //退出区：修改turn的值,将临界区资源交给下一个进程
remainder section;   //执行剩余区代码

//进程1
while(turn ！= 1);    //如果不等于1，那么就一直循环等待
critical section;
turn = 0;
remainder section;
<br>
如果此时 turn = 0，但是进程 1 调用临界区资源，则会一直卡在进入区的部分，直到时间片用完，然后进行调度，切换进程 1 上处理机运行<br>
此时进程 0 正在访问临界资源，如果此时发生进程调度，进程切换为进程 1，进程仍然会卡在进入区，直到时间片用完
<br>因此上述算法可以实现最多时刻只允许一个进程访问临界区资源<br><br>因为此算法每次只能由一个进程访问临界区资源，并且需要交替的访问，如果某一个进程不再进入临界区，那么另外一个进程也无法访问临界资源（例如，进程 P 顺利从临界区离开，将临界资源给进程 Q 使用，但是如果 Q 没有进入临界区的打算，也会导致进程 P 无法访问临界资源，因为 turn 的值声明只能由进程 Q 访问临界资源），<br>
违反了空闲让进的原则<br><br>设置一个 bool 类型的数组 flag[]，如果 bool 值为 false 时，说明对应进程不想进入临界区，如果 bool 值为 true 时，说明对应进程需要进入临界区<br>
每一个进程在进入临界区之前都会检查对方是否想进入临界区<br>//进程0
while(flag[1]);   //如果对方想用，那么一直循环等待
flag[0] = true;
critical section;
flag[0] = false;
remainder section;

//进程1
while(!flag[0]);
flag[1] = true;
critical section;
flag[1] = false;
remainder section;
<br>
<br>进程在访问临界资源时，首先检查另一个进程是否想访问临界区资源
<br>如果想则就会陷入循环等待
<br>如果不想，那么该进程就会访问临界资源，将自己的 flag 值设为 true，使用完临界资源之后将 flag 值设为 false
<br><br>如果两个进程在并发执行时，如果在进程 1 判断完成之后，执行 flag 值转换之前，如果此时发生系统调度，转到进程 0，此时进程 0 会发现进程 1 的 flag = false，此时进程 1 会访问对应的临界资源，然而进程 1 此时也想要访问临界资源，所以此时就出现问题，两个进程同时进入了临界区<br>
违反了“忙则等待”的原则，原因在于“检查”和“上锁”两个处理不是一气呵成的，二者之间可能会发生进程调度<br><br>算法思想：与双标志先检查法的不同的是，在此算法中会先上锁然后再检查<br>//进程0
flag[0] = true;        //先上锁
while(!flag[1]);       //对方想用则循环等待
critical section;
flag[0] = false;
remainder section;

//进程1
flag[1] = true;
while(flag[0]);
critical section;
flag[1] = false;
remainder section;

<br>
<br>进程在访问临界资源时，先上锁，将对应 flag 的值置为 true
<br>检查另一进程是否想要访问临界资源
<br>如果另一进程不想访问临界资源，那么当前进程就进行临界资源的访问
<br><br>当进程 1 先发起资源请求时，此时会将 flag 置为 1，然后再判断，如果此时发生进程中断，进程 0 如果提出临界资源的访问，然后再判断，此时因为进程 1 的 flag 为 1，所以会等时间片用完之后调度进程 0，然而进程 0 面对的也是同样的问题，两个进程都无法访问临界资源，产生饥饿现象<br>
违背了“空闲让进”和“有限等待”的原则<br><br>算法思想：结合了单标志法和双标志法的核心，如果双方都争着进入临界区，进程就会将临界区让给对方<br>bool flag[2];    //用来表示临界区意愿的数组，初始值都是false
int turn = 0;    //turn表示优先让哪个进程访问临界区
c
//进程0
flag[0] = true;    //表示自己想要进入临界区
turn = 1;          //将turn的值设为对方的编号，表示对方可以优先进入
while(!flag[1]&amp;&amp;turn == 1);    //对方想进入临界区,并且是我自己表达的谦让，对方并没有让回来
critical section;
flag[0] = false;
remainder section;

//进程1
flag[1] = true;
turn = 0;
while(flag[0]&amp;&amp;turn == 0);
critical section;
flag[1] = false;
remainder section;

<br>该算法并未遵循“让权等待”的原则<br><br><br>一个进程在访问临界资源之前会执行关中断指令，访问完成之后再关中断<br>关中断
临界区
开中断
<br>关中断之后不允许当前进程被中断，必然也不会发生进程切换，直到访问完临界区的资源之后，执行开中断指令，才有可能有别的进程上处理机并访问临界区<br>
优点：<br>
简单、高效<br>缺点：<br>
<br>不适用于多处理机系统，因为一个 CPU 上的关中断不能限制其他 CPU 对临界资源的访问
<br>只适用于内核进程，将关中断和开中断的权限交给用户态程序很不明智，如果一个进程关中断之后不再开中断，系统很可能因此停止
<br>限制了 CPU 交替执行程序的能力，因此效率会明显降低
<br><br>——TS（TSL）指令是硬件实现的，只能一气呵成，不允许被中断<br>
算法思想：为临界资源设置一个共享变量 lock 表示该资源的两种状态，true 表示该资源被占用，false 表示未被占用<br>/*
bool类型变量lock表示临界区是否被加锁
true表示已加锁，false表示为加锁
下面只是指令的功能描述，并非使用代码实现，实际是由硬件实现的，是能一气呵成的实现，不能中断
*/
bool TestAndSet(bool *lock)
{
	bool old;
	old = *lock;     //old用来保存以前的值
	*lock = true;    //当前进程需要访问临界资源
	return old;      //返回之前的lock值
}

while(TestAndSet(&amp;lock));    //如果之前的lock为true的话，那么一直循环等待其他进程的解锁
临界区代码;
lock = false;       //解锁
剩余区代码;
<br>解决了双标志位先检查法的问题：上锁和检查不是一气呵成的，在 TestAndSet 指令中是一气呵成的<br>
未能实现让权等待，因为等待进入临界区的进程会占用 CPU 执行 TS 指令<br><br>——Swap 指令也叫 Exchange 指令或者简称 XCHG 指令<br>
Swap 指令是用硬件实现的，执行过程同样不允许被中断，只能一气呵成，下面使用 c 描述<br>
//Swap指令的作用是交换两个变量的值
void Swap(bool *a,bool *b)
{
	bool temp = *a;
	*a = *b;
	*b = temp;
}

//下面是使用swap指令实现互斥的算法逻辑
//lock表示的是临界区资源是否加锁
bool old = true;
while(old == true)//如果old一直为true就执行循环，lock为false并且与old进行交换，然后跳出循环
	Swap(&amp;lock,&amp;old);
临界区代码段     //进入临界区
lock = false;
剩余区代码段
<br><br><br>——解决临界区资源最简单的工具就是互斥锁<br>
<br>一个进程在进入临界区时应获得锁
<br>进程在退出临界区时应该释放锁
<br>//获得锁
viod acquire()
{
	while(!available);      //忙等待，有其他进程获得了锁，所以需要一直循环等待锁的释放
	available = false;      //获得锁，将资源可访问设置为false
}

//释放锁
viod release()
{
	available = true;       //将资源可访问设置为true
}
<br>缺点：<br>
互斥锁的主要缺点就是忙等待，当一个进程在临界区，那么其他进程需要连续循环调用 acquire，当进程共享一个 CPU 时就浪费了 CPU 周期<br>
所以互斥锁一般用于多处理机，一个线程在一个 CPU 上等待时，其他线程可以在其他 CPU 上运行<br>需要连续忙等待的互斥锁都成为自旋锁，如 TSL 指令、swap 方法、单标志法<br>特点：<br>
<br>需忙等，进程时间片用完才下处理机，违反让权等待
<br>优点：进程等待期间不需要切换上下文，多处理机系统中，若上锁时间很短，则等待代价很小
<br>常用于多处理机，一个核忙等，其他核可以正常工作，并且快速释放资源
<br>不太适用于单处理机系统，忙等的过程中不可能解锁
<br><br>——信号量机制是一种功能比较强的机制，可以用来解决互斥和同步问题，他只能被两个原语 wait 和 signal 访问，也可以简写为 P()和 V()，可以使用上述操作来操作信号量 <br><br>——用一种整数型的变量作为信号量表示系统中某种资源的数量<br>/*
下面的wait和signal函数在运行时是一气呵成的，并不会出现执行过程中断的问题
*/

int S = 1;     //初始化信号量S，表示可用的资源数
void Wait(int S)
{
	while(S&lt;=0);  //资源不够，一直循环等待
	S=S-1;        //资源够用，占用一个资源
}

void Signal(int S)
{
	S = S+1;     //释放一个资源
}

//进程访问临界资源的步骤
Wait(S);
使用打印机资源;
Signal(S);
<br><br>不满足让权等待的原则，当进程无法获取到对应的资源，那么会一直循环等待，直到时间片到达下处理机<br><br>——整形信号量的缺陷是存在忙等问题，因此就提出了记录行信号量<br>//记录型信号量的定义
typedef struct{
	int value;           //剩余资源数
	struct process *L;   //进程等待队列
}semaphore;

//进程访问临界资源的步骤
void wait(semaphore S)
{
	S.value--;         //首先占用资源
	if(S.value&lt;0){      //检查资源是否能够支持被占用
		add this process to S.L;
		block(S.L);    //将进程从运行态转到阻塞态,转到等待队列中
	}
}

//signal操作
void signal(semaphore S)
{
	S.value++;        //释放占用的资源
	if(S.value&lt;=0){    //表明在此之前还有进程需要访问这个资源
		remove a process P from S.L
		wakeup(P);  //唤醒进程，将其从阻塞态转为就绪态
	}
}
<br>
如果 vlaue 小于 0, 那么就说明还有多少个进程在等待临界资源的释放
<br>
<br>对信号量 S 执行以此 P 操作, 意味着请求一个单位的资源, 需要执行 S.vaue--, 如果S.value&lt;0, 则说明资源已经分配完毕, 进程需要调用 block 进行阻塞, 主动放弃处理机, 遵循了"让权等待"的原则, 不会出现忙等的状态
<br>对信号量进行一次 V 操作, 意味着一单位的资源已经释放, 需要执行 S.value++, 如果+1 之后S.value 仍然小于 0, 则说明还有进程需要访问这个临界资源, 此时应该用 wakeup 原语唤醒一个进程, 被唤醒进程从阻塞态到就绪态
<br><br>
<br>分析并发进程的关键活动, 划定临界区
<br>设置互斥信号量 mutex, 初值为 1 (信号量 mutex 表示进入临界区的名额)
<br>进入临界区 P (mutex)
<br>离开临界区 V (mutex)<br>
注意: 实现进程的互斥必须将 mutex 设置为 1, 对于不同的临界资源设置的 mutex 应该不一样, 表示不同的临界资源<br>
PV 操作必须成对出现: 如果没有 P 操作, 那么就不能保证资源的互斥访问, 如果缺少 V 操作, 那么等待的进程就永远不会被唤醒
<br><br>——进程同步就是让个并发的进程有序的执行<br>
<br>什么地方需要保证进程的同步关系，必须保证一前一后的执行
<br>设置同步信号量 S，初始值为 0
<br>在前操作后面执行 V (S)
<br>在后操作前面执行P(S)<br>
例如，需要将代码 4 在代码 2 之后运行，可以在 code2 后加一个 V 操作，code 4 前加一个 P 操作
<br>//初始化S的值为0
semaphore S = 0;

P1()
{
	code 1;
	code 2;
	V(S);        //执行一个V操作，以便于后面的P操作能够正常运行
	code 3;
}

P2()
{
	P(S);        //必须等待V操作之后才能执行P操作
	code 4;
	code 5;
	code 6;
}
<br>
对于上述代码只有 code 2 后面的 V 操作之后才能执行 P 操作后面的 code4，否则就需要等待
<br><br><img alt="Pasted image 20250524162954.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250524162954.png"><br>
对于上述这种有前驱关系的执行流程图来说。每一对关系都对应一个进程同步问题
<br>
<br>为每一对同步关系设置一个信号量
<br>在对应前操作之后执行一个 V 操作
<br>在对应后操作之前执行一个 P 操作
<br>
seamphore a12 = a13 = a24 = a25 = a46 = a56 = a36 = 0;//初始化信号量
S1()
{
	进程S1执行;
	V(a12);      //唤醒对应的进程
	V(a13);
}

S2()
{
	P(a12);
	进程S2执行;
	V(a24);
	V(a25);
}

S3()
{
	P(a13);
	进程S3执行;
	V(a36);
}

S4()
{
	P(a24);
	进程S4执行;
	V(a46);
}

S5()
{
	P(a25);
	进程S5执行;
	V(a56);
}

S6()
{
	P(a36);
	P(a56);
	P(a46);
	进程S6执行;
}
<br><br>在系统中有生产者进程和消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品使用（这里的产品指某种数据）<br>
<br>生产者和消费者共享一个缓冲区
<br>只有缓冲区没满时，生产者才能向缓冲区中放数据，否则等待
<br>只有缓冲区中不为空时，消费者才能从缓冲区中取数据，否则等待
<br>缓冲区是临界资源，生产者需要互斥的访问缓冲区
<br>设置各信号量的初始值，互斥信号量mutex为1，生产者同步信号量为空的缓冲区大小，empty为n，消费者信号量为资源的数量。full初始值为0
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

producer()
{
	while(true)
	{
		生产一个产品;
		P(empty);      //1：申请一个空闲的缓冲区
		P(mutex);      //6：缓冲区资源互斥，需要对mutex进行PV操作
		把产品放入缓冲区
		V(mutex);
		V(full);       //2：表示增加了一个产品的数量

	}
}


consumer()
{
	while(true)
	{
		P(full);       //3：从缓冲区中拿取数据
		P(mutex);
		从缓冲区中拿产品
		V(mutex);
        V(empty);      //4：增加了一个空闲缓冲区的数量
		使用产品

	}
}
<br>
实现互斥操作是在同一个进程的代码中进行 PV 操作实现的，但是同步关系就是在两个进程中进行 PV 操作，一个进程进行 V 操作，然后另一个进程进行 P 操作，执行 V 操作的进程完成之后会唤醒对应执行 P 操作的进程，实现互斥的 P 操作一定要在实现同步的 P 操作之后，否则会造成死锁的现象，两个进程都在同时等待被对方唤醒，V 操作不会影响进程阻塞，因此 V 操作可以交换位置
<br><img alt="Pasted image 20250524170755.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250524170755.png"><br>
实现互斥的 P 操作一定要在实现同步的 P 操作之后<br><br>多类生产者和多类消费者共享同一个缓冲区，生产者和消费者生产和消费的东西不一样<br>
例如：生产者 1、生产者 2、消费者 1、消费者 2，共享空间<br>
分析：<br>
<br>互斥关系：对于共享空间的访问需要互斥
<br>同步关系：生产者 1 完成之后消费者 1 才能执行<br>
生产者 2 完成之后消费者 2 才能执行<br>
只有共享空间为空时生产者才能往里写入内容
<br>/*
首先定义mutex = 1;实现互斥锁
然后定义product1 = 0;表示当前产物为0
定义product2 = 0;表示当前产物2
定义buf = 1;表示当前缓冲区的大小
*/

//producer1
produce1()
{
	while(1)
	{
		准备一个产物1
		P(buf);
		P(mutex);
		将产物放入共享空间
		V(mutex);
		V(product1);
	}
}

//producer2
producer2()
{
	while(1)
	{
		准备一个产物2
		P(buf);
		P(mutex);
		将产物放入共享空间
		V(mutex);
		V(product2);
	}
}

//consumer1
consumer1()
{
	while(1)
	{
		P(product1);
		P(mutex);
		从共享空间中取出product1
		V(mutex);
		V(buf);
		消费product1
	}
}

//consumer2
consumer2()
{
	while(1)
	{
		P(product2);
		P(mutex);
		从共享空间中取出product2
		V(mutex);
		V(buf);
		消费product2
	}
}
<br>对于生产者和消费者的问题需要从事件来考虑，重点关注资源的变化，资源变化引发事件的变化<br><br>有多个进程对同一个文件进行读写操作，规定<br>
<br>允许多个进程同时对文件进行读操作
<br>只允许一个写进程往文件中写信息
<br>任一写者写完之前，不允许其他读者、写者进行操作
<br>写者执行写操作之前应让所有的读者和写者退出
<br>分析：<br>
<br>互斥关系：读进程-写进程、写进程-写进程
<br>读进程和读进程之间不存在互斥关系
<br>semaphore rw = 1;   //设置rw信号量实现互斥访问
int count = 0;      //表示有多少个读进程在访问文件
semaphore mutex = 1; //保证count的判断以及赋值是一气呵成的

//写进程解决与读进程和写进程之间的互斥问题
writer()
{
	while(1)
	{
		P(rw);
		写文件
		V(rw);
	}
}

//读进程主要解决的是与写进程之间的互斥问题
reader()
{
	while(1)
	{
		P(mutex)      //使进程之间互斥访问count
		if(count==0)
			P(rw);       //第一个读进程对文件进行加锁
		count++;
		V(mutex)
		读文件
		P(mutex)
		count--;
		if(count==0)
			V(rw);      //最后一个读进程对文件进行解锁
		V(mutex)
	}
}
<br>
对于上述进程，如果，两个进程并发的对文件进行访问，都会认为 count=0，然后给文件加锁，此时另外一个进程进行加锁时会发现文件已经被加锁，所以会发生阻塞<br>
问题出现的原因是因为：进程对 count 的判断和++操作不是一气呵成的，而是可以被中断的，解决办法，可以使进程之间互斥的访问 count 变量
<br>潜在的问题<br>
——如果一直有读进程在读，那么写进程就会一直等，可能会出现饿死的现象，可以认为读进程有更高的优先级<br>解决写写进程优先级低的问题<br>
——如果有一个写进程申请写文件，那么后续的读进程的读操作都需要终止，是一个互斥的关系<br>
引入一个新的信号量 w，用来保证写进程的优先级<br>semaphore rw = 1;   //设置rw信号量实现互斥访问
int count = 0;      //表示有多少个读进程在访问文件
semaphore mutex = 1; //保证count的判断以及赋值是一气呵成的
seamphore w = 1;    //用于解决写进程饥饿的问题

//写进程解决与读进程和写进程之间的互斥问题
writer()
{
	while(1)
	{
		P(w);
		P(rw);
		写文件
		V(rw);
		V(w)
	}
}

//读进程主要解决的是与写进程之间的互斥问题
reader()
{
	while(1)
	{
		P(w)
		P(mutex)      //使进程之间互斥访问count
		if(count==0)
			P(rw);       //第一个读进程对文件进行加锁
		count++;
		V(mutex)
		V(w)
		读文件
		P(mutex)
		count--;
		if(count==0)
			V(rw);      //最后一个读进程对文件进行解锁
		V(mutex)
	}
}

<br>
分析：对于读进程的并发，如果此时有一个写进程申请对文件的访问，首先会对 w 进行 P 操作，然后后续的读进程就暂时无法访问文件资源，只能等到写进程结束之后才能获得 w 信号量，然后才能继续读进程接下来的操作
<br>对于信号量 w 来说，就是起到一个先来先服务的作用<br><br>——一个圆桌上有若干位哲学家，他们只有思考和进餐这两个动作，每个哲学家的左手和右手都只有一根筷子，只有左右两根筷子都存在才能正常进餐，否则产生阻塞<br>
分析：<br>
<br>每个哲学家与其左右的哲学家存在互斥关系，因为只有在左右两根筷子都存在的时候当前哲学家才能正常进餐
<br>需要两个临界资源才能正常进行，如何避免临界资源分配不当造成的死锁现象是问题的精髓<br>
信号量设置：设置信号量数组{1，1，1，1，1}，将哲学家进行编号 0，1，2，3，4，对于第 i 个哲学家左边的筷子编号为 i，右边的筷子编号为（i+1）%5
<br>semaphore chopsticks[5] = {1,1,1,1,1};

Pi()
{
	while(1)
	{
		P(chopsticks[i]);
		P(chopsticks[(i+1)%5]);
		吃饭
		V(chopsticks[i]);
		V(chopsticks[(i+1)%5]);
		思考
	}
}
<br>问题的产生<br>
当所有的哲学家都之心那个吃饭时先申请左边的筷子，然后再申请右边的筷子，发现无法申请，所有哲学家都阻塞，发生死锁问题<br>
<img alt="Pasted image 20250527154457.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250527154457.png"><br>
如何防止死锁的发生呢<br>
<br>限制每次进餐的哲学家数量，至少保证有一个哲学家对临界资源的访问正常
<br>或者奇数号的哲学家先拿左边的筷子，偶数号的优先申请右边的筷子
<br>仅当哲学家左右两边筷子都在时才允许进餐，拿筷子这件事是互斥进行的<br>
通过以上方法，避免了进程占用资源之后发生阻塞的问题<br>
方法一
<br>semaphore count = 4;     //表示当前最多允许四个哲学家就餐
semaphore chopsticks[5] = {1,1,1,1,1};

Pi()
{
	while(1)
	{
		P(count);
		P(chopsticks[i]);
		P(chopsticks[(i+1)%5]);
		就餐
		V(chopsticks[i]);
		V(shopsticks[(i+1)%5]);
		V(count);
		思考
	}
}
<br>方法二<br>semaphore chopsticks[5] = {1,1,1,1,1};

Pi()
{
	while(1)
	{
		if(i%2==0)
		{
			//偶数编号优先申请右边
			P(shopsticks[(i+1)%5]);
			P(chopsticks[i]);
			就餐
			V(chopsticks[(i+1)%5]);
			V(chopsticks[i]);
			思考
		}
		else
		{
			P(chopsticks[i]);
			P(chopsticks[(i+1)%5]);
			就餐
			V(chopsticks[i]);
			V(chopsticks[(i+1)%5]);
			思考
		}
	}
}
<br>方法三<br>Semaphore chopsticks[5] = {1,1,1,1,1};

Pi ()
{
	While (1)
	{
		P(mutex);
		P (chopsticks[i]);
		P (chopsticks[(i+1)%5]);
		V(mutex);
		吃饭
		V (chopsticks[i]);
		V (chopsticks[(i+1)%5]);
		思考
	}
}
<br>
该方法每次只允许一个哲学家进行资源的申请，只有都满足时才能使哲学家进行就餐，但是会产生一个问题，不能正常进餐的哲学家会阻塞能够正常进餐的哲学家
<br><br>管程解决的问题：解决信号量机制大量同步操作分散的问题<br>
——信号量机制存在的问题，编程困难，易出错<br>
管程是一种高级的同步机制<br>
管程是一种特殊的软件模块，由这些部件组成<br>
<br>局部于管程的数据结构说明
<br>对该数据结构进行操作的一组说明
<br>对局部于管程的共享数据设置初始值
<br>管程有一个名字<br>
与 C++中的类相似，包含了构造函数，类对象，类函数等<br>
管程的基本特征
<br>局部于管程的数据只能由局部于管程的过程访问
<br>一个进程只有通过调用管程内的过程才能进入管程访问数据
<br>每次允许一个进程在管程内执行某个内部过程
<br>monitor ProducerConsumer
condition full,empty;
int count = 0;
void insert (Item item)
{
	if(count==N)
		wait(full);
	count++;
	insert_item(item);
	if(count==1)
		signal(empty);
}
Item Remove(Item)
{
	if(count==0)
		wait(empty);
	count--;
	if(count==N-1)
		signal(full)
	return remove_item();
}
end monitor

Producer()
{
	while(1)
	{
		item = product;
		ProducerConsumer.insert(item);
	}
}

Consumer()
{
	while(1)
	{
		item = ProducerConsumer.remove()
		consume = item
	}
}
<br>由编译器实现各进程互斥的进入管程中的过程<br>
对于信号的解释：<br>
<br>当消费者移出 item，如果此时为空，那么对应进程就会挂在 empty 信号的队尾
<br>当生产者执行时，发现缓冲区中一开始为空，那么就会发送 empty 信号唤醒对应 empty 信号后的进程
<br>当生产者生产时发现缓冲区已满，那么就会等待，将进程挂在 full 信号的队尾
<br>当消费者执行时发现缓冲区中一开始为满，取走元素之后发送 full 信号唤醒对应 full 信号后的进程
]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\2.3进程同步和互斥.html</link><guid isPermaLink="false">review/操作系统/2.进程、线程/2.3进程同步和互斥.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 28 May 2025 11:01:53 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250524162954.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250524162954.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[调度]]></title><description><![CDATA[ 
 <br><br>——对于多道程序系统中，进程的数量往往多余 CPU 的数量，CPU 调度就是对 CPU 进行分配，既从就绪队列中按照一定的算法选择一个 CPU 分配给它运行<br><br>作业：一个具体的任务<br>作业调度：按照一定的原则，从外存的作业后备队列中挑选一个作业调入内存，并创建进程（分配相应需要的计算机资源等），简而言之作业调度就是内存与辅存之间的调度，在作业的一个生命周期中，只能被调入一次，调出一次<br><br>——按照某种算法从进程就绪队列中选取一个进程，将处理机分配给它。<br>
进程调度是操作系统中最基本的调度，进程调度的频率很高<br><br>——当内存不够时，将那些不能运行的进程调至外存等待，此时的进程为挂起态，当它们具备运行的条件又有空闲的内存时，就会将进程再次调入内存中<br>目的：提高内存的利用率和系统吞吐量<br><br><img alt="Pasted image 20250522141710.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522141710.png"><br>
有的 OS 还会根据阻塞挂起的原因不同分别用不同的阻塞挂起队列来表示
<br>注意阻塞和挂起的区别，相同的地方就是二者都无法获取 CPU，但是阻塞时进程映像还在内 u 才能中，挂起时进程影响被调入外存中了<br>三级调度之间的关系<br>
<br>作业调度从外存的后备队列中选择一批作业进入内并且为其创建 PCB，分配对应的系统资源，然后将进程放在就绪队列中，之后等待进程调度，将就绪的进程转为执行，中级调度的作用是，当内存不足时就会将部分进程调出内存
<br><br>什么时候需要进行进程的调度<br>
<br>进程主动放弃 CPU：进程正常终止、异常、主动请求进阻塞
<br>进程被动放弃 CPU：分配的时间片用完、优先级更高的进程进入队列、中断
<br>什么时候不能进行进程调度<br>
<br>处理中断时不能进行进程调度
<br>进程在 OS 内核程序临界区中
<br>在原子操作的过程中
<br>
临界资源：一段时间内只能有一个进程使用的资源，各进程需要互斥的访问临界资源<br>
临界区：访问临界资源的那一段代码<br>
内核临界区：一般是用来访问内核中的某种数据结构的，比如进程的就绪队列
<br>在对内核临界区资源的访问过程中，首先会给对应的资源上锁（比如给就绪队列上锁），只有进程出内核临界区之后才能解锁，如果进程一直在内核临界区中，如果此时发生进程的调度问题，必须先访问就绪队列，由于还有进程处于内核临界区中，所以此时无法访问就绪队列，也就无法进行进程的调度 <br>对于普通的临界区资源的访问时，可以对进程进行调度，因为普通临界区资源的访问不会影响内核<br><br><br>——只允许进程主动的放弃处理机，即便有更加紧急的进程到达，也只能等待当前进程终止或者主动终止使用处理机<br>虽然非抢占式的开销小，但是无法处理计算机中的更加紧急的任务，所以只适合与早期的批处理系统<br><br>——当一个进程在处理机上运行时，有更加紧急的进程到达，则立即停止当前进程的执行，转去执行更加紧迫的进程<br>可以优先处理更紧急的进程，也可以按照进程的时间片轮转算法，轮流执行功能（通过时钟中断），适合于分时操作系统、实时操作系统<br><br>狭义的进程调度和进程切换，就是从进程就绪队列中选择一个进程（这个进程可以是刚刚被暂停执行的进程，也可以是另一个进程）<br>
进程切换：指的是一个进程让出处理机，另一个进程上处理机的过程<br>广义的进程切换包含了进程选择和进程切换两个过程<br>进程切换完成的内容<br>
<br>对原来的进程进行数据的保存（一般保存在进程控制块中）
<br>对调度的进程进行数据的恢复（从对应进程的进程控制块中恢复）
<br>注意：进程的切换是需要时间代价的，因此过于频繁的切换和进程调度必然会使整个 OS 的效率降低，使得系统大部分时间都花在了进程切换上，真正用于进程执行的时间减少，反而降低了进程之间的并发度<br><br>什么时间才会除法调度程序<br>
<br>创建新进程
<br>进程退出
<br>运行进程阻塞
<br>IO 中断发生
<br>非抢占式策略只有工作进程阻塞或者退出时才会执行调度程序
<br>抢占式策略只有时钟中断或者 k 个时钟周期中断才会除法调度程序工作
<br>不支持内核级线程的 OS 调度的对象是进程，支持内核级线程的调度对象是内核级线程<br><br>——程序调度的备胎，没有其他进程调度时，会运行闲逛程序<br>特性：<br>
<br>优先级最低
<br>可能是 0 地址指令，占用一个完整的指令周期（指令末尾例行检查中断）
<br>能耗低
<br><br> CPU 利用率<br>
——指的是 CPU 繁忙的时间占总时间的比例<br><br>系统吞吐量<br>
——单位时间内完成的作业数量<br><br>周转时间<br>
——从作业被提交给系统开始到作业完成的时间间隔<br>
一般包括四个部分<br>
<br>高级调度的时间：从外存转移到内存中的时间
<br>低级调度的时间：从就绪态转到执行的时间
<br>CPU 时间：进程在 CPU 上执行的时间
<br>等待 IO 的时间：进程等待 IO 设备完成的时间


<br><br>对于 OS 来说更关心系统的整体表现，更加关注平均周转时间<br><br>对于周转时间相同的进程来说，作业实际运行时间越长，时间越短，服务满意度更高<br>
带权周转时间肯定是大于 1 的，因为周转时间包含了作业运行时间<br><br>等待时间<br>
——指的是用户作业等待等待处理机的等待时间之和，等待时间越长用户满意度越低<br>
进程在就绪队列中等待被调度的时间，CPU 调度算法并不影响 OI 操作的时间，也不影响作业执行<br>
对于作业来说，还需要加上在外存被高级调度的时间<br><br><br>调度算法只能影响作业的等待时间，而被服务的时间是不确定的<br>响应时间<br>
——用户从提出请求到首次产生响应所需的时间<br><br><br>算法思想：先到达就绪队列的进程就先对它服务<br>
一般是非抢占的算法，只有进程主动放弃处理机才会进行调度算法<br>优点：<br>
算法公平、简单，不会导致饥饿<br>缺点：<br>
对长作业有利，对短作业不利的算法<br><br>算法思想：所需 CPU 时间最短的作业、进程优先<br>每次都选择当前已到达的运行时间最短的作业/进程，然后分配处理机<br>一般来说按照上述算法的执行是非抢占式算法<br>
<img alt="Pasted image 20250522154656.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522154656.png"><br>抢占式算法（最短剩余时间算法）<br>
每当有进程加入，就绪队列改变时，就需要调度，如果新到达的进程的剩余运行时间比当前进程的剩余时间要短，则新进程抢占处理机，当前运行进程重新返回就绪态，当一个进程完成之后也需要进行调度<br><img alt="Pasted image 20250522160020.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522160020.png"><br>优点：<br>
可以得到更短的平均等待时间、平均周转时间<br>缺点：<br>
不公平，对短作业有利，对长作业不利，可能产生饥饿现象<br>
另外进程/作业的运行时间是由用户提供的，并不一定真实，不一定能做到真正的优先<br><br><br>每次进行调度时，会先计算对应的响应比，选择最高的响应比的作业、进程为其服务<br>
该算法也是非抢占式的，只能等进程/作业完成之后才能进行调度<br>
<img alt="Pasted image 20250522161017.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522161017.png"><br>
注意 P 3 的等待时间为 3，因为只有当 P 1 执行完成之后才会从就绪队列中进行调度，此时时间为 7，但是 P 3 从 4 的时候就已经到达了，说明等待了 3，对于 P 4 的计算也是同理，到达之后等待 2 才能被调度，在每次执行完成一个进程之后都需要执行调度算法，计算出对应的响应比，然后将其放在 CPU 上执行
<br>优点：<br>
综合了等待时间和运行时间<br>
等待时间相同时，执行时间更短的优先<br>
执行时间相同时，等待时间更长的优先<br>
对于长作业来说，等待时间越久，响应比会越来越大，被调度的可能性也会越来越大，从而避免了长作业的饥饿问题<br><br>算法思想：公平的，轮流的服务每一个进程，让进程在一定的时间间隔内都能得到相应<br>
算法规则：按照进程到达就绪队列的顺序，轮流让进程上处理机上执行一个时间片，若在时间片内未执行完成，则将进程放在就绪队尾重新排队<br>
一般用于进程调度：（只有作业被放入内存并且分配进程之后才有时间片）<br>
该算法是一种抢占式算法，由时钟中断告诉其时间片已到<br>
常用于分时操作系统，更加注重响应时间<br>
<img alt="Pasted image 20250522163313.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522163313.png"><br>
以此类推：对于进程来说，必须等到时间片结束之后才能进行进程调度或者当前进程在时间片中间执行完成，例如 P3，只需执行 1 个周期，但是分配了两个时钟周期，所以在执行完毕之后，主动放弃 CPU，此时也会进行进程调度<br>对于不同的时间片进程的执行会有不同的结果，时间片太大、太小的影响<br>
<br>如果时间片太大，每个进程都可以在一个时间片内完成，此时这种算法退化成先来先服务算法，并且会增加进程相应时间
<br>如果时间片太小，会导致进程之间切换很频繁，从而导致实际程序执行的比例减少<br>
一般来说：设计时间片大小要让进程切换的时间开销占比不超过 1%<br>
优点：<br>
公平、响应快、适用于分时操作系统<br>
不会导致饥饿
<br>缺点：<br>
由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度<br><br>算法思想：根据任务的紧急程度来决定处理顺序<br>
算法规则：每个作业、进程都有各自的优先级，调度时选择优先级最高的进程/作业<br>
即可用于作业调度，也可以用于进程调度，甚至还可以用于 IO 调度<br>
抢占式<br>
在就绪队列发生变化时，检查是否会发生抢占，既当一个进程在 CPU 上执行时，如果此时有一个优先级更高的进程到来，CPU 会放弃当前进程的执行，转去执行另一个优先级高的进程<br>
非抢占式<br>
需要在进程主动放弃处理机时进行调度即可，当一个进程在 CPU 上执行时，如果此时有一个优先级更高的进程，此时仍然需要等待当前进程执行完成之后才能进行下一个进程的执行<br>静态优先级<br>
创建进程之后就确定了，之后一直不变<br>动态优先级<br>
创建进程时会有一个初始值，之后会随情况动态的改变<br>合理的设置优先级初始值<br>
<br>系统进程高于用户进程
<br>前台进程高于后台进程
<br>交互型进程高于非交互型进程
<br>IO 型进程高于计算型进程（因为 IO 可以和 CPU 同时运行，将其优先级设置高就会让 IO 设备今早开始运行，可以提升系统吞吐量，资源利用率）
<br>采用动态优先级该如何调整<br>
答：<br>
<br>如果某进程在就绪队列中等待了很长的时间，就可以适当的提升该进程的优先级
<br>如果一个进程运行了很长时间就可以适当的降低其优先级
<br>如果一个进程频繁的进行 IO 操作可以提升其优先级（这样可以提升系统资源的利用率，可以提高吞吐量）
<br>优点：<br>
用优先级区分紧急程度、重要程度、适用于实时操作系统，可以灵活的调整各种作业/进程的偏好程度<br>缺点：<br>
若源源不断的有优先级高的进程到来就会导致饥饿现象<br><br>算法思想：对其他调度算法进行折中，设置多个队列来实现不同的调度算法<br>
针对不同类型不同性质的进程设置不同的队列，对其中不同的队列实行不同的调度算法, 同一队列中不同进程可以设置不同的优先级，不同的队列也可以设置不同的优先级<br>
<br>各级队列优先级从高到低，时间片从小到大【优先级越高时间片越小】
<br>新进程到达时，会先将其放在优先级最高的队列中，按照先来先服务的算法进行调度，若用完时间片进程还未结束，则进入下一级队列队尾，如果已经是最后一个队列，则重新放回最后一个队列的队尾
<br>只有第 k 级队列为空时，才会向 k+1 级队列分配时间片
<br>如果当前执行进程时，有一个新进程进入优先级高的队列中，那么当前进程就会下 CPU，然后放到原队列尾部<br>
相当于每进入一个队列，时间片增加，优先级降低
<br>优点：<br>
各进程之间相对公平<br>
每个新到达的进程可以被快速相应<br>
短进程只用较少的时间就可以完成<br>
不必估计进程的运行时间（避免用户作假）<br>
可以灵活调整各类进程的偏好程度（可以将偏好的进程重新放回原队列，以此来保证高优先级）<br>缺点：<br>
会导致饥饿，如果源源不断有短进程到达，就会导致后面的进程没法执行<br>该算法适用于交互式系统，更注重进程响应时间、公平性、平衡性等<br><br>非对称多处理机大多采用的是主从式操作系统，内核驻留在主机上，从机上只运行用户程序，当从机空闲时，会向主机发送索求进程的信号，在主机中有一个进程就绪队列，只要队列不为空，就从就绪队列上摘一个进程交给从机处理<br>
这种方式的瓶颈就是主机太忙<br>需要考虑的问题<br>
亲和性<br>
系统进程从一个 CPU 转到另一个 CPU 上执行时，会将第一个 CPU 缓存设置无效，并且重新设置另一个 CPU 的缓存，此方法开销较大，因此应当避免进程在 CPU 之间的转换，尝试将所有进程都在一个 CPU 上运行，这种方式就是 CPU 的亲和性<br>负载均衡<br>
应当利用好多处理机的优势，将进程均匀的分给多个处理机，否则会造成一个 CPU 过于繁忙另一个 CPU 过于空闲，通常负载均衡会抵消掉 CPU 亲和性带来的好处<br><br><br>在系统中设置一个公共的就绪队列，所有 CPU 共享一个就绪队列，一旦 CPU 空闲就会从就绪队列中选择一个进程执行<br>
优点：<br>
这种方案很好的实现了 CPU 的负载均衡<br>缺点：<br>
这种方式无法实现 CPU 的亲和性<br>提升 CPU 亲和性的方法<br><br>1：软亲和<br>
指的是将进程尽量保持一个进程在某个 CPU 上<br>
2：硬亲和<br>
指的是用户进程通过系统调用，主动请求系统分配到固定的 CPU 上<br><br>系统为每个 CPU 设置了一个私有就绪队列，当 CPU 空闲时，就从各自对应的就绪队列中选择一个进程进行执行<br>
优点：<br>
很好的实现了 CPU 的亲和性<br>缺点：没有实现负载均衡<br>提升负载均衡的方法<br><br>推迁移和拉迁移<br>
<br>一个特定的系统程序会周期性的检查每个 CPU 的负载，如果发现不平衡就会从负载高的就绪队列中“推”一些进程到负载低的就绪队列中，同理，如果有一个 CPU 的就绪队列负载很低，就会从负载较高的就绪队列中“拉”一些进程到负载低的就绪队列中
]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\2.2cpu调度.html</link><guid isPermaLink="false">review/操作系统/2.进程、线程/2.2CPU调度.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 23 May 2025 08:38:41 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522141710.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250522141710.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[进程]]></title><description><![CDATA[ 
 <br>——程序的一次执行过程，即使是一个程序，如果多次执行，每一次执行就会对应不同的进程<br>
当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的进程 ID 号：PID<br><br><br>操作系统需要记录进程的很多信息<br>
<br>进程描述信息：PID，所属用户 UID
<br>资源分配清单：分配了哪些资源，内存、网络、正在使用哪些 IO 设备
<br>进程控制和管理信息：进程状态、优先级等
<br>处理机相关信息：CPU 上下文，各寄存器中的数据<br>
但凡是进程管理需要的信息都被存储在进程控制块中
<br>进程实体（进程映像） = PCB+程序段+数据段<br>
PCB 是进程存在的唯一标识<br>
进程是进程实体的运行过程，是系统资源分配和调度独立单位<br><br>
<br>动态性：进程是程序的一次执行，是动态的产生、变化和消亡的【最基本的信息】
<br>并发性：内存中存在多个进程，各进程可以并发执行
<br>独立性：进程能够独立运行，独立获得资源，独立接收调度的基本单位
<br>异步性：各进程按照独自的、不可与之的速度向前推进，操作系统要通过进程同步机制解决异步问题
<br>结构性：每一个进程都存在 PCB、数据段、程序段
<br><br>——指的是多个进程在同一时间段内执行的相对快慢，其影响因素有多个<br>
<br>
进程调度策略：OS 通过调度策略来管理各进程的执行顺序和时间片分配（某些调度策略会影响进程的优先级从而影响其他进程的执行速度）

<br>
系统资源的利用：当多个进程争用同一个资源，资源分配的使用情况会影响进程的执行速度（如某个进程占用大量 CPU 时间，其他进程的执行速度可能会受到影响）

<br>
进程的特征：并发进程的执行是间断的，进程会因为等待资源，IO 中断而被中断，进程的执行轨迹和代码结构也会影响执行速度（如某些进程可能会包含复杂的 IO 操作，从而影响其相对速度）

<br>
不确定性：由于多个进程同时运行，进程的执行顺序和时间片分配可能会发生变化，从而导致结果的不确定性

<br><br><br>此时正在创建进程，申请一个空 PCB，向 PCB 中写入相关的信息，然后为进程分配所需的资源，最后将创建态转为就绪态并且插入就绪队列，如果所需的资源不足，则创建任务未完成<br><br>处于就绪态的进程，其实已经具备运行条件，但是此时 CPU 比较忙，暂时不能运行该进程，所以将该进程放入就绪队列中<br><br>进程正在 CPU 上运行，CPU 正在执行进程程序段的指令，每个时刻都只有一个进程在一个核心上运行<br><br>进程在运行时因为某一项请求无法得到满足，例如请求打印机，但是打印机此时正在忙碌，进程就无法继续往下执行，此时 OS 会将进程放入阻塞态，选择另一个就绪态的进程进行执行<br><br>进程正在从 OS 中消失，进行一个 exit 的系统调用，OS 会回收对应进程的 PCB 和进程的资源，然后让出 CPU<br><br><img alt="Pasted image 20250521164705.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521164705.png"><br>
注意区分就绪态和阻塞态:<br>
对于就绪态来说, 进程只是缺少 CPU, 不缺少其他资源<br>
对于阻塞态来说, 进程不仅缺少 CPU, 还缺少其他资源
<br><br><br>会有三个指针指向进程<br>
执行指针: 指向当前正在运行的进程<br>就绪队列指针: 指向处于就绪态的进程 PCB, 一般会将 OS 中优先级更高的 PCB 放在前面<br>阻塞队列指针: 指向处于阻塞态的进程 PCB, 有的 OS 中会将阻塞原因不同的进程划分为不同的队列<br>
<img alt="Pasted image 20250521165622.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521165622.png"><br><br>根据进程状态的不同, 建立几张索引表, 还是通过上述指针, 指向对应的索引表<br>
<img alt="Pasted image 20250521165613.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521165613.png"><br><br>进程控制的本意就是进程状态的转换<br>如何实现进程控制？<br>
答：使用原语实现。<br>
为什么进程的状态转换要一气呵成？<br>
答：假设 PCB 中有一个变量表示进程所属状态，当进行进程状态转换的过程首先会更改进程的状态变量，然后将进程转到对应的队列，如果允许中断，那么就会出现进程 PCB 中表示的状态为 A，但是进程处在 B 队列中
<br>如何实现原语的原子性<br>
答：可以使用关中断和开中断来实现原语的原子性，当关中断之后外部的可屏蔽中断无法再对当前的操作进行中断<br>原语在内核态执行，常驻内存<br><br>——创建进程会使用创建原语，让进程从创建态转换为就绪态<br>
<br>申请空白 PCB
<br>为新进程分配资源
<br>初始化 PCB
<br>将 PCB 插入就绪队列
<br>引起进程创建的事件<br>
<br>用户登录：分时系统中，用户登录成功会为用户创建一个新的进程
<br>作业调度：多道批处理系统中，如果有新的作业放入内存中就会创建一个新的进程
<br>提供服务：用户向 OS 提出某些请求时，OS 会建立一个进程处理该请求
<br>应用请求：一个进程可以通过 fork 来创建新的进程
<br><br>——撤销原语会将程序从运行态转为终止态<br>
<br>从 PCB 集合中找到对应的 PCB
<br>若程序正在运行，那么就立即剥夺程序的 CPU，并且将 CPU 释放给其他进程
<br>终止其子进程【级联终止】
<br>将进程拥有的资源归还给父进程或操作系统
<br>删除 PCB
<br>引起进程终止的事件<br>
<br>正常结束：自己调用 exit 系统调用
<br>异常结束：整数除以 0，或者非法指令的执行
<br>外界干预：用户杀死进程
<br><br>
<br>找到对应的 PCB
<br>如果进程为运行态，那么需要保护进程运行现场，将 PCB 设置为阻塞态，暂时停止进程运行
<br>将 PCB 插入等待队列
<br>引起进程阻塞的原因<br>
<br>等待系统中的某些资源
<br>需要等待相互合作的进程完成工作
<br><br>
<br>在等待队列中找到 PCB
<br>将 PCB 从等待队列中移除
<br>将 PCB 插入就绪队列，等待被调度
<br>引起唤醒的操作<br>
<br>进程所等待的事件发生

注意：进程因为什么事件被阻塞，就需要什么事件来唤醒，所以阻塞原语和唤醒原语一般成对使用


<br><br>——切换原语会让两个进程状态发生改变<br>
<br>将运行环境存入 PCB
<br>PCB 移入相应的队列
<br>选择一个进程执行，并更新 PCB
<br>根据 PCB 恢复新进程所需的运行环境
<br>引起进程切换的事件<br>
<br>当前进程的时间片到
<br>有更高优先级的进程到达
<br>当前进程主动阻塞
<br>当前进程终止
<br><br>——两个或者多个进程之间产生的数据交互<br>
为什么进程通信需要操作系统支持<br>
答：对于每个进程来说，为了保护进程数据的安全，一个进程不能直接访问另一个进程的地址空间，所以需要 OS 来完成进程之间的通信<br><br>——各个进程只能访问自己的内存空间，映射到各进程的虚拟地址空间中，所以对于多个进程来说，一般会开辟一块共享区域，一个进程会将数据写入共享区域，另一个会从共享区域中读取数据，数据如何存储，以及数据存放在哪都是由进程控制的，而不是由 OS 决定的<br>为了避免访问存储出错，一般需要保证进程对共享内存的访问是互斥的，各个进程可以使用 OS 提供的同步互斥工具如（P、V 操作）<br>共享存储又分为两种：<br>
低级方式共享：基于数据结构的共享，例如：空间中只能放一个长度为 10 的数组，这种共享方式速度慢，限制多，灵活性差<br>
高级方式共享：基于存储区的共享，直接开辟一段共享内存区，进程之间可以使用这段共享内存来进行通信，这种共享方式速度很快，灵活性高<br><br>——进程间数据交换以格式化的消息为单位，进程通过 OS 提供的“发送/接收”消息的两个原语进行交换。<br>
格式化的消息<br>
由消息头和消息体构成<br>
消息头包括发送进程 ID，接收进程 ID，消息长度等格式化的信息<br>
消息体中包括具体的一个进程传递给另一个进程的数据<br>消息传递又可以分为：<br>
直接通信方式<br>
发送进程需要指明接收进程的 ID<br>
<br>进程 P 使用 OS 提供的发送原语 send，指明需要接收的对象以及接收的消息 send（Q，msg）
<br>OS 内核对应的消息挂在进程 Q 的消息队列中
<br>进程 Q 会使用 OS 提供的接收原语 receive，指明接收哪个进程的消息队列（在内核区 PCB 中），receive（P,&amp;msg）
<br>OS 内核会检测这些消息中哪些是由 P 发过来的，找到之后会把对应的消息 msg，放在进程 Q 的用户区中<br>
间接通信方式<br>
通过将发送的消息放在“邮箱”作为中间实体进行通信
<br>进程 P 通过系统调用申请一个“邮箱”A，P 指明自己需要将消息发送到哪个邮箱 send（A，msg）
<br>进程 Q 使用接收原语从对应的信箱中读取消息
<br><br>——一个进程的输出作为另一个进程的输入，数据的流向只能是单向的，管道实际上就是一个特殊的共享文件，又名 pipe 文件，其实就是在内存中开辟了一个固定大小的缓冲区<br>
共享存储和管道通信的区别，共享内存方式，进程可以在内存的任意位置写数据，但是管道有一个先进先出的特性，写方只能从前向后写数据，读方只能从头开始读数据，管道本质上是一个循环队列，有先进先出的特点
<br>一个管道只能实现半双工通信：只能单向传输，使用两个管道可以实现全双工通信，既双向通信<br>
各进程需要互斥的访问管道<br>
当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，之后可以唤醒写进程<br>
当管道为空时，读进程将阻塞，直到写进程往管道中写数据，之后才可以唤醒读进程<br>管道的特性决定，当管道中的数据一旦被读出就彻底消失，当多个进程读数据时可能会造成错乱，读出的数据不是发给自己的，一般有两种解决方法<br>
<br>一个管道允许多个写进程，一个读进程【以此解释为准】
<br>允许多个写进程和多个读进程，但是系统会让各个都进程轮流从管道中读数据
<br><br>——通知某个进程，某个特定的事件已经发生。进程收到一个信号之后，会对该信号进行处理<br>进程中有两个向量，一个用来表示待处理信号，另一个表示被阻塞信号，通过上述向量的标记位可以表示存在哪些对应的事件以及哪些信号被屏蔽，具体要屏蔽哪些信号这个有进程自己决定<br>用于发送信号的函数：int kill (pid_t pid, int sig)分别表示需要发送信号的进程 PID 以及对应需要发送的信号是什么，具体作用会将对应待处理信号置为 1<br>
<br>可以由进程给另一个进程发送信号
<br>可以由操作系统给进程发送信号
<br>一个进程也可以给自己发送信号
<br>进程什么时候会处理信号<br>
答：当进程从内核态转为用户态时（中断执行返回或者系统调用返回），会例行检查是否有待处理信号，如果有就处理信号，结合待处理信号和阻塞信号的值来确定哪些信号需要处理<br>信号的处理，将阻塞向量按位取反，然后再和待处理信号进行与操作得到最终的待处理向量<br>
<br>信号处理完成之后一般都会执行进程的下一条指令，除非信号处理程序将进程阻塞或终止
<br>一旦处理完某个信号就会将该信号 pending 位（待处理信号）置为 0
<br>如果收到重复的同类信号，将被简单的丢弃，因为仅有 1 bit 记录待处理信号
<br>当收到多个不同类型的信号时，通常会优先处理编号小的信号
<br>如何处理信号<br>
答：对于每一种信号，操作系统都设置了默认信号处理程序<br>
也可以执行进程为此类信号设置的用户自定义信号处理程序，自定义信号处理程序将会覆盖上一个默认程序，各个进程定义的信号处理程序只会作用于进程本身，而不会作用于其他进程<br>有的信号不能被用户自定义也不能被阻塞，比如 linux 下的 SIGKILL 和 SIGSTOPD 等<br>信号和异常有什么关系<br>
信号可以作为异常的配套机制，让进程对操作系统的异常进行补充<br>
在进程运行过程中某些特殊事件可能引发异常，操作系统内核捕捉并处理异常<br>
<br>有些异常可能由内核完成全部处理，此时就不需要再使用信号机制
<br>但是有些异常不能由内核完成全部处理，可能还需要用户进程进行配合处理，此时就可以用信号机制和异常机制进行补充处理
<br><br>——基本的 CPU 执行单元，也是程序执行流的最小单位<br>
什么是线程、为什么要引入线程<br>
在引入线程之前，系统中各程序只能串行执行，所以引入线程增加并发度，引入线程之后，线程成为了程序执行的最小单位，也是调度的最小单位<br>引入线程之后，进程只作为除了 CPU 之外的系统资源分配单元<br>
引入线程之后，各线程之间也能并发，提高了并发度<br>
只切换统一进程内的不同线程，不需要切换进程的运行环境，系统开销较小，传统进程间并发，需要不断地切换运行环境，开销很大<br><br>
<br>线程是调度的基本单位
<br>多 CPU 计算机中，各个线程可以占用不同的 CPU
<br>每一个线程都有一个 ID、线程控制块 TCB
<br>线程也有就绪、阻塞、运行三种状态
<br>线程几乎不拥有系统资源
<br>统一进程的不同线程可以共享使用进程的系统资源
<br>由于线程共享内存地址空间，统一进程中线程的通信甚至无需系统干预
<br>同一进程之间的线程切换不会引起进程切换
<br>不同进程中的线程切换会引起进程切换
<br>切换进程内的线程开销很小
<br>切换进程开销很大
<br><br><br>——用户态的程序可以调用对应线程库中设计的多线程工具实现多线程，此时 CPU 的调度单位仍然是进程<br>程序员可以使用线程库实现现成的创建、销毁、调度，但是操作系统只能看见进程<br>
线程的管理工作谁来完成<br>
答：用户级线程是由应用程序通过线程库来实现管理的，并不是 OS 负责的<br>线程切换是否需要 CPU 从用户态转为内核态<br>
答：线程的管理都是由线程库实现的，在用户态下即可完成，不需要是 CPU 进行状态转换<br>OS 是否能意识到用户及线程的存在<br>
答：OS 不能意识到用户级线程的存在<br>优点：<br>
对用户级线程的管理和切换在用户态下即可完成不需要 CPU 进行状态的转换，线程管理开销小，效率高<br>
算法可以是进程专用的，不同进程可以根据自身需要，对自己线程选择合适的调度算法<br>
用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分<br>缺点：<br>
当一个用户级线程被阻塞之后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上同时运行<br><br>线程的管理工作由谁完成<br>
答：线程的管理工作由操作系统来完成<br>线程的切换是否需要 CPU 状态的转换<br>
答：是，需要由用户态转为内核态<br>OS 能否意识到内核级线程的存在<br>
答：能意识到<br>优点：<br>
当一个线程被阻塞之后，别的线程也可以继续执行<br>
多线程可以在多核 CPU 上并行执行<br>
内核级线程具有很小的数据结构和堆栈，线程切换比较快，开销小<br>
内核本身也可以采用多线程技术，可以提高系统执行的效率和速度<br>
缺点：<br>
一个进程可能对应多个内核级线程，线程之间切换需要 CPU 频繁的进行状态之间的转换，线程的管理成本高，开销大<br>一对一模型<br>
——一个用户级线程映射到一个内核级线程，每个用户级进程都会有同等数量的内核级线程<br>
优点：<br>
<br>当一个线程阻塞之后，允许调度另一个线程执行，并发性比较高<br>
缺点；
<br>每创建一个线程就需要对应创建一个内核线程，开销较高
<br>多对一模型<br>
——多个用户级别的线程映射到一个内核级别的线程，且一个进程分配到一个内核级线程<br>
优点：<br>
<br>线程的管理开销小，效率高，并发性不高，类似于用户级多线程
<br>线程管理是在用户空间上的，无需切换到内核状态，效率高<br>
缺点：
<br>若一个线程再访问内核时发生阻塞，那么整个进程都会被阻塞
<br>任何时刻只允许一个线程访问内核，多个线程不能同时在多个 CPU 上运行
<br>多对多模型<br>
——将 n 各用户级线程映射到 m 各内核级线程（n&gt;=m），每个用户对应 m 个内核级线程<br>
优点<br>
<br>克服了多对一模型并发度不高的缺点，也克服了一对一模型中一个进程占用太多内核级线程，开销太大的缺点
<br>可以这么理解，用户级线程是代码逻辑的载体，内核级线程是运行机会的载体，一段代码逻辑只有在获得运行机会之后才能被 CPU 执行，内核级的线程可以运行任意一个有映射关系的用户级别的线程代码，只有对应内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞<br><br>——线程的状态和转换与进程之间的转换完全一致<br>
<img alt="Pasted image 20250521205201.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521205201.png"><br><br>进程控制块<br>
<br>TID：表示进程编号
<br>PC 寄存器：表示当前执行到哪个指令
<br>其他寄存器：线程运行的中间结果 
<br>堆栈指针：函数调用、局部变量，使用指针指向对应的内存区域
<br>线程运行状态：就绪、阻塞、运行
<br>优先级：线程调度、资源分配的参考
<br>绿色部分就是线程切换时需要保存和恢复的部分，一般上处理机和下处理机的线程需要将对应的数据从对应位置保存或者将其恢复到对应位置<br>线程的组织<br>
多个线程的 TCB 组织起来就可以组成线程表，不同的系统可以采取不同的策略]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\2.1进程和线程.html</link><guid isPermaLink="false">review/操作系统/2.进程、线程/2.1进程和线程.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 24 May 2025 06:34:01 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521164705.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\2.进程、线程\img\pasted-image-20250521164705.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.2：虚拟内存技术]]></title><description><![CDATA[ 
 <br>在基础内存管理技术上加上覆盖技术和交换技术可以使得电脑内存的利用效率更高，能够从逻辑上扩充内存的容量<br>传统内存分配的方式<br>
连续分配<br>
<br>单一连续分配
<br>固定分区分配
<br>动态分区分配<br>
非连续分配
<br>基本分页管理存储
<br>基本分段式管理存储
<br>基本段页式管理存储<br>
上述传统内存分配方式的基本特征
<br>一次性：作业必须一次性装入内存才能正常运行，这将会导致两个问题，
<br>
<br>当作业太大时会导致不能全部装入内存，导致大作业无法运行
<br>当大量作业需要运行时，由于内存无法容纳所有作业，因此只有少量的作业能够运行，, 导致多道程序并发性下降
<br>
<br>驻留性：作业被装入内存之后就一直驻留在内存中，其任何部分都不能被换出，直至作业运行结束
<br>
<br>但事实上在一个时间段内，只需要访问作业的一小部分资源数据就可以正常运行，这就导致内存中驻留大量暂时用不到的数据，浪费了宝贵的内存资源<br>
局部性原理<br>
时间局部性：如果执行了程序的某条指令，那么不久之后这条指令有可能再次运行，如果某个数据被访问过，那么在不久的将来可能再次被访问
<br>空间局部性：一旦访问量程序的某个存储单元，不久之后其附近的存储单元也会被访问，因为数据在内存中是连续存放的，程序的指令也是顺序存放的<br><br>基于局部性原理，可以将程序很快会用到的部分先装入内存，暂时用不到的放在外存，就可以让程序开始执行<br>
在程序执行过程中，当所访问的信息不存在时，由 OS 负责将所需的信息从外存调入内存，然后继续执行程序，这个过程就是调段功能或者调页功能，需要进行页面置换<br>虚拟存储器的三个主要特征<br>
<br>多次性：无需在作业运行时一次性将进程装入内存，而是被允许多次调入内存, 多次性是虚拟存储最重要的特征
<br>对换性：在作业运行时无需常驻内存，而是允许在作业运行的过程中，将暂时不需要的部分换出，以后需要是再换入内存
<br>虚拟性：从逻辑上扩充了内存的容量，用户看到的容量远大于实际的容量，这是虚拟存储表现出得最重要得特征，也是实现虚拟存储得最重要得目标
<br><br>如果采用连续分配技术，后面得分段、分页想要到达内存空间的话，需要分配一之前相连续得内存空间，这样显然是不方便实现的，所以虚拟内存技术是在离散内存分配的基础上的<br>虚拟内存的实现主要有以下三种技术<br>
<br>请求分页式存储管理
<br>请求分段式存储管理
<br>请求段页式存储管理
<br><br>——请求分页与基本分页存储管理的主要区别是：<br>
<br>在程序执行的过程中，当所访问的资源不在内存中时，由操作系统负责将信息从外存调入内存，然后继续执行程序
<br>如果内存空间不够会将暂时用不到的信息换出外存<br>
操作系统需要增加请求调页的功能<br>
还需要增加页面置换功能，将暂时用不到的信息换出内存
<br><br>——在请求分页管理中，OS 需要知道每个页面是否已经调入内存，如果还没调入，也需要知道页面在外存中的存放位置，当页面不够时需要进行页面置换，OS 根据页面置换算法决定换出哪个页面，页面是否被修改过，是否要重新写入外存<br><br>
<br>状态位 P：表示当前页面是否已经调入内存，0 表示为被调入，1 表示已被调入
<br>访问字段 A：用于记录本页在一段时间内访问的次数或最近多久没有访问，供页面置换算法做参考
<br>修改位 M：表示当前页面是否被修改，决定在换出外存时是否写回外存
<br>外存地址：记录该页在外存中的物理地址，通常是物理块号，供调入该页时参考
<br><br>在分页请求管理系统中，当要访问的页面不存在时，产生一个缺页中断，由 OS 去执行对应缺页中断处理程序处理中断，此时进程阻塞，加入阻塞队列，直到页面被调入内存之后被唤醒，加入就绪队列<br>
如果内存中有空闲块的话，就将所缺页面放入空闲块，并修改表中相应页表项<br>
如果内存中没有空闲块的话，就通过页面置换算法置换一个页面，如果当前页面没有被修改那么直接进行置换，如果当前页面被修改的话，那么将修改之后的页面写入外存然后再进行置换<br><br><img alt="Pasted image 20250607151238.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607151238.png"><br>对应左侧和右侧的修改访问位和修改位是请求分页和基本分页机制的不同<br>
注意：

<br>并非所有的操作都需要修改表中的修改位，只有进行写操作的时候才需要修改表中的修改位，但是在快表中的修改并不立即写入慢表，而是等待快表中的表项删除时才将其写回慢表，类似写回法
<br>和普通的中断处理一样，中断的处理都需要保存 CPU 现场，让进程进入阻塞态
<br>页面置换算法决定将哪个页面换出
<br>页面的换入换出都是需要启动慢的 IO 操作，如果换入换出太频繁的话会有很大的开销
<br>上图中存在一个错误就是在左边将页面换入内存之后修改页表之后也需要将其写入快表中

<br>请求分页管理的地址变换过程如下<br>
<br>先检索快表，若命中就直接取出物理地址，并且修改访问位
<br>如果快表未命中，去查慢表，如果对应页面在内存中，则取出对应的物理块号，并且修改访问位，并且将表项写入快表，如果快表已满，则采用替换算法
<br>如果不在主存中，那么产生缺页中断，从外存中将对应页调入主存，同时更新慢表和快表
<br>利用得到的物理地址去内存中进行访存
<br><br>——一个好的页面置换算法要追求少的缺页率，减少 IO 开销<br><br>——每次选择的都是以后永远不使用，或者在最长时间内不再被访问的页面，或者长时间不访问的页面，以此保证缺页率<br>
在做题时，如果页面需要被置换，可以往后看对应已经在内存中的块号出现的顺序是什么，找到出现最晚的那个，将其进行替换<br><img alt="Pasted image 20250607153745.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607153745.png"><br>前提条件：知道进程执行过程中以此访问的页面是什么，但是 OS 根本不可能知道后面需要访问的页面是什么，因此最佳置换算法是无法实现的<br><br>——每次淘汰的页面就是最早进入内存的页面<br>
把页面调入的顺序排成一个队列，需要换出页面时选择队头页面即可，队列的最大长度取决于系统为进程分配了多少个内存块<br><img alt="Pasted image 20250607154429.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607154429.png"><br>
只有 FIFO 算法会产生 Belady 异常，虽然算法的实现简单，但是先进入的页面有可能最经常被访问，算法性能差
<br><br>——根据页表项中的访问字段来判断未被访问的时间<br>
可以让页表项中的访问字段来表示距离上一次被访问的时间<br>
<img alt="Pasted image 20250607155003.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607155003.png"><br><br>简单的 CLOCK 算法<br>
——为每个页面设置一个访问位，将内存中的页面通过连接指针连成一个循环队列，当某个页面被访问时，将其访问位置为 1，当需要淘汰一个页面的时候，查找访问位，如果为 0 那么就将其换出，如果是 1，则将其置为 0，继续寻找下一个页面的访问位，依次类推（因此简单 CLOCK 算法最多会经过两轮扫描）<br>
<img alt="Pasted image 20250607160015.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607160015.png"><br>
算法开销小，但是未考虑是否被修改<br>改进的 CLOCK 算法<br>
——简单的 CLOCK 算法仅仅考虑页面是否被访问过，但是如果该页面被修改还需要执行写入外存的操作，需要更多的 IO 操作，如果置换的是没有修改的页面，就会减少 IO 时间从而提高效率<br>
所以，增加一个修改位表示是否被修改，与简单 CLOCK 算法不同的是，改进之后需要优先置换没有被修改过的页面<br>
<img alt="Pasted image 20250607160520.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607160520.png"><br>
改算法可以类比位按照优先级进行淘汰：<br>
<br>最近未访问过也未修改过的页面
<br>最近访问过但是未修改的页面
<br>最近未问过但是未修改的页面
<br>最近最近访问过也修改过的页面<br>
算法开销小，性能也不错
<br><br>驻留集：指分页存储管理中给进程分配的物理块的集合<br>采用虚拟存储技术的系统中驻留集大小是要小于进程总大小的<br>
如果驻留集太小的话，会导致缺页频繁，系统要花大量时间来处理缺页，实际用于进程推进的时间很小，如果驻留集太大，会导致多道程序并发性下降，资源利用率低，所以应该选择一个合适大小的驻留集<br>驻留集的分配策略<br>
固定分配：OS 为每个进程分配一组固定数目的物理块，在进程运行期间不会改变，既驻留集大小不变<br>
可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况适量的增加或减少，驻留集大小可变<br>页面置换范围<br>
局部置换：发生缺页时只能选择自己的进程的物理块进行置换<br>
全局置换：可以将 OS 保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程<br>按照上面的驻留集分配策略和页面置换范围可以进行组合<br><br>因为全局置换的规则可以知道进程拥有的物理块数必定是可变的，因此不可能是固定分配<br>固定分配局部置换<br>
为进程分配一个固定大小的物理块，然后发生缺页中断需要进行页面置换时，只能置换属于自己进程的物理块<br>可变分配全局置换<br>
系统为进程分配一定数量的物理块，在进程运行期间根据实际情况增加或者减少，当发生缺页时，在空闲的物理块中选择一块分配给进程，如果无空闲物理块，可以选择一个系统中未锁定的页面将其换入外存，这会导致其他进程的缺页率上升<br>
只要缺页就分配物理块<br>可变分配局部置换<br>
首先为进程分配一定数量的物理块，在进程运行期间进程发生缺页时，只允许从自己的进程中进行页面的置换，如果缺页很频繁的话，那么就给其多分配几个物理块，直到缺页率到达适当程度，反之，如果进程的缺页率比较低的话，那么就适当减少对其物理块的分配<br>
根据缺页率动态的调整进程的物理块<br>调入页面的时机<br>
<br>预调页策略<br>
根据局部性原理，一次调入若干个相邻的页面，预测其为不久之后可能访问的页面，这种策略主要用于进程的首次调入
<br>请求调页策略<br>
程序在运行时发现缺页才将所需页面调入内存中，这种策略调入的页面一定会被访问到，由于每次只能调入一页，每次缺页就需要调入，IO 凯西奥很大<br>
用于进程运行期间调入页面
<br>从何处调入页面<br>
<br>系统有足够大交换分区<br>
交换区能够很快的将对应分页装载如内存，在程序运行之前，将与进程有关的文件从文件区复制到交换区
<br>系统缺少足够的交换分区<br>
凡是不需要修改的文件都直接从文件区调入，在换出时，由于不会被修改，所以不必被换出，对于那些可以被修改的文件，在他们换出时需要经过交换区，需要时再从交换区调入
<br>UNIX 方式<br>
与进程有关的文件都放在文件区，未运行的页面都从文件区调入，曾经运行过后但是又被换出的页面放在交换区，下次调入直接从交换区调入
<br>抖动现象<br>
刚刚换入的页面马上就要被换出内存，刚刚被换出的页面马上要被换入内存，这种频繁的页面置换现象称为抖动现象，产生的原因主要是分配给进程的物理块数目不够了<br>工作集<br>
在某段时间内，进程实际访问的页面的合集，驻留集大小不能小于工作集大小<br>
<img alt="Pasted image 20250607170329.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607170329.png"><br>物理块调入算法<br>
<br>平均分配算法：系统将空闲的物理块平均的分配给全部进程
<br>按比例分配算法：根据进程大小比例分配空闲的物理块
<br>优先权分配算法：为重要和紧迫的进程分配物理块，通常采取的措施就是将空闲的物理块分为两个部分，一部分按照进程比例进行分配给各个进程，另一部分按照进程优先级分配
<br><br>OS 向上层程序员提供的系统调用，方便程序员访问文件数据，方便多个进程共享同一个文件<br>
传统的文件访问方式<br>
<img alt="Pasted image 20250607171238.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607171238.png"><br>
内存映射文件解决的问题，将文件映射到进程空间中，但是并未把文件的真实数据放入进程的内存空间中，映射到的位置暂时是一个缺页的状态，当进程需要访问对应文件的位置时，会产生缺页中断，由 OS 进行中断处理，将文件中的内容读入内存中<br>多个进程可以映射同一个文件，对应不同的进程空间映射到相同的物理地址，可以实现进程对文件的共享<br>
优点：<br>
<br>便于程序员编程，已经建立映射的文件只需按照读写内存的方式进行读/写
<br>方便多个进程共享同一个磁盘文件
<br><br><br>影响页面换入/换出的效率的原因主要包括<br>
<br>对页面进行置换的算法，好的算法会造成更低缺页率，从而减少页面换入/换出的开销
<br>将已修改的页面写入磁盘的频率，对应频率越低就会减少写回磁盘的 IO 开销
<br>将磁盘内容读入内存的频率，如果频率越低则对应换入/换出的开销越小<br>
页面缓冲算法在原来的页面置换算法的基础上增加了已修改页面的链表，用于保存已修改并且等待换出的页面，当等待换出的页面到达一定值的时候再一起换到磁盘，降低了换入换出的频率，使得磁盘的 IO 开销大幅减少
<br>设置两个链表<br>
<br>空闲页面链表：主要用于存放空闲的页表和需要换出的未被修改的页面，如果需要读入某个页面，那么就需要从链表头部选择一个页框并装入该页面，需要换出的未被修改的页面则放在链表的表尾，当其他进程需要时从链表中取数据，避免了重复的从磁盘中读数据
<br>修改页面链表：主要用于存放修改之后的需要写入磁盘的页面，等页面数量到达一定值的时候同一将页面写入磁盘
<br><br>当系统可分配的内存不足的时候此时需要进行页框的回收，但是只能回收属于进程的页框，再 Linux 中设置了一个负责页面换出的守护进程，定期检查页框的数量，如果小于阈值的话，那么就进行页框的回收，因为内核需要一个页框来作为 IO 传送的缓冲区，所以不能等到系统中没有页框在进行回收，在回收时需要把零碎的页框合并为一整个页框，回收时，先检查是否有大小相同的页框，如果存在就将其合并为更大的空闲页框，每次合并之后还需要检查是否可以继续合成更大的页框]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\3.2：虚拟内存技术.html</link><guid isPermaLink="false">review/操作系统/3.内存/3.2：虚拟内存技术.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 11 Jun 2025 08:44:48 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607151238.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250607151238.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[什么是内存、有什么作用]]></title><description><![CDATA[ 
 <br><br>——内存的作用就是存放数据，程序需要放在内存中才能够被 CPU 给处理，因为硬盘的速度和 CPU 之间相差太多<br>但是很多程序公用内存空间，OS 如何区分各个程序的数据放在什么地方呢<br>
答：<br>程序编译之后都从 0 号单元开始编址，这就称为目标模块的相对地址，当链接程序将各个模块链接成一个完整的可执行目标之后，链接程序按照顺序依次按各个模块的逻辑地址依次执行指令，进程在运行的之后使用和操作的都是逻辑地址，但是实际操作的还是物理地址，其中需要使用内存管理部件进行地址的转化，因此不同的进程可以拥有相同的逻辑地址，因为这些地址可以映射到不同的物理地址，也就是在内存中的实际地址，将逻辑地址转换为物理地址的过程称为地址重定位<br><br><br>在程序编译时，如果知道程序将要放在内存中的哪个位置，编译程序就会产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存<br>
绝对装入只适合单道程序环境，此时还没有 OS 的概念，所以这个地址转换是由编译器完成的<br><br>在编译链接的时候地址都是按照 0 为基准地址进行编译和链接，但是在装入内存的过程中，再对其中的地址进行修改，将逻辑地址转换为物理地址<br>静态重定位的特点就是，需要一次性将作业装入内存，如果内存空间不足，就不能装入该作业，在程序运行的整个期间都不能修改程序，也不能再申请空间<br>
适用于早期多道批处理操作系统<br><br>也成为动态重定位，在程序编译、链接装入模块都是从 0 开始的，装入程序把装入模块装入内存之后，并不会立即把逻辑地址转为物理地址，而是需要通过一个地址转换表，将逻辑地址和物理地址进行一一对应，这种方式需要一个寄存器来实现，使用重定位寄存器(基址寄存器)，来进行地址之间的转换<br>
优点：<br>
<br>可以将程序分配到不同的连续区，在程序运行前只需要装入它的部分代码就可以投入运行，然后在程序运行期间可以根据需要动态分配内存，便于程序段的共享<br>
适用于现代的操作系统
<br><br><br>在程序运行之前将它们所需要的库函数链接成一个完成的装入模块，以后不再拆开，<br><br>在将目标模块装入内存时，边装入边链接的链接方式，优点是便于修改和更新，便于实现对目标模块的共享<br><br>在程序运行时需要使用到对应的模块时，才对他进行连接，优点是能加快程序的装入过程，还可以节省内存空间<br><br><br>一个进程在内存中的存放主要有<br>
<br>代码段：进程的二进制代码，代码段是只读的，可以被多个进程共享
<br>数据段：程序运行时处理的对象，包括全局变量、静态变量
<br>堆：存放动态内存分配的变量
<br>栈：用来实现函数调用，从用户空间的最大地址往低地址方向增长
<br>进程控制块：放在系统去，OS 通过 PCB 来控制和管理进程<br>
<img alt="Pasted image 20250605182554.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250605182554.png">
<br><br>——确保每个用户进程都有一个单独的用户空间，分配之前需要保护 OS 不受用户进程的影响<br><br>——在内存中设置上下限寄存器，用来表示进程可以在主存中可以分配到的上下限地址，当 CPU 需要访问一个地址时，判断是否超过上下限寄存器中的值，判断有无越界<br><br>——设置一个基地址寄存器（重定位寄存器）和界地址寄存器（限长寄存器），基地址寄存器表示进程存放的基准地址，界地址寄存器表示的是可以访问的最大逻辑地址长度<br>
访问地址时首先判断逻辑地址是否超过界地址寄存器，如果超过则抛出越界异常，否则就加上基地址寄存器中的值，去访问对应的物理地址<br>操作上述两种寄存器都需要在内核态进行，OS 可以改变上述寄存器中的值，但是不允许用户进程修改上述寄存器的值<br><br><br>——程序大小超过内存总和的问题<br>
思想：<br>
<br>将程序分成多个段（模块），常用的常驻内存，不常用的在需要时调入内存
<br>内存分为固定区和若干个覆盖区，将需要常驻在内存中的放在固定区，调入之后就不再调出（除非运行结束）
<br>将不常用的段放在覆盖区中，需要时调入内存，不需要时调出内存<br>
如果程序本身有明显的调用结构的话，可以按照自身逻辑结构让那些不能同时被访问的程序段共享一段覆盖区<br>
适用于早期的操作系统
<br>必须由程序员声明覆盖结构，操作系统自动完成覆盖<br>
缺点：<br>
对用户不透明，增加了用户编程负担<br><br>——在内存空间紧张时，将某些进程暂时的移除内存，把外存中的某些已经具备运行条件的进程换入内存（进程在内存于磁盘之间调度）<br>此方法进程的 PCB 是常驻内存的，因为需要通过 PCB 管理集成，将外存中的进程唤醒到内存<br>
在外存的什么位置保存被换出的进程呢？<br>
答：在具有交换功能的操作系统中，通常把磁盘分为文件区和交换区，文件区主要存放文件，更注重存储空间的利用率，所以采用离散的方式存储，交换区需要存放进程数据，交换速度直接影响到系统运行速度，所以交换区更加注重速度，因此采用连续分配方式，总而言之交换区的 IO 速度要比文件区要快
<br>
应该在什么时候交换？<br>
答：交换通常发生在许多进程同时运行并且内存资源不够的情况下，知道系统负载明显降低<br>
例如：如果在进程运行的时候经常发生缺页现象，说明内存空间不够，此时将其他进程交换出内存，缺页次数明显降低，此时可以暂停换出
<br>应该换出什么进程？<br>
答：可以有限换出阻塞的进程，换出优先级比较低的进程，为了防止优先级低的进程在被调出内存之后很快被调出，有时还需考虑进程在内存中的驻留时间
<br><br><br>——系统为用户分配的必须是一个连续的内存空间<br><br>采用静态重定位<br>
——将内存分为系统区和用户区<br>
为进程分配整个用户区，用户区中只有一道作业，也就是说，不能加载多道用户程序<br>优点：<br>
<br>简单、无外部碎片
<br>不一定需要进行内存保护
<br>缺点：<br>
<br>只能单用户、单任务的操作系统
<br>有内部碎片（为其分配的空间中有一部分没有用上）
<br>内存利用率极低
<br><br>采用静态重定位<br>
——将用户空间划分为若干个固定大小的分区，每个分区只装入一道作业，有空闲分区时就可以在外存的后备作业中选取合适大小的作业装入该分区，划分分区的方法有两种：<br>
分区大小相等<br>
程序太小会造成浪费、程序太大无法装入、缺乏灵活性<br>
分区大小不相等<br>
划分多个较小的分区，适量的中等分区和少量大分区，增加了灵活性，可满足不同大小进程的需求<br>为了区分分配与回收，建立一张分区使用表，表象包括分区的始址，大小及状态，分配内存时查找是否存在一个能满足进程所需的空间的最小分区，并且将这一分区的状态置为已分配，回收时将其置为未分配即可<br>优点：<br>
实现简单，不会产生外部碎片<br>缺点：<br>
<br>当进程很大时，所有的分区都无法满足分配，此时又需要使用覆盖技术，这就会降低性能
<br>会产生内部碎片，内存利用率低
<br><br>——又称为可变分区分配，是指内存装入内存时，根据进程的实际需要，动态的为其分配内存，使得分区大小正好满足进程的需要，因此系统中进程大小和数量都是可变的<br>动态分区技术在一开始的表现是很好的，但是随着时间的推移，内存中会产生很多的小内存块（因为在上一个进程退出时，空间释放大小是固定的，很难找到一个进程大小正好的进程装入，只能找到对应比较小的进程装入，所以随着时间的推移会产生很多的内存小碎片）<br>系统要使用怎样的数据结构来记录内存的使用情况<br>
空闲分区表：类似固定分区分配中的分区表<br>
空闲分区链：每个分区起始部分和末尾部分都设置指针指向对应的前一个分区和后一个分区，起始部分还可以记录分区大小等情况
<br>当很多空闲分区满足需求时，需要选择哪个空闲分区进行分配  动态分区分配算法<br>
<br>如何进行分区的分配以及回收操作<br>

<br>回收区与插入点的前一个空闲分区相邻，此时将这两个分区合并为一个分区，修改起始地址和分区大小等信息
<br>回收区与插入点的后一个空闲分区相邻，此时将这两个分区合并，修改起始地址和分区大小等信息
<br>回收区与插入电的前后空闲分区都相邻，将这三个分区合并，修改起始地址和分区大小等信息
<br>回收区没有与之相邻的空闲分区，此时就需要新建一个表项，记录对应的起始地址，分区大小，并将其插入空闲分区表（链）

<br>如何判断前后是否为空闲呢？<br>
在空闲分区链中前后都会记录分区信息，前面包括起始地址，分区大小，是否被分配，后面包括分区大小的信息，后面的节点可以访问前面节点的分区大小信息，计算出分区的头部，访问分配情况判断是否为空闲分区，后面的节点根据其起始地址查看分配情况判断是否被分配<br>内部碎片：分配给某些进程的内存区域中有些部分没有用上<br>
外部碎片：内存中有些很小的空间难以利用<br>紧凑技术：通过挪动进程在内存中的位置，将外部碎片集中在一起，拼成一块更大的可以利用的空间<br><br>基于顺序搜索的分配算法<br>
1. 首次适应算法<br>
空闲分区按照地址递增的方式进行排序，每次分配空间时，查找空闲分区表，找到的第一个满足条件的分区就进行分配<br>
优点：<br>
保留了内存高地址上的大分区，使得大进程能够装载<br>
缺点：<br>
回使内存低地址部分出现很多小的分区，每次查找都需要经过这些分区，增加了开销<br>2. 邻近适应算法<br>
每次从上一次查找结束的位置开始查找，与首次适应算法一样，只是每次开始的位置不一样，开始的位置是上一次查找结束的位置<br>
优点：<br>
解决了首次适应算法中的在低地址部分出现很多小的空闲分区问题<br>
缺点：<br>
导致高地址中没有大空间可以使用，通常比首次适应算法更坏<br>3. 最佳适应算法<br>
空闲分区链按照空闲分区大小递增的次序来排列，优先选用满足条件的最小的分区，尽可能留下大片的空闲区，以此来保证大进程可以被装入<br>
优点：<br>
算法的效果最佳<br>
缺点：<br>
每次使用的都是最小的分区进行使用，因此这种方法会带来越来越多的很小的外部碎片，难以利用的内存块<br>4. 最大适应算法<br>
空闲分区按照分区大小递减的次序来排列，每次找到大小能满足的第一个空闲分区<br>
缺点：<br>
每次都选择最大的分区进行分配，导致后面的大进程没有空间存放<br>总而言之：首次适应算法的开销小，性能最好，回收分区不需要对空闲分区进行重新排布<br><img alt="Pasted image 20250605201148.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250605201148.png"><br><br>当系统很大时，空闲分区链可能很长，所以根据空闲分区的大小设置空闲分区链，每一类（分区大小相同）的空闲分区，单独一个空闲分区链，并且设置一张索引表来管理这些空闲分区<br>
快速适应算法<br>
<br>根据进程的长度，在索引表中查找能够容纳它的最小空闲分区链表
<br>从链表中取下第一块进行分配<br>
优点：<br>
查找效率高，不会产生内部碎片<br>
缺点：<br>
在回收分区时需要有效的合并空闲分区，算法比较复杂，开销较大
<br>伙伴系统<br>
将系统中的空闲分区全部设置为 2 的倍数，每一类放在一个分区链中<br>
如果需要大小为 n 的空闲分区<br>
<br>查找一个最小的满足大小为 n 的空闲分区，如果有那么就进行分配
<br>如果没找到，那么就找下一个更大的分区（此时应该是上一个的 2 倍），将这段分区一分为二，一般用于空间分配，另一半用于空闲分区，将其挂载到对应的分区链上
<br>哈希算法<br>
构建一张针对空闲分区关键字的哈希表，每个表项记录对应空闲分区的头指针，分配时通过分区大小经过哈希查找找到对应的空闲分区链，从中得到对应的空闲分区<br><br><br>将内存空间分割为相同大小的页框，每个页框有一个编号，编号从 0 开始<br>
将进程的逻辑地址空间也分为对应大小的部分，每一个部分称为一个页或页面，每一个页面也有编号从 0 开始<br>
分页管理地址结构是一维的<br>
注意页和页面指的是进程在逻辑上被划分的部分<br>
页框和页帧指的是内存被划分为相同大小块
<br>将进程加载进内存中的页帧中，对应装在的页帧不一定连续，可以将其装在到不同的页帧中<br>为了能知道页面能够装在内存中的哪个页框中，操作系统要为其建立一张页表，页表通常存储在 PCB 中<br>
<br>一个进程对应一张页表
<br>每个进程的页面对应一个页表项
<br>每个页表项由页号和块号（页框号）组成
<br>页表记录进程页面和实际存放内存块（页框）之间的映射关系<br>
注意：答题的时候建议使用页框号
<br>每一个页表项占多少个字节呢？<br>
例：假设系统物理内存大小为 4 GB，页面大小为 4 KB，那么对应每个页表项需要多少个字节？<br>
答：页表项记录的是进程页号和页框号之间的映射，所以只需要计算多少字节能够表示对应的页面大小和页号，4 GB 分块可以分为 2^20 个内存块，所以需要 20 位标识页框号，所以需要 3 B 来标识块号，对于页号是不需要存储空间的，因为对应表项是连续存放的，所以可以通过计算得到对应的页号及其对应的块号地址【可以类比数组下标对数组的访问特性】
<br>如何根据块号找到对应的实际物理地址呢？<br>
答：内存块的起始地址 = 块号* 内存块的大小
<br>如何实现地址的转换（操作系统是如何实现逻辑地址到物理地址的转换的）<br>
答：首先确定逻辑地址所在的页号（页号 = 逻辑地址 / 页面长度  下取整）<br>
根据确定的页号，查找到对应在内存中的物理块号<br>
确定逻辑地址的页内偏移量 （页内偏移量 = 逻辑地址%页面长度）<br>
物理地址 = 页面对应页框的首地址 + 页内偏移量
<br>虽然进程页面在内存中是随意存放的，但是在进程内部是连续存放的<br>页面大小为 2 的整数倍有什么好处<br>
答：页面大小为 2 的整数倍，可以更好的拆分地址，可以很快的根据页框号和页内偏移量得到实际的物理地址，直接对其进行拼接就能得到对应的物理地址，反之也可以很快的通过物理地址得到对应的页块号还有页内偏移量，只需要进行左移和右移就行
<br>可以将逻辑地址分为页号和页内偏移量，<br>
其中页号的表示位数表明了进程所占页框的数量<br>
页内偏移量的位数表示页框的大小<br><br>——用于实现逻辑地址到物理地址转换的一种硬件机构<br>
通常会在系统中设置一个页表寄存器用来存放页表在内存中的起始地址和页表长度，进程未执行时会存放在 PCB 中，进程开始执行会将其加载进页表寄存器中<br><img alt="Pasted image 20250606175413.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606175413.png"><br>
<br>根据逻辑地址计算得到页号和页内偏移量
<br>判断页号是否越界，如果页号&gt;=页表长度，则说明越界
<br>如果不越界，访问页表对应的起始地址，访问页表查找出对应的页框号
<br>通过页框号和页内偏移量去访问对应的物理地址
<br>主要问题：<br>
每次访存都需要进行逻辑地址到物理地址之间的转换，地址转换速度需要足够快，否则访存速度就会降低<br>
每个进程引入页表，页表必须连续存放，用于映射机制，但是页表不能太大，否则内存利用会降低<br><br>快表：又称联想寄存器，它是一种访问速度比内存快很多的高速缓存（cache，一般集成在 CPU 内部），用来存放最近访问过的表项的副本，, 可以加速地址的转换<br>
内存中的页表称为慢表<br><img alt="Pasted image 20250606182139.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606182139.png"><br>
在引入快表之后，每次进行地址转换的过程都会查看快表是否命中，命中就直接访问内存单元，否则去访问慢表然后再进行地址转换，同时将慢表中的表项放入快表中，如果快表已经存满，那么就通过置换算法来对表项进行置换<br>有无快表地址转换对比<br>
<img alt="Pasted image 20250606183526.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606183526.png"><br><br>——解决单级页表存在的问题，如果页表项过多，在内存中所需要占用的空间就越多<br>
根据局部性原理可知，进程在一段时间内只需要访问某几个页面就可以正常执行了，因此没必要让所有页表项都常驻内存<br>注意每个表只能存放在内存中的一个页框中，超出的部分需要按照多级页表进行划分<br>
采用 n 级页表需要进行 n+1 次内存的访问<br>类比进程分页的方式，可以类比的将页表进行分页，将各个分组分别放入内存块中，为需要分配的页表再建立一个页表，这个表示页表映射关系的表称为页目录表或称为外层页表或者顶层页表<br>原理：<br>
外层页表表示的是对应页表编号存储在内存中的页框号<br>
内层页表表示的是进程对应分页存储在内存中的页框号<br>地址转换的过程：<br>
<br>根据地址按照地址安排结构将其拆成 3 部分，一级页表、二级页表、页内偏移量
<br>从 PCB 一级中读取页表存储的位置，根据一级页号去对应内存中查找对应下一级页表在内存中存放的位置
<br>根据二级页号查找最终想要访问的内存块
<br>组合页内偏移量组合得到最终访问的地址<br>
如果想访问的页面不在内存中则会产生缺页中断，然后将目标页面调入内存
<br>缺页中断与当前执行的指令有关，属于内部中断<br><br>与分页存储最大的区别就是离散分配的时候所分配的基本单位不同，分页是固定分配的空间，而分段是根据程序的逻辑功能进行分段的，用户进行编程会更加方便，程序的可读性更高<br>
分段存储管理地址结构是二维的<br>什么是分段？<br>
答：进程按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从 0 开始编址
<br>内存分配规则：<br>
OS 以段为单位进行分配，每个段在内存中占据连续的内存空间，但是各段之间可以不相邻
<br>分段系统的逻辑地址由段号和段内地址组成<br>
<br>段号的位数确定了进程最大可以分为几个段
<br>段内地址决定了段的最大长度为多少<br>
在编写分段存储分配程序时按照段名编写，在编译的时候会将其转换为对应的段号
<br>为了保证程序能够正常运行，找到对应段的位置，OS 会建立一张段映射表简称段表<br>
<br>段表中包含段号、段长、基址（段在内存中的起始位置）三个字段
<br>各个段表项的长度是相同的，段号是可以隐藏的，不占存储空间（类比数组的下标访问，数组下标也不占存储空间）
<br>在进行地址转换的过程中需要使用到段表寄存器，在程序运行开始时，从 PCB 中恢复段表寄存器中的值<br>
<img alt="Pasted image 20250606194109.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606194109.png"><br>
访问过程大体和页式存储一致，不一样的是在得到段号之后还需要比较段内偏移量是否越界，因为每个段的长度都是不一样的，所以需要进行判断
<br>分段式存储实现简单进程间共享数据的方法如下，使得不同进程的段表中分别指向同一个段对应的物理地址<br>
<img alt="Pasted image 20250606195433.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606195433.png"><br>为什么分页不利于实现进程之间数据共享<br>
因为在进行分页时，可能会出现多个进程同时访问的代码存在不同的页中，可能共享代码存在的那个页中还存在其他部分不能共享的代码，这显然是不合理的
<br>对应分页存储管理的措施、方法都可以应用到分段存储管理<br>
分段式存储进行地址转化时需要进行两次访存，第一次访问段表，第二次访问对应真实的物理地址<br><br>——结合分段管理和分页管理的优点，按照逻辑模块进行分段，将各段再进行分页，将内存空间划分为大小相同的各个页框<br>按照上述分段之后再分页，所以逻辑地址结构由段号、页号、页内偏移量组成<br>段号的位数决定了一个进程最多能分多少段，页号的位数决定了一个段最多能分为多少页，页内偏移量决定了内存块的大小<br>
分段对于用户来说是可见的，程序员编程时需要显式的给出段号、段内地址，而将各段分为各个页对于用户来说是不可见的，系统会根据段内地址自动划分页号和页内偏移量
<br>此时对于段表的定义需要更新<br>
段表由段号、页表长度、页表存放块号组成，其中页表长度表示的是将一个段分为多少个页，段号页式可以隐式表示的<br>段页式和页式管理的页表都是一样的，记录的都是页号到内存中的映射位置<br>对应逻辑地址到物理地址转换的过程<br>
<img alt="Pasted image 20250606201645.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250606201645.png"><br>
需要注意的是段页式存储需要进行两次比较，分别比较段号是否越界，以及段内的页号是否越界<br>在段页式存储进行地址的转化过程需要进行三次访存<br>
第一次访问段表<br>
第二次访问页表<br>
第三次访问真实的物理内存<br>同样的，也可以引入快表机制，使用块号和页号作为标记进行访问，快表命中就不需要访问段表和页表了，可以直接访问对应真实物理地址]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\3.1：内存的基本知识.html</link><guid isPermaLink="false">review/操作系统/3.内存/3.1：内存的基本知识.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 11 Jun 2025 08:58:40 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250605182554.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250605182554.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Drawing 2025-06-13 21.00.10]]></title><description><![CDATA[ 
 ]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\drawing-2025-06-13-21.00.10.excalidraw.html</link><guid isPermaLink="false">review/操作系统/4.文件管理/Drawing 2025-06-13 21.00.10.excalidraw.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 13 Jun 2025 13:00:10 GMT</pubDate></item><item><title><![CDATA[磁盘格式化]]></title><description><![CDATA[ 
 <br><br><br>——低级格式化：划分扇区，检测坏扇区，并且使用备用扇区替换坏扇区<br>
坏扇区对于 OS 来说是透明的，<br><br>——高级格式化：将磁盘进行一个个的分区（又称为卷，C、D、E 盘），对应每个分区从哪个地址到哪个地址需要由分区表记载，分区表存在于主引导记录中<br>
<img alt="Pasted image 20250613194133.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613194133.png"><br>
进行逻辑格式化之后会在磁盘中写入主引导记录，然后对应系统盘中写入引导块（引导开机并初始化操作系统），超级块（记录空闲区块），空闲空间管理（如位示图），i 节点区（对应的就是索引节点），根目录（所有系统都会有的，基于根目录建立下一级目录和构建新文件）
<br>逻辑格式化之后灰色的部分是实际被填充数据的部分，白色部分需要自行添加数据<br><br>在内核区中，存放着目录的缓存（近期访问过的目录文件）、系统打开文件表、进程（用户）打开文件表<br>
在用户区中存放着打开文件的文件描述符<br>
<img alt="Pasted image 20250613194754.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613194754.png"><br><br><br>对于不同的设备有着不同的文件系统，对应文件格式化不一样，对外提供的系统调用可能也不一样，例如磁盘采用 UFS 文件系统，移动硬盘采用 NTFS 文件系统，U 盘采用 FAT 文件系统，他们对外提供的系统调用可能不一样，对应系统调用的参数数量、参数类型可能也不一样<br>
<img alt="Pasted image 20250613195649.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613195649.png"><br>
产生的问题<br>
如果对应不同文件系统提供的系统调用不一样，那么在编写代码起来会格外的困难，所以就在中间封装一层虚拟文件系统<br><br>——为了解决不同文件系统提供的系统调用不一致的问题，在中间再封装一层，对上提供统一的系统调用，对下兼容各种文件系统的系统调用<br>
<img alt="Pasted image 20250613195835.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613195835.png"><br>
添加了虚拟文件系统之后，用户只需要根据虚拟文件系统提供的系统调用去编写代码实现系统调用即可
<br>虚拟文件系统的特点<br>
<br>向上层用户提供了一个同一标准的系统调用接口，屏蔽底层具体文件系统的实现差异
<br>要求下层文件系统必须实现某些规定函数的功能，如：open、read、write
<br>每打开一个文件之后都会在主存中新建一个 vnode 节点用来保存文件信息
<br>虚拟文件系统存在的问题<br>
不同的文件系统，表示文件的数据结构各不相同，打开文件之后，其在内存中的表示方式就不同<br>
解决方法<br>
对于不同的文件系统，只要使用 open 打开了文件之后，都将文件的信息保存在 vnode 结构体中，这样虚拟文件系统都可以使用同一的 vnode 节点表示对应文件的数据<br>
vnode 只存在于内存中，inode 可能既会被调入内存中也存在于外存中<br>
Inode 一般是跟文件系统紧密相关的，vnode 一般始于 VFS 有关的，当 VFS 根据文件名从对应文件系统中找到对应的 inode 之后将文件的相关信息保存到 vnode 中，同时也保存对应文件功能函数指针（指向对应的功能函数）
<br><br>——又称文件系统的安装/装载<br>文件系统挂载要做的事<br>
<br>在 VFS 中注册新挂载的文件系统，内存中的挂载表中包含各个文件系统的相关信息，包括文件类型，容量大小等
<br>新挂载的文件系统需要向 VFS 提供一个函数地址列表（每个文件系统的系统调用实现方式、存放位置都不一样，这么做是为了统一系统调用，也就是 vnode 中的函数调用指针）
<br>将新的文件系统加入到挂载点中，也就是要将新文件系统挂载在某个父目录下
]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\4.3：文件系统的全局结构.html</link><guid isPermaLink="false">review/操作系统/4.文件管理/4.3：文件系统的全局结构.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 13 Jun 2025 12:36:36 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613194133.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613194133.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[存储空间的划分与初始化]]></title><description><![CDATA[ 
 <br><br>将一个存储空间划分为若干个文件卷，每个文件卷又初始化为目录区和文件区<br>
目录区：主要用来存储文件目录信息（FCB），用于磁盘存储空间管理的信息<br>
文件区：用于存放普通的文件数据<br>
<img alt="Pasted image 20250612195214.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612195214.png"><br><br>空闲表有两个表项，第一个表项为“第一个空闲盘号”，用来存储空闲盘的开始盘号，第二个是“空闲盘快熟”，用来表示对应连续空闲盘的数量<br>如何分配空闲块<br>
与内存管理的动态分区分配很相似，为一个文件分配连续的空间，同样可以采用首次适应、最佳适应、最坏适应等算法来实现决定为文件分配哪个区间<br>如何回收磁盘块<br>
与动态分区分配很相似，对应需要查看前后是否含有空闲分区，如果有空闲分区的话，那么应该将空闲分区进行合并，总之就是要注意对前后空闲分区表项合并问题<br><br>空闲盘块链：以空闲盘块组成一条空闲盘块链，对应将磁盘中空闲的盘块使用链表综合在一起<br>
空闲盘区链：是以空闲盘区组成一条空闲盘区链，将对应磁盘中恋曲的空闲块构成一个空闲盘区，使用链表将其组织起来<br><img alt="Pasted image 20250612200514.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612200514.png"><br>空闲盘块链表对应操作系统中保存了链头指针、链尾指针，便于后面对空闲块的分配与回收<br>
空闲盘块链对应空闲块的分配<br>
如果某个文件申请 k 个磁盘，则从链头开始依次摘 k 个盘块开始分配，并修改空闲链的头指针<br>
空闲盘块链对应空闲块的回收<br>
将回收的空闲块依次挂到链表尾部，并修改空闲链表的尾指针<br>空闲盘区链对应操作系统保存了链头、链尾指针<br>
如何分配<br>
若文件申请 k 个盘块，可以采用首次适应、最佳适应、最坏适应等算法，从链头开始检索，找到一个合适的空闲分区，如果没有找到合适大小的空闲分区，也可以将不同盘区的空闲盘块分配给同一个文件，分配之后需要修改链指针的指向以及对应空闲区长度大小<br>
【对于离散分配、连续分配都适用，为一个文件分配多个盘块时效率更高】<br>
如何回收<br>
如果回收盘区和某个空闲盘区相邻，则需要将回收盘区和空闲盘区合并到空闲盘区中，若没有相邻的空闲盘区，那么就作为一个独立的空闲盘区挂到链表尾部<br><br>每个二进制位表示一个盘块，0 表示盘块空闲，1 表示盘块已分配<br>
<img alt="Pasted image 20250612202223.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612202223.png"><br>如何分配<br>
若需要 k 个块，那么按照顺序扫描位示图，找到 k 个相邻或者不相邻的“0”，根据字号和位号计算出对应的盘号，将相应盘块分给文件，相应的将对应盘号的位示图位置修改为 1<br>如何回收<br>
根据回收的盘块号计算出对应的字号和位号，将相应二进制位设置为 0<br><br>空闲表法和空闲链表法不适用于大型系统，因为空闲表和空闲链表可能会过大，因此采用成组链表法对磁盘空闲块进行管理<br>
在文件卷的目录中专门用一个磁盘块作为“超级块”，当系统启动时，将“超级块”中的内容读入内存，并且要保证内存中的数据和“超级块”中的数据一致<br>
<img alt="Pasted image 20250612203658.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612203658.png"><br>
当申请的空间为 100 时，此时查询超级块中的内容，发现正好可以分配 100 块空闲分区，那么将下面的空闲分区分配给文件，但是对应 300 号分区中存储着链接下面空闲分区块的信息，在将 300 号分区分配之前需要将 300 号分区的内容复制到上一级（也就是超级块）中指向自己的块中<br>
<img alt="Pasted image 20250612204139.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612204139.png"><br>如何回收<br>
如果需要回收对应空闲块，首先查看块中空闲块数量是否已满，如果未满那么就将其插入到块中，将空闲数量+1，如果满了那么就继续向后查看空闲块是否已满<br>
如果对应块中都满了，那么就将这个空闲块作为一个新的块，并且将超级块中的内容复制到这个块中，然后再让超级块指向这个块<br>
<img alt="Pasted image 20250612204634.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612204634.png"><br><br><br>当用户点击操作系统的创建文件之后，实际上是进行了 create 的系统调用<br>在进行 create 系统调用时，需要传递的参数有<br>
<br>所需空间的大小
<br>文件存放路径
<br>文件名
<br>操作系统接收到 create 系统调用时，主要的操作为<br>
<br>在外存中找到文件所需空间（结合上面的空链表法，位示图，组成链法等方法去查找对应空闲分区）
<br>根据文件存放路径的信息找到改目录对应的目录文件，在目录中创建对应的目录项，目录项中包含了文件的各种信息
<br><br>用户点击删除文件之后，实际上执行了 delete 系统调用，将文件从外存中删除<br>进行 delete 调用时，需要提供的参数有<br>
<br>文件存放路径
<br>文件名
<br>操作系统处理 delete 系统调用时，进行的操作是<br>
<br>根据文件对应的存放路径找到对应目录文件，根据目录文件找到文件名所在的目录项
<br>根据目录项中记录的文件存放位置，文件大小等信息，将分配的磁盘块进行回收（根据对应的管理方法执行对应的空间回收算法）
<br>从文件目录对应的目录文件中将相应的目录项删除
<br><br>很多操作系统中，在对文件操作之前需要先打开文件，执行 open 系统调用<br>open 系统调用需要提供的参数有<br>
<br>文件存放路径
<br>文件名
<br>对文件的操作类型（r、rw）只读？只写？读写<br>
操作系统在执行 open 函数调用时进行的操作是
<br>首先根据存放路径找到对应的目录文件，找到目录文件之后再查找对应的目录项，并且检查用户是否有指定的操作权限
<br>将目录项中的内容加载到内存的打开文件表中，并且将对应表目中的编号返回给用户，之后用户就可以通过编号指定要操作的文件<br>
<img alt="Pasted image 20250613170906.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613170906.png">

一般会有两种打开文件表<br>
一: 第一种是系统打开文件表, 整个系统只有一张, 其中记录了整个系统打开的文件, 以及对应编号, 还有打开计数器 (用来记录打开这个文件的进程有多少)<br>
二: 第二种是进程打开文件表, 每个进程对应一张, 用来记录每个进程打开的文件以及打开的文件对应在系统文件中的索引, 以及访问权限<br>
<img alt="Pasted image 20250613171250.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613171250.png">


<br>通过上面的描述实现对打开文件的管理可以方便实现某些文件管理的功能,<br>
例如: 如果需要删除某个文件, 系统此时会检查该文件是否被进程占用 (既是否有进程打开了这个文件), 此时就会提示我们暂时无法删除该文件, 如果没有进程占用, 那么可以正常删除文件
<br><br>进程使用完文件之后, 还要进行一次 close 调用<br>进行 close 调用时操作系统主要工作是<br>
<br>将进程打开文件表中的对应目录项删除
<br>回收分配给该内存的内存空间等资源
<br>对系统打开文件表中的对应表项的打开文件计数器执行-1 操作
<br><br>用户双击打开文件的时候, 实际上是调用了操作系统的 read 系统调用<br>read 系统调用需要的参数有<br>
<br>文件索引 (在打开文件表中的对应文件名的编号)
<br>指明需要读入多少数据
<br>指明读入的数据要放在内存中的什么位置
<br>在进行 read 系统调用时, 操作系统的主要操作是<br>
<br>根据读写指针指向的内存空间地址读取用户指定大小的数据
<br>将用户指定大小的数据放入用户指定的内存区域
<br><br>用户点击保存时, 实际是进行了 write 的系统调用<br>执行 write 系统调用所需要的参数有<br>
<br>指明是哪个文件 (有打开文件表的系统中只需要传入对应文件索引号)
<br>指明写回多少数据
<br>指明写回外存的数据放在内存的哪个位置
<br>操作系统执行 write 系统调用的过程是<br>
<br>从用户指定的内存空间中, 将指定大小的数据写入指针指向的外存
<br><br>操作系统为多个用户提供文件共享功能, 可以让很多用户共享的使用同一个文件<br>
多个用户共享一个文件意味着系统中只有一份文件数据, 并且只要某个用户修改了文件的数据, 其他用户也可以看到文件数据的变化
<br><br>索引节点 (根据 4.1 笔记中的内容)就是将文件的所有信息放在一个节点中, 这个节点就是索引节点, 然后有一张索引表, 记录着文件名到对应索引节点的映射关系, 本质上是一种文件目录的瘦身策略, 减少了每次检索文件时调入内存的数据, 采用索引节点就可以只加载文件名和对应索引节点编号就行<br>对于多用户索引节点方式就需要在原来的索引节点的基础上添加一个 count 数据项, 用来表示链接到该索引节点上的用户数目<br>如果 count 大于 0, 表示有别的用户正在使用该文件, 所以并不可以直接将文件数据删除, 否则会导致指针悬空<br><br>与硬链接不同的是, 软链接索引结点指针指向的是对应的链接文件, 这个链接文件中存放了所需共享文件的存放路径 (与 Windows 中的快捷方式类似)<br>索引表中的 count 数据项表示的含义与硬链接是一致的, 表示的都是有多少用户指向了该共享文件<br>
当 count 大于 0 的时候表示的是还有其他用户在访问这个文件, 此时不能直接删除文件中的数据<br><img alt="Pasted image 20250613185529.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613185529.png"><br><br>保护文件数据安全<br><br>为文件设置一个"口令", 用户访问文件时必须要提供口令<br>一般来说, 口令存在文件的 FCB 或者索引节点中, 用户访问文件之前需要先输入口令, 操作系统会将用户提供的口令与 FCB 或者索引节点中的口令进行比较, 如果相同那么允许用户访问文件<br>优点:<br>
<br>保存口令的空间开销不多, 验证口令的时间开销也很小<br>
缺点:
<br>口令存储在系统内部, 不够安全
<br><br>使用某个密码对文件进行加密, 在访问文件时需要提供正确的密码才能访问文件<br>
注意加密与口令的不同, 加密方式对文件内容根据密钥进行某种加密, 用户如果需要解密, 也需要获取对应的密钥, 之后才能对文件内容进行解密, 之后才能获取文件的最终内容<br>
而口令相当于一个文件锁, 需要输入对应锁的口令才能解锁文件正常访问<br>
口令是操作系统和用户都能感知到的, 密码是只有用户才能感知到
<br>只有用户提供相同的密码, 才能将加密之后的文件解密为正确的文件内容, 如果使用的是错误的密码, 就不能解密得到一个正确的文件内容<br>优点:<br>
<br>保密性强, 不需要在系统中存储密码<br>
缺点:
<br>编码/译码,或者说加密/解密需要一定的时间开销
<br><br>在文件的 FCB 或者索引节点中添加一个访问控制表, 该表中记录了各个用户可以对文件执行哪些操作<br>
<br>读：从文件中读数据
<br>写: 向文件中写数据
<br>执行: 将文件装入内存并执行
<br>添加: 将新信息添加到文件结尾部分
<br>删除: 删除文件, 释放空间
<br>列表清单: 列出文件名和文件属性<br>
此外，还可以对文件的重命名，复制，编辑等加以控制，这些更高层的内容通过系统程序调用低层系统调用来实现<br>
<img alt="Pasted image 20250613191525.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613191525.png"><br>
计算机中可能有多个用户的话，可能会导致访问控制表太大，可以用精简访问控制列表来解决上述问题
<br>精简访问控制列表<br>
以组为单位，标记各组用户可以对文件执行哪些操作<br>
<img alt="Pasted image 20250613191920.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613191920.png"><br><br>（408 大纲不考察）<br>
<img alt="Pasted image 20250613192908.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613192908.png"><br><img alt="Pasted image 20250613193245.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250613193245.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\4.2：文件存储空间管理与操作.html</link><guid isPermaLink="false">review/操作系统/4.文件管理/4.2：文件存储空间管理与操作.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 13 Jun 2025 11:32:47 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612195214.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612195214.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[文件的基本概念]]></title><description><![CDATA[ 
 <br><br>文件就是一组有意义的信息集合<br><br>文件名：由创建文件的用户决定文件的名称，方便用户查找文件，同一目录下不能存在相同名称的文件<br>
标识符：一个文件系统中各标识符唯一，对于用户来说没有实际意义，因此标识符是 OS 区分各个文件的一种内部名称<br>
文件类型：指明文件类型<br>
位置：文件的存放路径（让用户使用），在外存中的地址（操作系统使用，对用户不可见）<br>
文件大小：指明文件大小<br>
还有文件创建时间，上次修改信息，文件所有者等信息<br>
保护信息：对文件的访问进行控制的信息<br>无结构文件：（如文本文件）由一些二进制或者字符流组成，又称流式文件<br>
有结构文件：（如数据库表）由一些相似的记录组成，又称记录式文件，其中记录是一组相关数据的集合，记录中包含很多数据项，数据项是文件系统中最基本的单位<br><br>
<br>按照性质和用途分类：系统文件、用户文件、库文件
<br>按照文件中数据形式分类：源文件、目标文件、可执行文件
<br>按存取控制属性分类：可执行文件、只读文件、读、写文件
<br>按照组织形式和处理方式分类：分为普通文件、目录文件、特殊文件
<br><br><img alt="Pasted image 20250609173004.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609173004.png"><br>
通过目录的形式将文件组织起来，方便用户管理<br>操作系统应该向上提供哪些内容<br>
创建文件、读写文件、删除文件，打开、关闭文件（在读写文件之前需要“打开”文件，在读写文件结束之后需要“关闭”文件）<br>
<img alt="Pasted image 20250609173414.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609173414.png"><br>
读文件：读、写文件之前需要打开文件<br>
写文件：读、写完成之后需要关闭文件<br>
复制文件：先创建一个新的空文件，再把源文件读入内存，再把内存中的数据写入新的文件中<br><br><br>外存和内存一样，也是由一个个存储单元构成，每个存储单元可以存放一定量的数据，每一个存储单元对应一个物理地址<br>类似内存的分块，外存也会分为一个个块/磁盘块/物理块，每个磁盘块的大小是相等的，每块一般包含 2 的正数幂个地址，与内存的分页类似，文件的逻辑地址也可以分为逻辑块号，块内地址，操作系统同样会将逻辑地址转换为物理地址，块内地址的位数取决于磁盘块的大小<br>操作系统以块为单位为文件分配存储空间，即使文件大小远远不足一个块的大小，但是实际分配仍然分配一个外存块，外存中的数据读入内存时同样以块为单位进行数据交换<br><br>所谓“逻辑结构”是指在用户看来，文件内部数据是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何放在外存的【类比数据结构的逻辑结构和物理结构】<br>
与数据结构一样，文件操作的具体实现与文件的逻辑结构和物理结构都有关<br>此处的文件结构不讨论无结构文件，只讨论有结构文件【由一些相似的记录组成，又称记录式文件，其中记录是一组相关数据的集合，记录中包含很多数据项，数据项是文件系统中最基本的单位】，一般来说有一个数据项可以作为关键字<br>按照各条记录所占空间是否相等，可以将记录分为定长记录和可边长记录两种<br>
定长记录：每条记录长度都相等，各数据项都处在记录中相同的位置，具有相同的顺序（各数据项在主存中的排布）和长度（记录占用主存空间的大小）<br>
可变长记录：例如各个学生的特长，由于特长的字段不固定，导致数据项长度不确定，因此这个数据项的长度是可变的，称为可编程记录<br><br><br>——文件的记录一个接一个的顺序排列，记录上是可变长的，各记录在物理上可以顺序存储或者链式存储<br>
排列的方式和性质可以类比顺序表和链表<br>按照记录之间的顺序是否按关键字排列可分为<br>
串结构：记录之间的顺序与关键字无关（通常按照记录存入时间顺序决定记录的顺序）<br>
顺序结构：记录之间的顺序按照关键字排列<br>假设我们知道了文件的起始地址，是否能够快速的找到第 i 个记录对应的地址<br>

<br>如果按照链式存储，无法实现随机存取，只能每次从第一个记录开始依次向后查找
<br>如果按照顺序存储，如果是定长记录，那么可以实现随机存取
<br>如果是顺序存储，如果是可变长记录，那么无法实现随机存取
<br>如果顺序存储采用的是顺序结构，也就是记录存放有序，那么可以快速的找到某个关键字对应的记录，使用二分查找
<br>如果顺序存储采用的是串结构，也就是记录无序，可以实现随机存取，但是无法快速的找到某个关键字对应的记录

<br><img alt="Pasted image 20250609181802.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609181802.png"><br><br>——对于顺序文件如果是可变长记录，要找到第 i 个记录，就必须先找到前 i-1 个记录，索引文件解决的就是顺序文件对可变长记录快速检索的不支持问题<br>解决方法：使用一张索引表，将对应索引号、记录长度、指针放在一个索引表中，指针指向对应记录存放的物理地址（在磁盘中），这样可以实现逻辑文件在物理上离散的存放<br>但是由于索引表需要要求有序，当需要插入/删除一条表项时，需要对索引表进行修改，由于索引文件有很快的索引速度，因此主要用于对信息处理的及时性要求比较高的场合<br><br>——索引文件，每一条记录对应一条索引表项，索引表可能会很大，这样可能会导致存储效率的降低<br>
解决方法：结合索引文件和顺序文件，同样会为每个文件设置一张索引表，但是不同的是，并不是每个记录都对应一个索引表项，而是将记录分组，每个分组是一个顺序文件，每个组对应一条索引表项<br>
<img alt="Pasted image 20250609183430.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609183430.png"><br><br>给定记录的键值，通过散列函数的转换直接决定记录的物理地址，散列具有很高的存取速度，但是会出现散列冲突<br><br>——为了进一步提高检索效率，可以为顺序文件建立多级索引表，类似字典树<br>
<img alt="Pasted image 20250609183707.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609183707.png"><br><br>——就是 windows 熟悉的文件夹，可以很方便的对用户实现按名存取<br>
目录文件是一种有结构的文件，它是由一条一条记录组成的，每一条记录对应一个放在该目录下的文件<br><br>对于目录文件中的一条记录就对应一个文件控制块（FCB），用来记录文件的一系列信息<br>
FCB 的有序集合称为“文件目录”，一个 FCB 就是一个文件目录项<br>
FCB 包含文件的基本信息，文件名、物理地址、逻辑结构等，还有文件的存取控制信息，最主要的还是文件名，文件存放的物理地址<br>
<br>基本信息：文件名、物理位置、文件的逻辑结构、文件的物理结构
<br>存取控制信息：文件的存取权限，标准用户的存取权限，一般用户的存取权限
<br>使用信息：文件建立时间，上次修改信息<br>
需要对目录进行哪些操作
<br>
<br>搜索：当用户要使用一个文件时，系统需要根据文件名搜索目录，找到对应的目录项
<br>创建文件：创建一个新文件就需要在其所属的目录中增加一个目录项
<br>删除文件：删除文件不仅需要杉树对应文件中的数据，也需要删除对应的目录项
<br>显示目录：用户可以显示目录中的内容，如显示目录中的所有文件以及响应属性
<br>修改目录：文件的属性保存在目录中，因此这属性变化需要修改对应的目录项
<br>单级目录结构<br>
早期操作系统并不支持多级目录，整个系统建立一张目录表，每个文件占一个目录项，单级目录实现了“按名”存取，但是不允许文件重名<br>
在创建文件的时候，需要先检查目录表中有没有重名文件，确定不重名之后才允许建立文件，并且将新文件对应表项插入对应目录中<br>
显然，单级目录结构不适合多用户操作系统<br>两级目录结构<br>
两级目录结构，主文件目录和用户文件目录，主文件目录存放的就是用户名及其相应用户文件目录存放的位置，用户文件目录由用户文件 FCB 构成<br>
在这种目录结构下，允许不同用户文件重名，但是不允许用户重名<br>多级目录结构<br>
多级目录结构，又称树形目录结构，在不同目录下文件可以重名，当用户或进程想要访问某个文件时，需要用文件路径标识文件，文件路径名是一个字符串，, 各级目录之间需要使用‘/’隔开，从根目录出发的叫做绝对路径<br>
对于想要连续访问当前目录下的文件，如果全部都从根目录向下找效率很低，那么就设置一个当前目录，用户想访问某个文件时，以当前目录为根目录进行访问，因为当前目录的目录文件已经被调入内存中了，从当前路径访问文件，不需要再进行访问硬盘的操作，这就是相对路径，效率比绝对路径快很多，IO 次数减少了<br>树形结构<br>
树形结构可以很方便的对文件进行分类，层次结构清晰，可以很有效进行文件的管理和保护，但是树形结构不利于实现对文件的共享，为此提出了无环图目录结构<br>无环图目录结构<br>
是在树形目录的基础上增加一些指向同一个文件的有向边，使得整个目录称为一个有向无环图，可以更方便的实现多个用户间的文件共享<br>
<img alt="Pasted image 20250609192146.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609192146.png"><br>
注意：可以将不同用户的不同文件名指向一个相同的文件，甚至可以指向同一个目录（共享一个文件夹下的所有内容）<br>
在删除文件时，或有一个共享计数器用来记录该文件被多少用户共享，用户提出删除文件的请求时，只是删除该用户的 PCB，并使共享计数器-1，并不会直接删除共享节点，只有当共享计数器减为 0 的时候才会删除节点<br>共享文件不同于复制文件，在共享文件中，两个用户看到的是同一个文件，因此只要其中一个用户修改了文件，另一个用户也可以看到文件数据变化，但是复制文件指的并不是同一个文件，一个用户对文件进行修改并不会影响另一个用户的文件<br><br>使用索引表来代替文件目录，减少了每次调入内存的数据量，将对应文件的索引指向对应的节点，然后去访问对应的节点将索引节点调入内存，里面记录了文件的各种信息，包括文件在外存中存放的信息，根据存放位置找到对应文件数据<br>
<img alt="Pasted image 20250609193242.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609193242.png"><br>
磁盘索引节点<br>
放在磁盘上的索引节点：每个文件有一个唯一的磁盘索引节点，包括<br>
<br>文件主标识符：拥有这个文件的个人或小组的标识符
<br>文件类型：包括普通文件、目录文件或者特别文件
<br>文件存取权限：各类用户对该文件的存取权限
<br>文件物理地址：每个索引节点中都含有 13 个地址项，他们以直接或者间接的方式给出数据文件所在盘块的编号
<br>文件长度：文件占用空间大小
<br>文件链接计数：文件系统中指向该文件的文件名的指针数
<br>文件存取时间：最近被进程存取、修改的时间以及索引节点最近被修改的时间<br>
内存索引节点
<br>索引节点号：用于标记内存索引节点
<br>状态：指明 i 节点是否被上锁或者修改
<br>访问计数：每当有进程访问 i 节点时，计数+1，访问结束计数-1
<br>逻辑设备号：文件所属文件系统的逻辑设备号
<br>链接指针：设置分别指向空闲链表和散列队列的指针
<br><br>文件块、、磁盘块：类似于内存分页，磁盘中的存储单元也会被分成一个个“块/磁盘块/物理块”，很多操作系统中，磁盘块的大小与内存块、页面大小相同<br>
同样的，在外存的管理中，为了方便对文件数据进行管理，文件的逻辑地址空间也被分为了一个个文件块，于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式<br>逻辑块号：文件按照块大小被分为各个块，逻辑块号描述的就是这部分内容在哪一块<br>
块内地址：这部分内容在块内的偏移量为多少<br>
<img alt="Pasted image 20250612154629.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612154629.png"><br>
类比进程的逻辑地址和进程的物理地址，文件也是如此，拥有逻辑地址到物理地址的转换过程<br><br>逻辑上相邻的块在物理上也需要相邻，占用一组连续的块<br>
在这种分配方式下，只需要进行逻辑块号到物理块号的转换，因为物理块的大小和逻辑块的大小是一样的，对应内容的块内偏移量是一样的<br>对于这种连续分配方式，需要在目录表中记录对应文件的起始块号、文件长度，这样就可以根据文件的逻辑地址转换到文件的物理地址，查找目录中文件对应目录项<br><br>连续分配方式支持顺序访问和直接访问（随机访问），因为可以直接根据逻辑地址得到物理地址<br>优点：<br>
<br>支持顺序访问和随机访问
<br>顺序访问容易，并且速度快，文件占用的块可能在一条或几条连续的磁道上，磁头的移动距离小<br>
缺点：
<br>要为文件分配连续的存储空间，与进程的连续分配相似，会产生许多内部碎片，可以采用紧凑的方式，但是开销很大
<br>必须事先直到文件的长度，并且无法满足文件动态增长的需求，否则会覆盖后续的文件
<br>为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动
<br><br><br>在目录项中记录了文件对应的起始块号、终止块号<br>
在文件对应的文件块中，每个磁盘块都会保存指向下一个盘块的指针，这些指针对用户是透明的<br>对于一个给定的逻辑块号 i，在访问物理块号的时候，需要从文件对应的第一个物理块号（逻辑块号 0）进行访问，然后依次向后访问到第 i 个物理块，因此需要进行 i+1 次磁盘 IO 操作<br>
因此对于链接分配（隐式链接），只支持顺序访问，不支持随机访问，查找效率低，另外存储下一个盘块位置也需要耗费少量的存储空间<br>缺点：<br>
<br>只支持顺序访问，查找效率很低
<br>稳定性问题：文件盘块中任何一个指针丢失都会导致文件数据的丢失
<br>指向下一个盘块的指针也需要消耗一部分存储空间
<br>优点：<br>
<br>方便扩展文件，如果需要进行文件扩展，找一个空闲磁盘块，挂到文件的磁盘块队尾，并且修改文件 FCB
<br>所有空闲磁盘都可以利用，不会有碎片问题，外存利用率高
<br><br>——与隐式链接的不同，显式链接会将各个物理块的指针显式的放在一张表中，既文件分配表<br>
对应一个文件有多少块，那么在文件分配表中就会有多少个表项，对应的物理块号和下一块号作为一个表项，目录文件中存储对应文件的起始块号<br>
<img alt="Pasted image 20250612162520.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612162520.png"><br>
注意：一个磁盘仅有一个 FAT，在开机时将 FAT 读入内存，并且常驻内存，FAT 在个表项在物理上连续存储，每个字段长度相同，因此物理块号的长度可以省略<br>如何实现文件逻辑块号到物理块号的转变<br>
查找对应文件的 FCB，找到文件的起始块号，查询对应 FAT，依次访问对应文件的块，直到找到对应的物理块号
<br>在显式链接存储中，逻辑块号转化为物理块号是不需要经过都磁盘的操作的<br>
优点：<br>
<br>支持顺序访问，也支持随机访问，房屋内第 i 块，直接查询 FAT 表，可以查找到对应第 i 块的物理块号
<br>FAT 在启动时被调入内存，检索是在内存中进行的，不仅提高了检索的速度，也减少了访问磁盘的次数<br>
缺点：
<br>FAT 在内存中需要占用一定的内存空间
<br><br>索引分配允许文件离散的分配在各个磁盘块中，系统会为每个文件构建一个索引表，索引表中记录了各个逻辑块对应的物理块（索引表的功能对应内存管理中的页表，建立逻辑页面到物理页面的映射）。存放索引表的磁盘块称为文件索引块，存放文件数据的磁盘块称为数据块<br>在使索引分配的方式目录中存放的是文件以及其文件索引块的位置，对应两个数据项，可以查找此表根据文件名找到对应的文件索引块，然后根据索引块中的索引表建立逻辑块到物理块之间的映射<br>索引分配方式，如何实现逻辑块号到物理块号的转换<br>
如果需要查找文件的第 i 块数据，首先根据文件名查找到索引块的物理块号，然后再根据索引表中的对应逻辑块与物理块之间的映射关系，可以查找到逻辑块对应的物理块
<br>索引分配方式支持随机访问，也可以很方便的实现文件内容扩展（只需给文件分配一个空闲的物理块，然后再添加一个索引表项就行）<br>如果一个磁盘块无法全部放下索引表的全部表项的话，如何解决呢？<br>
<br>链接方案
<br>多层索引
<br>混合索引
<br>1. 链接方案<br>
如果索引表项太大，一个索引块放不下，那么可以将多个索引块链接起来存放<br>
采用此种方式，文件的 FCB 中只需要记录第一个索引块的物理块号就行，在每个物理块之后都采用一个指针指向存放索引表的下一个索引块<br>
<img alt="Pasted image 20250612181339.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612181339.png"><br>
对于上述索引块很多的话，采用链接方案在访问靠后的索引块时间开销很大（因为需要进行多次的磁盘读取操作）
<br>优点：<br>
<br>支持直接访问，索引块的第 i 个索引项就指向对应物理块
<br>不会产生外部碎片<br>
缺点：
<br>每个文件都需要分配一个索引块，即使文件很小，也需要一个索引块，对于索引块的利用率不是很高
<br>索引块增加了额外的存储空间的开销
<br>2：多级索引<br>
建立多层索引，（原理类似多级页表），使得第一层索引块指向第二层索引块，依次类推，可以表示更多的索引项<br>对应在 FCB 中记录的是文件对应的第一级索引表存放的物理块号就行<br>
<img alt="Pasted image 20250612183849.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612183849.png"><br>
采用多级索引，如何实现逻辑块到物理块之间的转换，例如访问 1026 号逻辑块，每个块中能存储 256 个索引项<br>
根据 1026/256 = 4，1026%256 = 2 可知，对应 1026 号逻辑块应该是在第四个索引块中的第二个索引项，所以 OS 根据 FCB 中一级索引表中查找 4 号索引块对应的物理块号，然后再去访问 4 号索引块，接着访问索引块中的第二个索引项，因此需要进行 3 次磁盘 IO 操作，前两次进行索引表的访问，第三次进行数据块的访问
<br>采用 K 层索引，则访问一个数据块只需进行 K+1 次磁盘 IO 操作<br>
优点：<br>
<br>极大加快了对大文件的索引速度<br>
缺点：
<br>当访问一个磁盘块的时候，所需要进行磁盘 IO 的操作随着索引级数的增加而增多，即使是访问很小的文件也是如此
<br>3. 混合索引方式<br>
在一个索引表中有着不同的索引方式，可以使用直接地址方式，对应直接指向数据块，也可以使用一级间接地址方式，对应指向一个一级索引表，根据索引表去查找对应数据块，或者二级间接，指向一个二级索引表，通过二级索引表指向实际的数据块<br>
<img alt="Pasted image 20250612183407.png" src=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250612183407.png"><br>
如果顶级索引表还未读入内存中<br>
<br>那么访问 0-7 号逻辑块需要两次读磁盘
<br>访问 8-263 号逻辑块需要三次读磁盘
<br>访问 264-65899 号逻辑块需要 4 次读磁盘操作<br>
采用混合索引，对于小文件来说，只需要进行较少的读磁盘的操作就可以访问目标数据块
<br>直接地址：<br>
——提高了小文件的检索速度，在顶级索引表中构建几个直接地址项，对于小文件可以使用直接地址访问对应物理地址<br>
一次间接地址：<br>
——用来存储中、大型文件，采用一级索引方式，对应根据一级索引表可以找到逻辑块号对应的物理块号<br>
二级间接地址<br>
——用来存储超大型文件，采用二级索引，第一级索引存放对应索引块的位置，第二级索引存放逻辑块对应物理块的位置<br>优点：<br>
<br>可以全面的照顾小、中、大型和特大型文件
<br>
考点：<br>
需要会根据多级索引计算出对应所能表示文件的最大长度<br>
能计算出访问某个逻辑块所需要读取磁盘的次数（要注意顶级索引块是否调入内存）
<br><br>——文件的逻辑结构是站在用户的角度看待文件的，而文件的物理结构指的是文件在外存上的存储<br>文件的逻辑结构中的顺序文件、索引文件等描述的是文件中的数据在文件中是如何存放的，指的是文件内部的组织方式<br>
文件的物理结构指的是操作系统对于这个文件是如何存放在磁盘上的，指的是整个文件在磁盘中是如何存放的<br>索引文件的索引表是用户自己建立的：将对应关键字映射到记录存放的逻辑地址<br>
索引分配的索引表是操作系统建立的：建立逻辑块号和物理块号之间的映射<br>对于逻辑结构，文件内部信息组织完全由用户决定，操作系统完全不关心文件内部存储的是什么，在用户看来，一个文件占用连续的逻辑地址空间<br>对于物理结构，由操作系统决定以什么方式存储到磁盘中，操作系统负责将逻辑地址转换为物理地址，（建立对应逻辑块号到物理块号之间的映射）]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\4.1：文件系统基础.html</link><guid isPermaLink="false">review/操作系统/4.文件管理/4.1：文件系统基础.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 12 Jun 2025 11:46:27 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609173004.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\操作系统\4.文件管理\img\pasted-image-20250609173004.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[缺页异常]]></title><description><![CDATA[<a class="tag" href="https://cs-note-three.vercel.app/?query=tag:中断处理" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#中断处理</a> <a class="tag" href="https://cs-note-three.vercel.app/?query=tag:缺页处理流程" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#缺页处理流程</a> 
 <br>若用户进程访问内存时产生缺页，则下面的选项中，操作系统可能执行的操作是<br>
<br>处理越界出错
<br>置换页
<br>分配内存<br>
A：1、2<br>
B：2、3<br>
C：1、3<br>
D：1、2、3
<br><a href=".\https:\\cs-note-three.vercel.app?query=tag:中断处理" class="tag" target="_blank" rel="noopener nofollow">#中断处理</a>  <a href=".\https:\\cs-note-three.vercel.app?query=tag:缺页处理流程" class="tag" target="_blank" rel="noopener nofollow">#缺页处理流程</a><br>
解析：根据虚拟页式请求分配的处理流程可知<br>
当接收到一个地址时，首先判断有没有出现越界的问题，如果有就转到对应中断处理程序<br>
后面执行的就是进行页面的访问<br>
如果页面不在内存中，产生缺页中断，进行处理调入页面<br>
如果页面在内存中，那么查找页表，访问对用页面的实际物理地址]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\错题\第二章\缺页异常.html</link><guid isPermaLink="false">review/操作系统/错题/第二章/缺页异常.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 11 Jun 2025 10:53:47 GMT</pubDate></item><item><title><![CDATA[下列关于多道程序系统的叙述，错误的是 1]]></title><description><![CDATA[<a class="tag" href="https://cs-note-three.vercel.app/?query=tag:操作系统的基本特点" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#操作系统的基本特点</a> <a class="tag" href="https://cs-note-three.vercel.app/?query=tag:线程调度" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#线程调度</a> 
 <br>下面关于多道程序系统的叙述, 错误的是（D）<br>
A：支持线程的并发执行<br>
B：不必支持虚拟存储管理<br>
C：需要支持对共享资源的管理<br>
D：进程数越多 CPU 利用率越高<br>
<a href=".\https:\\cs-note-three.vercel.app?query=tag:操作系统的基本特点" class="tag" target="_blank" rel="noopener nofollow">#操作系统的基本特点</a>  <a href=".\https:\\cs-note-three.vercel.app?query=tag:线程调度" class="tag" target="_blank" rel="noopener nofollow">#线程调度</a><br>答案：D：对于 OS 来说，进程越多可能会造成死锁，不一定 CPU 利用率越高<br>
A、C：并发、共享、虚拟、异步，一定要实现的是并发和共享，其他的不一定要全部实现<br>
B：早期的多道处理系统会将所有的进程都调入内存中，再让多道程序并发的执行，及时不实现虚拟存储管理也能实现并发]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\下列关于多道程序系统的叙述，错误的是-1.html</link><guid isPermaLink="false">review/操作系统/错题/第一章/下列关于多道程序系统的叙述，错误的是 1.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 24 May 2025 10:12:06 GMT</pubDate></item><item><title><![CDATA[中断,调用]]></title><description><![CDATA[<a class="tag" href="https://cs-note-three.vercel.app/?query=tag:系统中断" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#系统中断</a> <a class="tag" href="https://cs-note-three.vercel.app/?query=tag:函数调用" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#函数调用</a> 
 <br><a href=".\https:\\cs-note-three.vercel.app?query=tag:系统中断" class="tag" target="_blank" rel="noopener nofollow">#系统中断</a> <a href=".\https:\\cs-note-three.vercel.app?query=tag:函数调用" class="tag" target="_blank" rel="noopener nofollow">#函数调用</a> <br><br>中断处理和子程序调用都需要压栈, 以便于保护现场, 中断处理一定保存, 而子程序调用不需要保存的内容是<br>
A: 程序计数器<br>
B: 程序状态字地址<br>
C: 通用数据寄存器<br>
D: 通用地址寄存器<br>
解析:<br>
一般函数调用的执行是连续的, 执行过程中不会有外部因素影响 CPU 的状态, 函数调用仅需保存通用寄存器和 PC 的值还有通用地址寄存器等, 不需要保存 PSW 中的值<br>
对于中断处理, 因为中断前后执行的代码是不连续的, 因此需要保存好完整的现场, 例如各种寄存器中的值, 以及各种标志位等<br>
所以中断和函数调用的区别是, 中断需要保存 PSW 中的值, 而函数调用不需要保存 PSW 的值<br><br>处理外部中断时, 需要操作系统保存的是<br>
A:PC<br>
B: 通用寄存器中的值<br>
C: 快表中的内容<br>
D: Cache 中的内容<br>对于中断产生之后各部件的作用总结如下:<br>
<br>关中断: 由硬件实现
<br>保存断点 PC 的值, 由硬件实现
<br>保存现场, 置屏蔽字, 开中断, 保存通用寄存器的值, 由操作系统完成
<br>设备服务, 由操作系统实现
<br>退出中断: 由软件实现<br>
对于快表和 Cache 中的内容一般在处理外部中断时无需保存, 直接置 0 即可
<br><br>下列关于中断相关操作中, 由 OS 完成的是<br>
A: 保存被中断程序的中断点 (硬件实现)<br>
B: 提供中断服务(软件实现)<br>
C: 初始化中断向量表(软件实现)<br>
D: 保存中断屏蔽字(置屏蔽字, 软件实现)<br>]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\中断,调用.html</link><guid isPermaLink="false">review/操作系统/错题/第一章/中断,调用.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 24 May 2025 10:12:44 GMT</pubDate></item><item><title><![CDATA[用户态、内核态指令的执行]]></title><description><![CDATA[<a class="tag" href="https://cs-note-three.vercel.app/?query=tag:用户态和内核态" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#用户态和内核态</a> <a class="tag" href="https://cs-note-three.vercel.app/?query=tag:特权指令" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#特权指令</a> <a class="tag" href="https://cs-note-three.vercel.app/?query=tag:中断的产生" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#中断的产生</a> 
 <br>下列指令可以在用户态执行的是（B）<br>
Ⅰ：置时钟指令<br>
Ⅱ：停机指令<br>
Ⅲ：存数指令<br>
Ⅳ：寄存器清零指令<br>A：Ⅰ、Ⅳ<br>
B：Ⅲ、Ⅳ<br>
C：Ⅱ、Ⅲ、Ⅳ<br>
D：Ⅱ、Ⅳ<br>
<a href=".\https:\\cs-note-three.vercel.app?query=tag:用户态和内核态" class="tag" target="_blank" rel="noopener nofollow">#用户态和内核态</a> <a href=".\https:\\cs-note-three.vercel.app?query=tag:特权指令" class="tag" target="_blank" rel="noopener nofollow">#特权指令</a><br>Ⅰ：置时钟指令是直接管理系统资源的指令，需要在内核态执行<br>
Ⅱ：停机指令属于系统控制指令，需要在内核态执行<br>
Ⅲ：存数指令不涉及到系统安全等，可以在用户态执行<br>
Ⅳ：寄存器清零是寄存器的基本操作指令，可以在用户态执<br>
总结: 涉及到系统资源 (设置时钟, 启动/关闭 IO 设备, 切换进程, 设置中断等)<br>
系统状态修改 (修改中断向量表, 切换 CPU 运行模式)<br>
系统控制指令 (停机指令, 重启指令)<br>
上述都属于特权指令, 必须在内核态执行<br>
普通的数据处理, 流程控制, 读操作指令都可以在用户态执行
<br><br>下列选项不可能在用户态发生的事件是<br>
A: 系统调用<br>
B: 外部中断<br>
C: 进程切换<br>
D: 缺页<br>
注意区分在用户态发生和在用户态执行的区别<br>
<a href=".\https:\\cs-note-three.vercel.app?query=tag:中断的产生" class="tag" target="_blank" rel="noopener nofollow">#中断的产生</a><br>
对于系统调用可能是在进程执行的过程中, 发生系统调用, 可以在用户态执行<br>
外部中断也可以在用户态产生, 但是处理也要在内核态<br>
进程切换属于系统调用过程中发生的事, 必须在内核态执行<br>
缺页中断属于内部中断, 可以在用户态产生, 但是中断处理需要在内核态<br>]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\用户态、内核态指令的执行.html</link><guid isPermaLink="false">review/操作系统/错题/第一章/用户态、内核态指令的执行.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 24 May 2025 09:48:05 GMT</pubDate></item><item><title><![CDATA[错题]]></title><description><![CDATA[ 
 第一章3<a aria-label="更多选项" class="kanban-plugin__lane-settings-button clickable-icon"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a><a data-href="用户态、内核态指令的执行" href=".\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\用户态、内核态指令的执行.html" class="internal-link" target="_self" rel="noopener nofollow">用户态、内核态指令的执行</a><a data-ignore-drag="true" class="kanban-plugin__item-postfix-button clickable-icon" aria-label="更多选项"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a><a data-href="中断,调用" href=".\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\中断,调用.html" class="internal-link" target="_self" rel="noopener nofollow">中断,调用</a><a data-ignore-drag="true" class="kanban-plugin__item-postfix-button clickable-icon" aria-label="更多选项"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a><a data-href="下列关于多道程序系统的叙述，错误的是 1" href=".\https:\\cs-note-three.vercel.app\review\操作系统\错题\第一章\下列关于多道程序系统的叙述，错误的是-1.html" class="internal-link" target="_self" rel="noopener nofollow">下列关于多道程序系统的叙述，错误的是 1</a><a data-ignore-drag="true" class="kanban-plugin__item-postfix-button clickable-icon" aria-label="更多选项"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a>+ 添加卡片第二章1<a aria-label="更多选项" class="kanban-plugin__lane-settings-button clickable-icon"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a><a data-href="缺页异常" href=".\https:\\cs-note-three.vercel.app\review\操作系统\错题\第二章\缺页异常.html" class="internal-link" target="_self" rel="noopener nofollow">缺页异常</a><a data-ignore-drag="true" class="kanban-plugin__item-postfix-button clickable-icon" aria-label="更多选项"><span data-icon="lucide-more-vertical" class="kanban-plugin__icon "><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-more-vertical"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg></span></a>+ 添加卡片]]></description><link>.\https:\\cs-note-three.vercel.app\review\操作系统\错题\错题.html</link><guid isPermaLink="false">review/操作系统/错题/错题.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 11 Jun 2025 10:48:16 GMT</pubDate></item><item><title><![CDATA[计算机的性能指标]]></title><description><![CDATA[ 
 <br><br>32位计算机、64位计算机表示的就是计算机的字长为32bit和64bit，这表明计算机进行一次整数运算能够处理的二进制位数，通常与CPU的位数，ALU有关，一般字长都等于通用寄存器的位数或者ALU的宽度，字长越长，数据的表示范围越大，计算精度越高，计算机字长一般都选择8的整数倍<br><br>数据通路带宽指的是数据总线一次能并行传递的信息的位数，这里指的是CPU内部数据总线宽度（内部寄存器的大小）有可能不同<br><br>主存容量表示的是主存储器所能存储的最大容量，通常以字节Byte来衡量，也可以用字长来衡量，MAR反应存储单元个数，MDR反应存储单元字长<br><br>
<br>吞吐量：指的是系统在单位时间内处理请求的数量，它取决于信息能多块的输入内存，CPU能多块的读取指令，数据能多快的从内存中读取或写入
<br>相应时间：指的是用户向计算机发送请求开始到系统做出相应所需要的时间
<br><br>
<br>时钟周期：机器内部产生一个脉冲信号的时间t=1/f
<br>CPU主频：CPU一秒内产生多少个脉冲信号，主频为多少则将1s分为多少个时钟周期，用f表示
<br>CPI：执行一条指令所需要的时钟周期
<br>IPS：1s中能够执行多少条指令f/CPI
<br>CPU执行时间：运行一个程序所花费的时间
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\计算机的性能指标.html</link><guid isPermaLink="false">review/计算机组成原理/1.计算机系统概述/计算机的性能指标.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 11 Apr 2025 02:18:30 GMT</pubDate></item><item><title><![CDATA[计算机发展历程]]></title><description><![CDATA[ 
 <br><br>计算机发展的四个时代<br>
<br>电子管时代，逻辑单元采用电子管、使用机器语言进行编程、运算速度较低
<br>晶体管时代，逻辑单元采用晶体管、出现高级语言及其编译程序，有了操作系统的雏形
<br>中小规模集成电路时代，逻辑单元采用中小规模集成电路，高级语言发展迅速，操作系统进一步发展，有了分时操作系统
<br>大超大规模集成电路时代，逻辑单元采用超大规模集成电路，产生了微处理器，并行、流水线、高速缓存、虚拟存储器等概念都用在这代计算机中
<br><br>机器语言——汇编语言——高级语言<br>
Windows——UNIX——Linux等操作系统<br><br><br>冯诺依曼机的特点<br>
冯诺依曼机的基本工作方式是控制驱动流的方式，也就是按照指令的执行序列依次读取指令，并且根据指令的控制信息，读取数据进行相关处理<br>
<img alt="冯诺伊曼机.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\冯诺伊曼机.png"><br>
冯诺依曼机以运算器为中心，输入设备将输入的数据转换为机器能够识别的形式，存储器用来存放数据程序与指令，存储的都是二进制数据，本质上没有什么区别，指令由操作码和地址码决定<br><br>
<br>
输入设备：输入设备的主要功能就是将程序和数据以机器能够识别的信息形式输入计算机

<br>
输出设备：输出设备的主要功能是将计算机处理完成的结果使用人能够接收的形式，或者其他系统所要求的信息形式输出

<br>
存储器：存储器分为主存储器（内存）和辅助存储器（外存、硬盘），CPU能够直接访问的是主存储器，辅助存储器中的信息必须先调入主存之后才能被CPU进行访问，主存储器的工作方式就是按照存储单元的地址进行存取<br>
<img alt="存储器.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\存储器.png"><br>
取数据的流程：先将地址放入MAR，MAR根据地址取主存储体中查找对应的数据，将数据放入到MDR中，CPU再去MDR中拿取数据<br>
其中MAR的长度反应了主存储体中存储单元的个数<br>
MDR反映了主存储体中一个一个存储单元的长度

<br>
运算器：运算器是计算机执行的部件，运算器的核心部件是算数逻辑单元（ALU），运算器包括若干寄存器，累加寄存器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR），其中前三个是必备的<br>
<img alt="运算器.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\运算器.png">

<br>
控制器：控制器是计算机的指挥中心，控制器由程序计数器（PC），指令寄存器（IR），控制单元（CU）<br>
<img alt="控制器.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\控制器.png"><br>
我们把运算器和控制器称为CPU，把CPU和内存合并称为主机

<br><br>现代计算机以存储器为中心，提高运算器效率<br><br>系统软件和应用软件<br>
<br>系统软件是保证计算机系统高效运行的基础软件、通常作为系统资源提供给客户，一般主要有操作系统，数据库管理系统，分布式软件系统等
<br>应用软件是用来解决某个领域中的各类问题而编制的程序<br>
三个级别的语言
<br>
<br>机器语言，也成为二进制语言，需要记住每条指令的二进制编码，机器语言是计算机可以唯一直接识别和执行的语言
<br>汇编语言，汇编语言用英文单词或其缩写代替二进制的指令代码，更容易记忆，汇编语言还需要经过汇编程序的翻译，将其翻译为机器语言之后才能在计算机硬件系统上运行
<br>高级语言，可以方便设计人员写出问题的处理方案和解题过程的程序，高级语言一般经过编译程序编译成汇编，再由汇编转机器语言，或者由高级语言直接转机器语言程序<br>
各种翻译程序
<br>汇编程序：通过汇编器将汇编语言转换为机器语言
<br>解释程序：通过解释器将语句按照执行顺序逐条翻译为机器程序并且立即执行
<br>编译程序：通过编译器将高级语言翻译成汇编，再将汇编翻译为机器语言<br>
硬件和软件逻辑功能的等价性<br>
由于软件代码实际还是控制硬件来执行对应的指令，所以硬件和软件再逻辑功能上具有等价性
<br><br>以c语言代码编译过程为例<br>
hello.c-&gt;预处理-&gt;hello.i-&gt;编译器-&gt;hello.s-&gt;汇编器-&gt;hello.o-&gt;链接器-&gt;hello<br>
<br>预处理主要是将代码中的宏定义进行替换以及将include之后的库文件进行替换
<br>编译阶段是将预处理之后的源程序进行编译，以文本格式描述低级机器指令
<br>汇编阶段是将汇编语言翻译成机器语言
<br>链接阶段是将汇编完成之后的文件与标准库进行连接，最终生成一个可执行文件
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\计算机发展历程.html</link><guid isPermaLink="false">review/计算机组成原理/1.计算机系统概述/计算机发展历程.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 11 Apr 2025 02:04:00 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\冯诺伊曼机.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\1.计算机系统概述\img\冯诺伊曼机.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[浮点数的运算]]></title><description><![CDATA[ 
 <br>浮点数的运算一般分为以下几个步骤<br>
<br>对阶
<br>尾数加减
<br>规格化
<br>舍入
<br>判断溢出<br>
对阶原则：阶数更小的向阶数更大的对齐，因为计算机存储的是定点数，要想实现小数点前面有很多有效值的话是很难实现的<br>
舍入：在浮点数表示中，尾数的表示长度是有限的，所以需要进行尾数的舍入<br>
<img alt="Pasted image 20250415143134.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\pasted-image-20250415143134.png"><br>
判断溢出：查看在进行规格化之后阶码有没有发生溢出
<br><br>有损失的转换int——&gt;float,float——&gt;int之间的转换会存在精度丢失和溢出的情况<br><br>对于一个int型变量，例如<br>
01234567H<br>
对于高位和低位有效字节我们一般看权重，权重高的称为高位，权重低的称为低位<br>
<br>对应的我们把最左边叫做最高有效字节，最右边叫做最低有效字节
<br>大端存储对应的就是把左边【最高有效字节】存放在低地址，把最右边【最低有效字节】存放在高地址
<br>小端存储对应的就是把右边【最低有效字节】存放在低地址，把最左边【最高有效字节】存放在高地址<br>
大端存储更便于人们的阅读，小端存储便于机器阅读
<br><br>按字、半字、字节寻址，表示的是寻址过程中每次向下寻址需要找多少个bit<br><img alt="Pasted image 20250415150032.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\pasted-image-20250415150032.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\浮点数的运算.html</link><guid isPermaLink="false">review/计算机组成原理/2.数据的表示/浮点数的运算.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Tue, 15 Apr 2025 07:00:33 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\pasted-image-20250415143134.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\pasted-image-20250415143134.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[浮点数的表示]]></title><description><![CDATA[ 
 <br>浮点数解决的问题：如何在不增加数据位数的前提下增加数据的表示范围<br>在相同长度字节的数据中使用阶码和尾数表示浮点数，阶码就是对应科学计数法的指数，尾数就是对应科学计数法的基数<br><br>阶码部分反映了数值的大小，也反映了数据的表示范围，尾数部分反应数值的精度，尾数越长，表示的浮点数精度越高，尾数越短，表示的浮点数精度越低，类比十进制科学计数法，阶码对应了你需要将小数点移动几位，阶符表明了你需要将小数点向哪个方向移动<br>一般默认来说，阶码的底一般为2，但是也可以取4、8等，类比十进制取100、1000等<br>浮点数尾数的规格化：对于浮点数来说，如果尾数第一位是0，那么就会丢失精度，所以规定尾数的第一位一定不能是非0值<br>左规：当浮点数中的尾数第一位不是有效位时，需要将尾数进行左移，既小数点右移n位，对应的将阶码-n<br>
右规：当浮点数的尾数进行加减操作时如果出现双符号位的溢出的情况下，需要对尾数进行右规操作，小数点向右移动n位，对应的阶码+n<br>
所以采用双符号位，当溢出发生时，可以进行挽救，使得符号位可以正确表示结果<br>
<img alt="规格化浮点数.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\规格化浮点数.png"><br>
补码表示的尾数必须为1.0开头<br><br>移码是在补码的基础上符号位取反，并且只能表示正数，正好可以用来表示阶码<br>
移码的定义：移码=真值+偏置值，偏置值的取法一般都是2^n-1 来表示<br>
<img alt="IEEE754标准.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\ieee754标准.png"><img alt="IEEE标准表示数据范围.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\ieee标准表示数据范围.png"><br>
<img alt="Pasted image 20250414203058.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\pasted-image-20250414203058.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\浮点数的表示.html</link><guid isPermaLink="false">review/计算机组成原理/2.数据的表示/浮点数的表示.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Tue, 15 Apr 2025 12:07:40 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\规格化浮点数.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\规格化浮点数.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[计算机中数据的计算]]></title><description><![CDATA[ 
 <br><br>如果将二进制数据左移一位，如果不产生溢出，那么就可以看作为乘以2<br>
如果将二进制数据右移一位，如果不考虑因为移除而舍去的末位尾数的话，那么就可以看作为除以2<br><br>逻辑移位就是将数据看作为无符号整数进行移位操作，逻辑移位的规则为：<br>
<br>左移时，高位溢出，低位补0
<br>右移时，低位溢出，高位补0
<br><br>算数移位是将数据看作有符号整数进行移位操作，对于算数移位的操作一般都是在补码的基础上进行移位操作，算数移位的规则为：<br>
<br>左移时，高位溢出，低位补0，如果移动前后的符号位不同，那么就发生溢出
<br>右移时，低位溢出，高位补0，高位补充符号位，正数补0，负数补1，低位的1溢出影响精度
<br><br><br><br><br>补码的运算规则：<br>
<br>按照二进制加法的规则进行运算，逢二进一
<br>若做加法，则将二者的补码直接相加
<br>若做减法，则将减数转换为其负数的补码进行相加
<br>符号位与数值一块相加，加减之后的符号位也在运算中得到结果
<br>最终运算结果仅保留n+1位【设机器字长为n+1】
<br><br>只有两个符号位相同的加数相加或者符号位相异的数相减才有可能发生溢出<br><br>
<br>
采用一位符号位<br>
如果参加运算的两个数的符号位相同，但是运算结果产生的符号位与两位数不同，则说明发生溢出<br>
设A的符号位为As，B的符号位为Bs，运算结果的符号位为Ss

如果V为0，则表示未溢出，否则表示溢出

<br>
采用双符号位表示<br>
在参加运算之后采用两个符号位表示运算结果是否产生溢出<br>
采用S1表示第一位符号位，S2表示第二位符号位<br>
S1S2分别为00，表示运算结果为正数<br>
S1S2分别为01，表示运算结果正溢出<br>
S1S2分别为10，表示运算结果负溢出<br>
S1S2分别为11，表示运算结果为负数

<br>
采用一位符号位根据数值的进位情况判断溢出<br>
若符号位产生的进位Cn与数的最高位产生的进位Cn-1相同，说明未产生溢出，否则则产生溢出

如果V=0，表示未溢出，若V=1，表示溢出

<br><br><img alt="带标志位的加减法电路.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\带标志位的加减法电路.png"><br>
sub控制加减法信号，sub-0表示加法运算，sub=1表示减法运算<br>
当进行加法操作时，多路选择器开通右边，直接将加数输入进加法器进行运算<br>
当进行减法运算时，多路选择器开通左边，将减数按位取反，再将sub的数值输入进cin进行+1操作得到【-Y】的补码，然后再进行补码的加法操作<br><br><br>一位乘法的含义是每次进行移位乘法的操作时，只有一位乘数进行操作<br><br>对于原码来说，有一位是符号位，对于符号位需要单独处理，若需要计算x×y，那么符号位的结果为<br><br>很容易可知对于符号相同的数相乘一定为正数，符号不相同的数相乘一定为负数，符合异或的性质，对于剩下的部分，采用绝对值进行相乘<br>
<img alt="运算器的乘积部分n.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\运算器的乘积部分n.png"><br><br><img alt="绝对值乘法.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\绝对值乘法.png"><br>
对于绝对值乘法：将被乘数放在寄存器X中，乘数放在MQ寄存器中，ACC用来保留乘法结果的高位，MQ存储低位，在每进行一次乘法操作之后都要对ACC和MQ寄存器中的数据进行右移操作，将已经计算完成的低位直接丢弃，直到计算到符号位，符号位不参与计算<br><br>将符号位异或的结果放入计算结果的最高位，也就是定点数小数点的前一位<br>上述计算流程类似手算乘法的过程，移位操作类似手算过程中的位对齐过程<br><br>补码的乘法运算与原码不同的是，需要有一个辅助位来辅助补码的乘法以及移位运算<br>
所谓的辅助位就是将MQ寄存器的容量向后多扩展了一位，所以对应的ACC和X寄存器也扩展一位，用来表示双符号补码<br>
<img alt="补码乘法.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\补码乘法.png"><br>
由于计算可能会出现求解【-X】补的情况，所以添加了一个辅助电路求解补码<br>
X的补码到-X的补码求解可以对X的补码全部按位取反，末位加1操作得到<br><img alt="补码乘法运算.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\补码乘法运算.png">与原码计算的不同：<br>
补码的计算会将补码的符号位也加入到补码的乘法计算中，而原码不需要<br>
补码每次加什么，需要有MQ寄存器中的“最低位”与辅助位计算得到，原码则直接加<br>
补码每次进行的是算数右移，需要在前面补符号位，而原码的计算补充的是0<br>
<br><br><br><br>将被除数的符号位与除数的符号位进行异或运算得到对应结果的符号位，最后将其添加到对应商的最高位<br><br><img alt="恢复余数法.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\恢复余数法.png"><br>
在进行除法操作时，同样的还是要进行补码的操作，需要将被除数每次都减去除数，首先上1查看相减之后的结果，如果为负值，则需要将被除数/余数复原，然后再在上0，然后对ACC和MQ寄存器中的数据进行逻辑左移操作<br>
进行逻辑左移操作之后需要在MQ寄存器末位补0<br>
由于每次减法计算完成之后第一位都为0，所以可以直接逻辑左移<br>
对应机器字长为多少位，就只能求几次的商<br><br>如果商1减完之后余数a值为负数的话，就需要加上除数b，然后再左移得到2a+2b，然后再减去除数b，最终得到的下一位余数为2a-b，所以如果商1得到的值为负数的话，可以直接商0，然后再商1，不用恢复余数可以直接得到后面商1的结果<br>综上：当商1相减值为负数时，可以不回复余数，直接将余数左移，然后加上除数，如果为正值，则说明后一位商1，然后再接着运算，左移、相减，这样就不用恢复余数了<br>
如果商上1，那么就左移加除数的相反数，如果上0，则左移加除数<br>注意：如果求解完成之后最后一步商1得到的是负数的话，那么就需要进行恢复余数，得到正确的余数<br><br><br>涉及到补码的大小比较<br>
被除数和除数符号相同的情况下：做减法，如果得到的结果与除数同号，表示够减<br>
被除数和除数符号相异的情况下：做加法，如果得到的结果与除数异号，表示够减<br><br>第一步求解商的值<br>
如果被除数和除数符号相同，那么就按照原码规则上商，够的时候上1，不够的时候上0<br>
如果被除数和除数符号相反，那么就按照反码规则上商，够的时候上0，不够的时候上1<br><br>由上述表格我们可以得出，可以根据余数和除数的符号是否相同来判断上1还是上0<br>
除数和余数符号同号上1，异号上0<br>
如果商上0，那么余数左移加除数的补码，如果商上1，余数左移加除数的相反数的补码，如果计算到最后一步，则将最后一位恒置1<br>
<img alt="补码除法.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\补码除法.png"><br>
如果数据位有n个，那么就需要进行n次运算，最后一位恒置为1，不论最后的余数是否为负数]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\计算机中数据的计算.html</link><guid isPermaLink="false">review/计算机组成原理/2.数据的表示/计算机中数据的计算.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Mon, 14 Apr 2025 09:10:11 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\带标志位的加减法电路.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\带标志位的加减法电路.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[运算方法和运算电路]]></title><description><![CDATA[ 
 <br>在计算机中各种运算都是由逻辑电路们来表示的<br><br>对于加法来说，如果有奇数个1，那么这一位的运算结果就是1，如果是偶数个1，那么运算结果为0<br>
所以加法一般是对被加数、加数、后一位产生的进位进行异或运算<br>
通过上述异或运算可以得到对应位置上的运算结果<br>
当前位置的运算结果可以表示为<br><br><br>进位产生的条件：<br>
<br>当前位置的加数和被加数全为1
<br>加数或被加数至少有一个1，并且后面一位产生了进位


<br><br>将对应的每个位置的加法器进行串联就可以得到对应的加法器<br>
对于上述加法器来说进位的产生是串行的，所以也将其称为串行进位加法器<br>
<img alt="串行进位加法器.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\串行进位加法器.png"><br>
串行进位加法器的缺点<br>
<br>低位的运算可以影响到高位的运算
<br>高位的运算需要低位的进位操作，进位信号时串行产生的，所以运行速度慢
<br><br>由于进位信息如上所示，由上述进位递推式可以知道，对于一个给定的输入数据队列，可以直接求解出第一位到最高位的进位信息<br>
所以并行进位加法器会将进位信息先计算好，然后直接将进位信息直接在计算的过程中输入，不用再等待前一位的进位信息<br><br><img alt="带标志位的加法器.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\带标志位的加法器.png"><br>
OF：overflowflag——用来判断有符号加减运算是否出现溢出的情况，0表示未溢出，1表示溢出<br>
CF：carryflag——用来判断无符号加减运算是否发生溢出，0表示未溢出，1表示溢出<br>
SF：signflag——用来表示运算完成之后的结果是正数还是负数，0表示正数，1表示负数<br>
ZF：zeroflag——用来表示运算结果是否为0，1表示结果为0，0表示结果不为0<br><br>OF<br><br>CF<br><br>其中cin表示是进行加法运算还是进行减法运算，为0时，加法进位Cout为1表示溢出，为1时，减法运算Cout为0表示溢出<br>
SF<br><br>ZF<br><br><br>ALU中的各端分别表示的含义<br>
A、B：表示两个n位操作数的输入端<br>
Cin：表示进位输入端<br>
Cout：表示进位输出端<br>
ZF、OF、SF、CF：标志位，分别表示是否为0或者是否溢出以及是否表示正负<br>
F：表示输出<br>
ALUop：ALU的控制端，表示ALU此时需要进行的运算【其中ALUop的位数决定了ALU的运算种类】<br><img alt="ALU.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\alu.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\运算方法和运算电路.html</link><guid isPermaLink="false">review/计算机组成原理/2.数据的表示/运算方法和运算电路.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Mon, 14 Apr 2025 03:14:36 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\串行进位加法器.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\img\串行进位加法器.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[数制与编码]]></title><description><![CDATA[ 
 <br><br>采用二进制编码的原因，二进制编码只有两个状态，可以使用高电平和低电平来表示<br>
二进制编码的运算都很简单，可以使用逻辑电路来表示<br><br>一般用当前位置的数码本身* 对应位置上的位权再加和就可以得到对应的十进制数<br><br>整数部分表示：除基取余法<br>
小数部分表示：乘基取整法<br><br>整数表示，小数点固定在最后一位数值的后面<br>
小数表示，小数点固定在符号位后面<br><br>数据的原码表示，最高位使用符号位表示正负，其余位置表示数的绝对值<br>
对于0，原码有两种表示方式00000000和10000000<br>
所以原码的表示范围为-(2^n-1)~(2^n-1)<br>反码表示<br>
对于正数来说，正数的原码=反码<br>
对于负数来说，负数的反码除了符号位之外全部按位取反<br>补码表示<br>
对于正数来说，正数的补码=原码<br>
对于负数来说，负数的补码=反码+1<br>移码表示<br>
移码对应的就是在补码的基础上对符号位取反<br><br>在C语言中整形的表示有很多种，short /short int 表示短整型16bit，int整形32bit，long/long int在32位机器中占32bit，在64位机器中占64bit，如果在前面加上ubsigned则表示无符号整形，不加则默认表示有符号的整形<br>
数据存放在计算机中都是用补码表示的<br><br>对于相互转换来说，其本质表示的二进制数据是不变的，本质就是解释这段二进制代码的方式发生了变化<br><br>对于短字节的转换为长字节的数据，一般都在前面使用符号位进行填充，既正数补0，负数补1<br>
如果是长字节转换为短字节，对应的高位直接溢出]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\2.数据的表示\数制与编码.html</link><guid isPermaLink="false">review/计算机组成原理/2.数据的表示/数制与编码.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 11 Apr 2025 03:04:19 GMT</pubDate></item><item><title><![CDATA[页式存储器和虚拟存储器]]></title><description><![CDATA[ 
 <br>将一个进程 (程序)在逻辑上分为若干个大小相等的页面,"页面"大小与主存块的大小相同, 每个页面可以离散的放入不同的主存块中<br>
<img alt="Pasted image 20250419162103.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419162103.png"><br>
逻辑地址: 虚地址 (程序员视角看到的地址)<br>
程序员视角看到的地址是相对而言的, 从程序开始的位置为 0, 一直编址到程序结束的位置<br>
例如 4KB 的程序对于程序员而言, 地址范围就是 000000000000~111111111111<br>
但是将 1KB 分为一页, 将该程序分为 4 页, 其中高两位表示页地址, 后面的 bit 表示页内地址<br>物理地址: 实地址 (实际在主存中的地址)<br>
逻辑地址与物理地址之间的转换:<br>
只需要将逻辑地址中的页地址转换为内存块中的页块的实际地址就行, 此时实际地址根据实际的块地址去访问对应的块, 然后再根据块内地址去访问对应的数据
<br>
为了方便进行逻辑页号到实际主存块号之间的转化, 操作系统会维护一张逻辑页号到实际块号的映射表,CPU 执行的机器指令中, 使用的是逻辑地址, 因此通常需要将页表逻辑地址转换为物理地址, 通过查询页表可以知道每个逻辑页面存放在对应的哪个主存块中
<br>
问题: 如何快速访问对应的映射表<br>
操作系统维护的映射表存放的位置是在主存中的, 所以在执行机器指令时对应的 CPU 需要进行一次访存操作, 为了便于 CPU 查找到对应映射表在主存中的位置, 还有一个页表基地址寄存器, 这个寄存器中存放了映射表的基地址, CPU 可以直接读取对应地址上的数据来查看映射表
<br>
问题:对于访问主存的速度太慢了该如何解决<br>
引入快表, 快表由 SRAM 构成, 通过内容访问对应的内容, 它只能保存页表的某一部分的信息
<br>快表与 Cache 的区别:快表中存储的是页表项的副本,Cache 存储的是主存块的副本<br>
<img alt="Pasted image 20250419163312.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419163312.png"><br><br><br>类似内存和 Cache 一样, 将辅存中的部分需要的数据调入主存中, 所以对于一定的主存存储空间, 你感受到的能运行的程序数量要比实际设计的要多<br>
类比: 主存与辅存之间的管理与主存和 Cache 中的管理是相通的, 对应 Cache 的替换算法以及 Cache 对应的标记为基本都是类似的, 只不过对应的是不同的存储层次而已<br>
主存和辅存之间的数据交换是由操作系统完成的，主存和 Cache 中的数据交换是由硬件完成的
<br><img alt="Pasted image 20250419165126.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419165126.png"><br>
<br>有效位: 这个页面是否被调入主存
<br>脏位: 这个页面是否被修改过
<br>引用位：用于页面置换算法，用来标记当前页面被访问过多少次
<br>物理页：既主存块号
<br>磁盘地址: 这个页面在主存中的存放位置
<br><br>将一个程序按照功能模块拆分位不同的段，操作系统会以段位单位，决定将哪些段优先调入主存<br>
由于每个功能模块的代码长度可能不一样，所以分段完成之后出现的问题就是每个段长度不一样，所以在维护段表的过程中需要增加一个段长字段<br>
<img alt="Pasted image 20250419170107.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419170107.png"><br><br>将一个应用程序先分段，段内再分页，所以寻址时需要段地址、段内页地址、页内地址]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\页式存储器和虚拟存储器.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/页式存储器和虚拟存储器.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:31:46 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419162103.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419162103.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Cache基本原理]]></title><description><![CDATA[ 
 <br><br><img alt="Pasted image 20250419094317.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419094317.png"> 为了解决 CPU 速度过快，内存速度供不上 CPU 读写速率，就使用 Cache 作为中间介质，将内存中的数据先写入 Cache，然后 CPU 从 Cache 中读取数据<br>局部性原理<br>
<br>空间局部性：<br>
在最近未来要使用的信息，很可能是与现在正在使用的数据是空间上相邻的
<br>时间局部性：<br>
在最近未来要使用的信息，可能现在正在使用的信息
<br>根据上述局部性原理，可以把 CPU 目前访问的地址的周围的部分数据写入 Cache 中<br>
那么如何界定周围这个范围？<br>
在与 Cache 的交互中，主存是以块为单位进行数据交换的，例如 1 KB 为一块，主存与 Cache 之间以块为单位进行交换
<br>在进行分块之后，可以将主存的地址分为块号和块地址等<br>性能分析<br>
<br>如果采用的方案是先去 Cache 中进行访问，如果未命中，然后再去主存中进行访问<br>
此时设 Cache 的命中率为 H，Cache 的访问时间为 t1，主存的访问时间为 t 2<br>
那么中的平均存取访问时间为


<br>如果采用的是同时取 Cache 和主存中访问，当在 Cache 中访问到对应的数据之后就中主存访问，设 Cache 的命中率为 H，Cache 的访问时间为 t 1，主存的访问时间为 t 2<br>
那么平均存取时间为


<br><br><br><img alt="Pasted image 20250419103131.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419103131.png"><br>
进行全相联映射时，主存中的数据映射到对应 Cache 中的位置是随机映射的，会有一张主存 Cache 映射表，其中记录了当前 Cache 块中对应主存的地址以及当前条目是否有效<br><br><br>直接映射：Cache 中位置 = 主存块号%Cache 总数<br>
但是如果有多个主存块经过 Hash 之后映射到同一个 Cache 块中，此时就会出现问题，第二个主存块中的数据就没法写入 Cache 中<br>
优化：对于 Cache 中的标记位，如果 Cache 的总块数为 2^n 个，主存末位 n 为直接反应了对应在 Cache 中的块号，所以主存的末位 n 位可以不用存储在标记位，可以直接由 Cache 块号来进行反应
<br><br>注意其中的标记以及 Cache 块号类似与全相联映射中的标记，不过此时的标记的后几位使用 Cache 块号进行表示，所以不用额外存储<br>访存步骤<br>
<br>CPU 得到数据对应的地址
<br>根据地址的低位查找 Cache 中的块号
<br>查看标记为是否跟地址的高位相同
<br>查看有效位，如果为 1，则直接在 Cache 中进行访问
<br>如果有效位为 0，则需要访问主存
<br><br>结合直接映射和全相联映射，在进行组的挑选时，使用直接映射，确定组内地址时，使用全相联映射<br>
将 Cache 分为若干组，主存中的信息映射到对应组中，然后再随便存储到组内的 Cache 块中<br>
组相联映射：组地址 = 贮存块号%分组数<br>
注意这里的主存块号的定义：在主存中每一块的大小和 Cache 块的大小是相等的，所以存在块内地址表示在块中的位置，所以前面的部分才是用来表示块号的<br>
与直接映射相同的优化，在记录标记时，主存块地址的最后几位反应了在 Cache 中的地址，所以标记为不用记录块地址，直接记录前面几位来表示标记，结合 Cache 组号进行访存<br>
<img alt="Pasted image 20250419105715.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419105715.png">
<br>可以将主存块中的地址进行如下解析<br><br>访存步骤：<br>
<br>CPU 得到对应的主存地址
<br>根据主存地址的低位确定在 Cache 中的哪个组中
<br>结合地址的高位和标记位查看访问的内容是否在 Cache 中
<br>如果有，并且对应的 Cache 有效位为 1，则直接在 Cache 中访问
<br>否则就要取主存中进行访问

K 路组相联，意思每个组中有 K 个块


<br><br>全相联映射方式——因为主存会将主存块存放在 Cache 的任意位置，只有在 Cache 全部被填满之后才会出现对应的替换<br>直接映射方式——因为直接映射方式时通过 Hash 之类的计算得到对应的 Cache 块号，对应位置如果非空则直接替换【直接映射方式不需要考虑替换算法，计算完之后只要不为空则直接替换，否则等待】<br>组相联映射方式——只有内存块所属的 Cache 分组被装满之后才需选择替换哪块<br><br>如果 Cache 已满，则随机选取一块 Cache 进行替换覆盖<br>因为没有考虑到局部性，所以这种算法非常不稳定，在进行随机替换可能会造成 Cache 命中率非常低<br><br>如果 Cache 已满，则会优先把最先调入 Cache 块被替换<br>算法实现也很简单<br>
将 Cache 块分为 0、1、2、3 编号，按照 0、1、2、3 的顺序进行 Cache 的写入，如需进行替换，也可以按照 0、1、2、3 的顺序进行替换<br>
<img alt="Pasted image 20250419141227.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419141227.png"><br>
同样，因为没有考虑到局部性原理，先被调用进 Cache 的块有可能是被频繁访问的，所以 Cache 的命中率也可能会很低<br><br>为每一个 Cache 块设计一个计数器，用来记录每个 Cache 块有多久没有被访问了<br>
<img alt="Pasted image 20250419142731.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419142731.png"><br>
注意：当 Cache 命中时，需要将命中的 Cache 块的计数器置为 0，然后再将小于当前 Cache 块的计数器的数值+1，高于当前 Cache 计数器的不用增加<br>

<br>通过上述算法可以确定对于 2^n 个 Cache 块，每个 Cache 块的未被访问时间最大只能是 2^n，所以可以只需要 n 个 bit 用来表示<br>基于局部性原理, 近期被访问过的 Cache 块在不久的将来也可能会被访问, 因此淘汰最近最久未使用的算法是合理的, 但是如果频繁访问的主存块的数量要大于 Cache 块的数量的话, 可能会发生抖动的现象 <br><br>为每个 Cache 块设计一个计数器, 用于记录每个 Cache 块被访问过几次. 当 Cache 块存放满了之后, 替换掉计数器最小的 Cache 块<br>如果有多个行的计数器一样的话, 根据行号递增的次序来进行排序, 优先将行号小的 Cache 块进行替换<br>
缺点: 当一部分 Cache 块被频繁访问时, 此时这部分 Cache 块的计数器的值会非常大, 此时就会造成这部分 Cache 块在很长一段时间内不会被淘汰, 所以实际运行效果不如LRU
<br><br>如果 CPU 修改了 Cache 中数据的副本, 如何确保 Cache 中数据和主存母本的数据一致<br><br>CPU 需要对主存中对应地址中写数据, 并且当前地址中映射到 Cache 中<br><br>CPU 对 Cache 写命中时, 只是修改 Cache 中的内容, 而不立即写入主存, 只有当此块 Cache 被换出时, 才将此部分 Cache 写入主存, 所以还需要有一个标记为来表示当前 Cache 块是否被新写入数据, 也就是脏位标记<br>
通过写回法减少了访存次数, 但是存在数据不一致的隐患<br><br>当 CPU 对 Cache 写命中时, 必须同时把数据写入 Cache 和主存, 一般使用写缓冲 (由 SRAM 组成)<br>
使用写缓冲, 当 CPU 进行写数据时, 回先将数据写入 Cache 块和对应的写缓冲中, 对应的写缓冲由一个 FIFO 队列维护, CPU 可以向队列中写入多个数据, 当 CPU 在进行其他操作时, 写缓冲就会将数据写入到对应的主存中
<br>通过全写法, 增加了访存次数, 速度变慢, 但是能够保存数据的一致性<br>
在加入写缓冲之后,CPU 的写速度很快, 若写操作不频繁, 则效果很好, 但是写操作如果很频繁的话, 就会导致写缓冲饱和, 从而发生阻塞<br><br>CPU 要写的数据地址块没有在 Cache 中<br><br>当 Cache 没有命中对应的数据块时, 就会采用 Cache 替换算法, 把主存中的数据调入 Cache 中, 通常搭配写回法进行使用<br><br>当 Cache 没有命中时,CPU 会直接将数据写入主存, 而不会将主存中的数据块调入 Cache, 通常搭配全写法进行使用<br>
<img alt="Pasted image 20250419150638.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419150638.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\cache基本原理.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/Cache基本原理.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:26:57 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419094317.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250419094317.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[磁盘存储器与固态硬盘SSD]]></title><description><![CDATA[ 
 <br>磁盘存储器是指把某些磁材料均匀的涂在铝或者塑料表面作为磁载体来存储信息，磁头每次读取只能读取 1bit<br>
磁表面存储器的优点：<br>
<br>存储容量大，位价格低
<br>记录介质可以重复使用
<br>记录信息可以长期保存不丢失，甚至可以脱机存档
<br>非破坏性读出，读出时不需要再生<br>
磁表面存储器的缺点
<br>读取速度慢
<br>机械结构复杂
<br>对工作环境要求高<br>
<img alt="Pasted image 20250418130219.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418130219.png">
<br><br><img alt="Pasted image 20250418130847.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418130847.png"><br>
重点：对于一个磁盘来说，每一条磁道上存储的信息都是相同的，并不是磁道越长存储的信息越多，因此，每一条磁道上的位密度不一样
<br>

<br>]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\磁盘存储器与固态硬盘ssd.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/磁盘存储器与固态硬盘SSD.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 18 Apr 2025 05:55:12 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418130219.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418130219.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[主存储器与CPU的连接]]></title><description><![CDATA[ 
 <br>
MAR 和 MDR 是存储器的一部分，但是在现代计算机中是 CPU 中的两个寄存器，分别通过数据总线和地址总线和 RAM 相连接
<br><br><img alt="Pasted image 20250418105610.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418105610.png"><br><br><br>
存储器存储的内容的多少一般表示为 M X Nbit<br>
其中的 M 就表示有个存储单元 N 表示每个存储单元有多少为二进制数据<br>
<img alt="Pasted image 20250418111040.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418111040.png">
<br>字扩展扩展的就是存储单元的个数，用来扩充从主存储器中存储字的数量，也就是扩展 M 的大小，此时需要更改的将就是 MAR 中的 bit 数，最高为用来控制选中拿一块 DRAM 芯片<br>例如将两片 1 K X 8 bit 的新的 DRAM 芯片放在一块进行字扩展，此时需要扩展数据线的条数，此时需要 11 根数据线来表示所有的存储单元<br>一般使用最高有效位来控制 SRAM 芯片的选取<br>
<br>A 10 等于 0 的时候范围是：A 10 A 9 A 8 A 7 A 6 A 5 A 4 A 3 A 2 A 1 A 0=00000000000-01111111111 B=0-1023
<br>第一个芯片会工作，当 A 0 到 A 9 都为 1 时再增加 A 10 就会变为 1 此时根据图可以看出 CS 0 非=1 是高电平，A 10 在经过一个非门使 CS 1 非接收到 0，此时第二个芯片工作，从 10000000000=1024 开始。
<br>A 10 等于 1 的时候范围是：A 10 A 9 A 8 A 7 A 6 A 5 A 4 A 3 A 2 A 1 A 0=10000000000-11111111111 B=1024-2047
<br><br><img alt="Pasted image 20250418110056.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418110056.png"><br>位扩展就是扩展一个存储单元中能存放的字节数，也就是扩展 N 的大小<br>例如使用两块 1 K X 4 bit 的存储芯片进行为扩展，此时数据线需要将低四位和高四位分开连接，此时需要更改的就是 MDR 中的 bit 数<br>由上例可知：我们进行位扩展之后此时的低 4 位数据来自第 2 片 DRAM，高 4 位来自第 1 片 DRAM，【这里来自于哪片 DRAM 芯片需要根据实际的连线来判断】<br>位扩展扩展的是每个存储单元存储一部分，所以 8 bit 长度的数据分别存放在不同 DRAM 芯片的同一个地址，所以此时 MAR 不需要进行拓宽，也就不需要片选信号<br><br>结合上述字扩展和位扩展，先进行位扩展，将扩展完成的存储单元阵列看作是一个整体再进行字扩展，将二者结合就完成了字位扩展<br>
扩展 MAR 的地址数，高几位用来表示字扩展之后的 DRAM 芯片阵列编号，MDR 扩展用来选中根据存储单元阵列中的各位数据，从低位到高位分别进行读取]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\主存储器与cpu的连接.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/主存储器与CPU的连接.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 18 Apr 2025 03:10:41 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418105610.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418105610.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[多体并行存储器]]></title><description><![CDATA[ 
 <br>对于 CPU 来说，读取数据的速度非常快，此时主存可能还在进行刷新操作，这样 CPU 就无法从主存中进行数据的读取，所以我们可以增加内存条的个数来缓解这种情况<br>由于增加了内存条的个数，所以需要使用几个字节来表示分别取哪一个存储体中对应地址上取数据<br><img alt="Pasted image 20250418100940.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418100940.png"><br>
当采用高位交叉编址时，此时连续的地址存储在同一个存储体中，此时进行连续读取的话，每一次读取需要等待上一次刷新，时间开销很大
<br>
采用低位交叉编制时，连续的空间存放在不同的存储体中，进行连续读取访问，此时读取下一个连续空间的地址不需要等待刷新，节省了时间开销
<br>进行数据的读取时，只能每次读取一行，即使会有无效的数据读入<br>采用流水线形式，微观上串行，宏观上并行，在宏观上，一个存储周期内，m 个存储体所能提供的数据量为单个模块的 m 倍<br>存取周期为 T，存取时间【总线传输时间】为 r，为了使流水线不间断，则应该保证有多少个模块<br>
为了保证流水线不间断，则必须保证模块数 m&gt;=T/r，最好情况是 m=T/r，当 m&gt;T/r 时，此时会有存储体存在空闲的状态
<br>对于多体并行存储器来说，每一个存储体都有自己的读写控制线，地址寄存器和数据寄存器，他们技能并行工作，也能交叉工作<br><br><img alt="Pasted image 20250418103305.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418103305.png"><br>
<br>单体多字存储器可以看作是位扩展，但是此时只有一套控制电路，每次读取只能读取一整行的数据
<br>当程序、变量等存储在一行上，此时读取效率更高，但是如果存储的数据不在同一行时，这时候读取数据就会存在读取很多废数据的情况
<br>按照上述单体多字存储器的设计，每一次在一个存储周期内读取数据都能读取很多个字，平均下来每读取一个字的时间就很小，速度跟多体并行存储器一样
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\多体并行存储器.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/多体并行存储器.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 19 Apr 2025 10:17:24 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418100940.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250418100940.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[双端口RAM]]></title><description><![CDATA[ 
 <br><br>双端口 RAM 是一种允许两个独立设备同时访问的存储器，其核心特点是具备两套独立的地址线、数据线和控制线，可支持并行读写操作<br>
<br>基本结构
<br>双端口 RAM 的存储单元与普通 RAM 类似（如 SRAM 或 DRAM），但增加了两套访问接口：<br>
<br>Port A：独立的数据线（D_A）、地址线（A_A）、控制线（CE_A, OE_A, WE_A）。
<br>Port B：独立的数据线（D_B）、地址线（A_B）、控制线（CE_B, OE_B, WE_B）。
<br>共享存储阵列：所有存储单元可被任意端口访问。
<br>         Port A                           Port B
   ┌──────────────────┐             ┌──────────────────┐
   │   Data (D_A)     │             │   Data (D_B)     │
   │   Address (A_A)  │             │   Address (A_B)  │
   │   Control        │             │   Control        │
   │  (CE_A/OE_A/WE_A)│             │  (CE_B/OE_B/WE_B)│
   └────────┬─────────┘             └────────┬─────────┘
            │                                │
            ▼                                ▼
   ┌──────────────────────────────────────────────────┐
   │               Shared Memory Array                │
   │ (所有存储单元可被Port A或Port B访问)                 │
   └──────────────────────────────────────────────────┘
<br>
<br>工作模式
<br>双端口 RAM 根据访问冲突情况分为以下三种工作模式：<br>
(1) 无冲突读写（Independent Access）<br>
<br>场景：Port A 和 Port B 访问不同的存储地址。
<br>行为：两端口完全独立操作，互不影响。<br>
示例：
<br>
<br>Port A 写入地址 0 x 100，同时 Port B 读取地址 0 x 200。
<br>两者并行执行，无延迟。
<br>(2) 读-读冲突（Read-Read Conflict）<br>
<br>
场景：两端口同时读取同一地址。

<br>
行为：数据可被同时读出，无冲突。

<br>
示例：

<br>Port A 和 Port B 同时读取地址 0 x 100。
<br>两端口均获取相同数据。


<br>(3) 写-写或读-写冲突（Write-Write / Read-Write Conflict）<br>
<br>场景：两端口尝试同时写入同一地址，或一个写一个读同一地址。
<br>行为：需通过仲裁机制解决冲突，常见策略：

<br>优先级仲裁：预先设定 Port A 或 Port B 优先级。
<br>时序控制：延迟低优先级端口的操作。
<br>硬件信号：通过 BUSY 标志位阻塞冲突端口。	


]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\双端口ram.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/双端口RAM.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 18 Apr 2025 01:53:53 GMT</pubDate></item><item><title><![CDATA[ROM]]></title><description><![CDATA[ 
 <br><br>厂家可以按照顾客需求，在芯片生产过程中直接写入信息，之后任何人不可重写（只能读出）<br>
可靠性高，灵活性差，生产周期长，只适合批量定制<br><br>解决 MROM 生产成本高，生产周期长的短板<br>
可以使用专门的 PROM 写入器写入信息，写入一次之后就不能再更改<br><br>允许用户写入信息，之后用某种方法擦除数据，可进行多次重写<br>
UVEPROM——用紫外线照射 8~20 分钟，擦除所有信息<br>
EEPROM——电擦除方式：可以使用电擦除方式擦除特定的字
<br><br>U 盘、SD 卡<br>
在 EEPROM 基础上发展而来，断电后也能保存信息，并且可以进行多次快速擦除重写<br>
注意：由于闪存需要先擦除再写入，因此闪存的写的速度要比读的速度更慢
<br><br>有控制单元+存储单元构成，与闪存的核心区别是控制单元不一样，但是存储介质都类似，可以进行多次的快速擦除重写。SSD 速度快，功耗低，价格高<br><img alt="{76A999A3-BD8F-4CB7-A7B7-998594F766E4}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{76a999a3-bd8f-4cb7-a7b7-998594f766e4}.png"><br><br>对于计算机来说，关机之后 RAM 中的数据全部丢失，计算机需要根据指令去辅存中读取对应的数据，将其加载进 RAM 中才能保证系统的稳定运行<br>
<img alt="{8A173BCE-789E-44B6-A6B7-29E735A33350}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{8a173bce-789e-44b6-a6b7-29e735a33350}.png"><br>
一般来说把主板 BIOS 中的 ROM 芯片与 RAM 一并称为主存，与主存一块编址，将 ROM 编在低地址，用作系统引导
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\rom.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/ROM.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 19 Apr 2025 09:30:18 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{76a999a3-bd8f-4cb7-a7b7-998594f766e4}.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{76a999a3-bd8f-4cb7-a7b7-998594f766e4}.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SRAM 与 DRAM]]></title><description><![CDATA[ 
 <br><br>
<br>主存由 DRAM 实现，Cache 由 SRAM 实现
<br>SRAM【随即静态存储器】的存储单元是双稳态触发器，非破坏性读出，存取速度快，但是集成度低功耗大
<br>DRAM 的存储单元是栅极电容的采用的是地址复用技术地址线为原来的一半
<br>SRAM 和 DRAM 都是断电易失性存储器<br>
对比<br>
<img alt="Pasted image 20250417093044.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250417093044.png">
<br><br>DRAM 为什么需要刷新?<br>
由于 DRAM 结构的特殊性，电容中的电荷会随时间流出，所以在一定的时间间隔内需要对存储单元中的电荷进行补充
<br>
<br>DRAM 的刷新时间为 2 ms，以行为单位需要行地址, 每次刷新一行存储单元
<br>刷新方式分为三种：<br>
- 分散刷新：每一次读写完之后就刷新这行。优点：没有死区；缺点：增加了系统的存取周期<br>
- 集中刷新：在 2ms 内集中安排刷新。优点：读写不受刷新影响，缺点：有死区<br>
- 异步刷新：将每一行的刷新分散到不同的时间段，只需保证在 2 ms 内刷新一次即可，既可以缩短死区，又可以充分利用刷新时间<br>
<img alt="{ED191F7E-B147-49F9-BB39-492B9C16B558}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{ed191f7e-b147-49f9-bb39-492b9c16b558}.png">

DRAM 刷新死区（Refresh Dead Time） 是指在进行刷新操作时，DRAM 无法响应正常读写请求的时间段。在这段时间内，内存控制器必须暂停所有其他访问操作，导致系统内存带宽暂时性损失，表现为延迟增加或吞吐量下降。


<br>每次刷新需要刷新多少个存储单元呢？<br>
 每次刷新的存储单元一般要以行为单位，每隔 2 ms 刷新一行存储单元<br>
对于刷新来说，通过行地址译码器找到对应要刷新的行，通过硬件支持，读取一行的数据，然后对其重新写入，占用一个读写周期
<br><br>
对于译码器连接的存储单元线的根数过多的情况，对于 n 位的 MAR，需要处理 2^n 根线，此时需要将一维的存储单元转换为二维的存储单元，分行和列进行地址的传输，此时能够节省译码器连接到存储单元的线的根数，经过这种转换，译码器只需要处理 n/2 根线
<br>对于 DRAM 芯片来说，默认使用地址复用技术<br><img alt="{82229E87-C9B1-407E-AC86-1E9468B226E2}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{82229e87-c9b1-407e-ac86-1e9468b226e2}.png"><br>那么，如何根据 MAR 中的地址找到对应位置的存储单元呢？<br>
一般会将 MAR 中的地址分为前后两个部分，前半部分拆分为行地址，传入行地址译码器，先找到对应的行位置，后半部分对应的是列地址，传入列地址译码器，只有对应存储单元的行地址译码器和列地址译码器对应的选通信号都是选通的情况下才能找到对应行中的位置【行列地址复用】
<br>行列地址复用：假设你的存储器容量是 16 bit，那么可以将这 16 个比特组织成一个 4 * 4 的矩阵，为了找到某个你想要找的 bit，比如第 1 行第 2 列的那个 bit。你先发送二进制的 01，表示要找的数据在第 1 行；接着发送二进制的 10，表示要找的数据在第 2 列。这样一来你就找到了第 1 行第 2 列的那个 bit。可以发现只要两根地址线就能寻找 16 个 bit 了，但是要发送两次地址（一次行地址，一次列地址）<br>行列独立：同样的 16 bit 存储器，这 16 个 bit 不是组织成一个矩阵，而是一个数组，标号 0~15，所以需要四根地址线来寻找，譬如要找第 12 个 bit，你发送地址线信号 1100 就能找到。可以发现行列独立的地址线数量比行列地址复用要多，但是地址数据只要一次就能传输完成。<br>DRAM 一般使用行列地址复用技术，而 SRAM 一般使用行列独立技术。<br><br>DRAM 普遍采用的是行与列地址分时复用技术进行寻址。在 DRAM 的矩阵存储单元中，地址可以分成行地址和列地址。在寻址时，必须先进行行寻址然后在进行列寻址，这是由 DRAM 的硬件电路所决定的。所以，对行地址线和列地址线进行共用，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可。既节省了地址线，也不会降低 DRAM 原有的工作速率（因为 DRAM 的行地址和列地址就是要分时传送的）。<br>
【重点就是将行地址和列地址使用同一根地址线进行传输】<br>如果是 SRAM 采用这种寻址方式的话，则会大大降低其工作速度。Cache 多为 SRAM，存储单元是线性排列，不像 DRAM 那样分行列，所以不适用行列地址线复用方式。不过说到底是因为 Cache 就是为了快才存在的，容量又小，所以 SRAM 也用得起。]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\dram和sram.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/DRAM和SRAM.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 19 Apr 2025 10:26:19 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250417093044.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\pasted-image-20250417093044.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[主存储器的基本组成]]></title><description><![CDATA[ 
 <br><br><img alt="{8EA762B3-FA59-456C-80F2-5EF556647F6C}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{8ea762b3-fa59-456c-80f2-5ef556647f6c}.png"><br>
存储元件将二进制信息存储在存储模块的电容中<br>
在查看二进制信息时，一般在 MOS 管上加一个 5 V 电压，此时 MOS 管下面的电路接通，电容中的电荷流出，这时候可以查看电路是高电平还是低电平来查看表示的是 0 还是 1
<br>由上述一系列存储元构成的叫做存储单元，由存储单元构成的叫做存储体和存储矩阵<br><br><img alt="{121C8774-2EF7-4ED4-9972-A2CAEBA03A4E}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{121c8774-2ef7-4ed4-9972-a2caeba03a4e}.png"><br>
由译码器接收地址总线上的地址，然后转换为 2^n 个存储单元上的一条数据线，然后 CPU 通过数据总线去接收对应位置上的数据<br>根据上述图片我们可以知道，根据 n 位地址我们可以知道由 2^n 个存储单元，每个存储单元存储的字长根据 MAR 知道，可以计算出存储器的总容量<br><br>控制线路<br>
<br>对于一个存储体来说，需要有一个控制线路来控制对存储体的操作
<br>在进行数据的存取操作之前需要控制器确定译码器稳定才能对译码器进行操作，否则就不能对其进行操作
<br>读写控制：有的控制器会使用两根线来控制对存储体的读写操作，当读控制线处在低电平时就是读操作，此时会将 MDR 位置对应的数据存放在 MAR 中，写控制线在低电平时表示的是写操作，会将 MAR 中的数据写入对应 MDR 地址对应的位置
<br>有的会将读写控制线路改为一根线控制读写，当这跟线路处在高电平时，表示读操作，当处在低电平时，表示写操作<br>
对于上述不同的读写控制对应对外暴露的引脚个数是不一样的
<br><img alt="{D9B068B8-E072-4D9E-8DA6-45021A4F7A4E}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{d9b068b8-e072-4d9e-8da6-45021a4f7a4e}.png"><br>
片选线：用来选取内存条中不同位置上的内存块中的信息<br><br>DRAM——动态RAM<br>
SRAM——静态 RAM<br>存储元的不同表示形式<br>
<img alt="{F7A357F9-44ED-4B19-A660-1C9FC800AD3C}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{f7a357f9-44ed-4b19-a660-1c9fc800ad3c}.png"><br>
在对于栅极电容的读取数据的过程中，当电容中存在电荷，既表示的二进制数据为 1 时，读取完之后电荷全部流走【破坏性读出】，此时需要进行重写，也成为再生<br>
双稳态触发器读出数据之后，触发器状态保持稳定，是非破坏性读出，无需重写<br>
所以双稳态触发器的读写速度要高于栅极电容，但是制造栅极电容的成本要低于双稳态触发器，栅极电容体积小，便于集成]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\主存储器的基本组成.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/主存储器的基本组成.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 19 Apr 2025 08:02:51 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{8ea762b3-fa59-456c-80f2-5ef556647f6c}.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{8ea762b3-fa59-456c-80f2-5ef556647f6c}.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[存储系统的概念]]></title><description><![CDATA[ 
 <br>主机由 CPU 和主存构成，这里的主存就是对应内存，硬盘之类的就对应之前将的外设<br><img alt="{17DB14BB-96AF-490F-9DB7-2993F2D30BBA}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{17db14bb-96af-490f-9db7-2993f2d30bba}.png"><br>
数据从辅存到主存的过程是由操作系统负责完成的
<br>主存到辅存的转换解决了计算机主存容量不够的问题<br>
cache 到主存解决了主存和 CPU 速度不匹配的问题<br>高速缓存和主存可以被 CPU 直接读写，而辅存、外存等只有先转入主存中才能被 CPU 读写<br><br>
<br>半导体存储器<br>
主存、Cache 都是以半导体器件存储数据的
<br>磁表面存储器<br>
以磁性材料存储数据的、磁带、磁盘、机械硬盘等
<br>以光介质存储信息<br>
光盘等
<br><br>
<br>随机存取存储器RAM<br>
读写任何一个位置的数据所需要的时间都相同，与存储单元所在的物理位置无关【内存条】
<br>顺序存取存储器 SAM<br>
读写一个存储单元所需的时间与存储单元所在的物理位置有关
<br>直接存储器 DAM<br>
既有随机存取的特性，也有顺序存取的特性，先直接选取信息所在区域，然后按照顺序存取方式存取数据
<br>相联存储器 CAM<br>
可以按照内容访存的存储器，可以按照内容检索到存储的位置进行访问，快表就是一种相联存储器
<br><br>
<br>读写存储器<br>
既可以读，也可以写的存储器，例如磁盘、内存、Cache 等
<br>只读存储器<br>
只能读不能写的存储器，例如一些硬件的出场信息等，以及 bios 信息等，以及实体音乐专辑，一般存储在 CD-ROM 中
<br><br>
<br>断电后信息消失的存储器——易失性存储器，主存、Cache
<br>断电后依然可以保存的存储器——非易失性存储器，磁盘、光盘等
<br>信息读出后，原存储信息被破坏——破坏性读出，DRAM 芯片，读出之后数据要进行重写
<br>信息读出后，原存储信息不被破坏——非破坏性读出，SRAM 芯片、磁盘、光盘等
<br><br>
<br>存储容量——存储字数×字长【例如 1M×8 位】
<br>存储成本——每 bit 价格【总成本/总容量】
<br>存储速度——数据传输速率——数据的宽度（Byte）/存储周期（s）<br>
<img alt="{DE024925-8849-4960-975B-BA99D87ADD54}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{de024925-8849-4960-975b-ba99d87add54}.png">
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\存储系统的概念.html</link><guid isPermaLink="false">review/计算机组成原理/3.存储系统/存储系统的概念.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:33:32 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{17db14bb-96af-490f-9db7-2993f2d30bba}.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\3.存储系统\img\{17db14bb-96af-490f-9db7-2993f2d30bba}.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[高级语言与机器语言之间的对应]]></title><description><![CDATA[ 
 <br>高级语言——汇编语言——机器语言<br>指令的作用<br>
<br>操作数据
<br>改变指令的执行流
<br><br>
思考：指令 = 操作码 + 地址码，如何对应操作和操作码，数据如何寻找？
<br>以 MOV 指令为例<br>MOV destination【目的操作数】 source【源操作数】<br>
mov eax ，ebx<br>
mov eax ，5<br>
mov eax， dword ptr [af996h]<br>
mov byte ptr [af996h] ，5<br>
上述指令中蓝色的表示寄存器，绿色的表示立即数、紫色的表示主存中的数据存在的地址，地址前的英文表示操作地址中数据的位数，dword ptr 表示双字——32bit，word ptr 表示单字 ——16bit
<br>
X 86 CPU 中的寄存器每个都是 32 bit，分为三种<br>
1：EAX、EBX、ECX、EDX【通用寄存器】，若使用 AX、BX、CX、DX 来表示寄存器的话，则只使用寄存器的低 16 位，如果是 AH，则使用 AX 中的高 8bit，AL 使用 AX 中的低 8bit，其余同理<br>
2：ESI、EDI【变址寄存器】<br>
3：EBP、ESP【堆栈基指针——EBP】【堆栈顶指针——ESP】
<br><br>算数运算<br>
<img alt="Pasted image 20250429152555.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250429152555.png"><br>
为什么除法的操作数只用传入一个，因为除法在计算之前需要进行位扩展【具体内容联系第二章除法的运算】，所以会将被除数先放入到 edx: eax 寄存器中进行位扩展，所以需要两个寄存器来保存数据
<br>在 X86CPU 中不允许两个操作数同时来自于主存，为了减少指令访问主存的次数，来提高指令的执行速度<br>逻辑运算<br>
<img alt="Pasted image 20250429153459.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250429153459.png"><br><br><img alt="Pasted image 20250429153755.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250429153755.png"><br><br>选择语句实际就是跳转指令，可以指定下一条执行的指令的地址，其中这个地址可以来自于指令中的操作数部分也可以来自于寄存器部分，也可来自于主存<br>问题：如果只能使用地址来表示需要跳转的地址，对于汇编程序员来说也是不容易的事，所以会使用一个标志来表示需要跳转的位置，然后在具体的地址写上标志<br>
<img alt="Pasted image 20250502140903.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250502140903.png"><br><br><img alt="Pasted image 20250502141022.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250502141022.png"><br>
对于上述跳转指令的写法与无条件跳转的写法相同，一般结合 cmp 指令进行条件跳转<br>
Cmp num1, num2<br>
Jg [addr]<br><br>函数调用<br>
caller:    表示当前函数的内容<br>
call add    表示当前需要调用 add 函数<br>
ret    表示当前函数已经结束，进行返回<br>
当执行 call 指令时，会将当前 pc 寄存器也称为 ip 寄存器中的值压栈保存，然后再压入调用函数的栈帧，设置 ip 新值，将其设置为调用函数的第一条指令的地址<br>
当执行 ret 指令时，表示当前调用的函数已经结束，所以将当前函数的栈帧弹出，紧接着再弹出 pc 寄存器的原始值，然后再进行指令的执行
<br>——如何访问栈帧中的数据<br>
为什么在画调用栈时要反过来画，栈底在上，栈顶在下
<br><img alt="Pasted image 20250508192142.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508192142.png"><br>
对于 OS 来说，高地址表示内核区，低地址表示用户区，用户栈是紧贴着内核区的，所以对应的栈底是高地址，栈顶是低地址<br>联想之前的 EBP 和 ESP 寄存器，分别表示栈的当前函数的栈帧的底部和栈帧的顶部，由 ESP 和 EBP 表示栈帧的范围<br><img alt="Pasted image 20250508192944.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508192944.png"><br>当然还可以使用加减法控制 esp 指针的指向，然后使用 mov 指令来进行数据的读取或者写入<br><br>
<br>在进行函数调用时，先把前一个函数的栈帧基地址压入栈
<br>然后让 EBP 寄存器中的值指向 ESP 寄存器中指向的地址<br>
一般来说一个函数的栈帧底部一般都存放着上一函数的栈帧基地址<br>
<img alt="Pasted image 20250508194318.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508194318.png">
<br><br><img alt="Pasted image 20250508194453.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508194453.png"><br>
将 ESP 栈顶指针指向 EBP 指针，再将 ESP 指向的地址复制给 EBP，实现栈帧的切换<br>
在每个函数返回之前需要执行 leave 指令，然后再进行返回<br><br>栈帧内包含了哪些内容<br>
栈帧的底部包含了上一函数的栈帧基地址，栈帧的头部包含了调用该函数程序 call 指令的下一指令的地址<br>
通常将局部变量存放再栈帧的底部，C 语言中定义的局部变量越靠前则越接近栈顶<br>
在栈帧顶部的区域，会将函数的参数存放在栈帧顶部区域的空间中
<br><img alt="Pasted image 20250508195948.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508195948.png"><br>
以上述函数调用为例，会将调用函数的参数存放在 EBP 指针+8 和之上<br>
对于一个函数栈帧，其中会存在空闲的几个字节，这是因为 GCC 编译器一般会将栈帧大小设置为 16B 的整数倍（当前执行函数的栈帧除外）<br>总结：<br>
<img alt="Pasted image 20250508200401.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508200401.png"> <img alt="Pasted image 20250508201333.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250508201333.png"><br>
对于中间未使用的区域可以用作存放函数调用之前的相应寄存器的值]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\高级语言与机器语言之间的对应.html</link><guid isPermaLink="false">review/计算机组成原理/4.指令系统/高级语言与机器语言之间的对应.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 08 May 2025 12:17:28 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250429152555.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250429152555.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[扩展操作码指令格式与寻址方式]]></title><description><![CDATA[ 
 <br>定长指令字结构：指令系统中所有指令的格式长度都相等<br>
变长指令字结构：指令系统中所有指令的格式长度不相等<br>定长操作码：指令系统中所有指令的操作码长度相等<br>
变长操作码：指令系统中所有指令的操作码长度相等<br>定长指令字结构+可变长度操作码=扩展操作码指令格式<br>
<img alt="Pasted image 20250426092206.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426092206.png"> <br>设计扩展操作码指令时，要注意<br>
<br>不允许短码是长码的前缀，既短操作码与长操作码的前一部分相同
<br>各指令的操作码不能重复<br>
一般对于使用频率较高的指令设计短的操作码，减少指令译码的时间，对于使用频率较低的指令，设计长的操作码
<br>在设计时，需要根据每一种指令的具体条数来设计对应指令的长度，需要多少条就用多少位来表示<br><br><br>使用 pc 寄存器来保存下一条指令的地址<br>
pc+"1"：这里的 1 并不是地址+1，实际上是当前地址所占的地址长度<br><br>有时 CPU 会执行到 JMP 指令，PC 寄存器中的内容会受到该指令的影响，会将 PC 寄存器中的内容修改为 JMP 指令后面的地址<br>
例如：<br>
JMP 7——这个指令会将 PC 寄存器中的内容修改为 7<br><br>——探明本条指令地址码指明的真实地址<br>
为了标明对应不同寻址方式，需要在操作数前面使用一些标记位<br><br>——指令字中的形式地址就是操作数的真实地址<br>
<img alt="Pasted image 20250426100915.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426100915.png"><br>
优点：<br>
<br>指令执行阶段仅访问一次主存，不需要专门计算操作数的地址<br>
缺点：
<br>操作数的位数决定了寻址范围
<br>当操作数的地址发生改变就无法找到对应的操作数
<br><br>——指令字中的形式地址指向的存储单元中存储的还是地址，需要进一步访问该存储单元指向的地址中的内容<br>
<img alt="Pasted image 20250426101941.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426101941.png"><br><br>——在指令字中直接给出操作数所在的寄存器的编号，既 EA=R，操作数在 R 所指的寄存器内<br>
<img alt="Pasted image 20250426102239.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426102239.png"><br>
因为寄存器价格昂贵，所以 CPU 中寄存器的个数是有限的，所需要的操作码寻址的位数相对应的就可以减少，所以指令字长短<br><br>——指令中地址指向的寄存器中存储的是数据在主存中的地址，而不是从寄存器中直接寻址<br>
<img alt="Pasted image 20250426102633.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426102633.png"><br><br>——不是明显的给出操作数的地址，而是在指令中隐含操作数的地址<br>
<img alt="Pasted image 20250426103009.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426103009.png"><br>
一般是会将对应的操作数存放在累加寄存器 ACC 中<br><br>——会直接将我们需要的操作数存放在对应指令后面的操作码中<br>
<img alt="Pasted image 20250426103331.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426103331.png"><br><br>——以程序的起始存放地址作为起点<br>
在 CPU 内部会有一个基址寄存器 BR，进行基址寻址的时候会将指令中的形式地址+基址寄存器中的地址，最终得到操作数的实际地址，（注意：有的 CPU 会使用通用寄存器来当作基址寄存器使用，在指令中会指明这个寄存器的编号）<br>使用基址寻址方式可以便于程序在内存地址的浮动，程序运行前，CPU 会将 BR 中的值，修改为程序的起始地址（存在于进程控制块 PCB 中）<br>
<img alt="Pasted image 20250426105128.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426105128.png"><br><br>——类似基址寻址方式，通过指令中的形式地址+变址寄存器 IX 中的地址得到对应的真实地址<br>
其中 IX 可以为变址寄存器，也可以为通用寄存器<br>与基址寻址不同的是，变址寻址方式是面向用户的，变址寄存器中的值可以由用户改变（可以将 IX 视为偏移量，将形式地址视为基地址）<br><img alt="Pasted image 20250426111254.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426111254.png"><br>
有了变址寻址方式之后可以很方便的完成循环操作数组的程序，可以将数组的首地址看作为基地址传入指令的形式地址中，将循环步长看作是相对地址存入变址寄存器 IX 中<br>
<img alt="Pasted image 20250426111544.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426111544.png"><br><br>先通过基址寻址找到对应形式地址的真实地址，然后再通过该真实地址来进行变址寻址操作<br>
<img alt="Pasted image 20250426111949.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426111949.png"><br><br>——把 PC 的内容加上指令中的形式地址进而转换成实际真实有效的地址<br>
其中的形式地址是相对与 PC 所指地址的偏移量，可正可负，使用补码表示<br>
PC 在取走一条指令之后，会自动的指向下一条指令的地址
<br>相对寻址可以进行指令的跳转，与跳转到绝对地址不同，相对寻址可以在程序内部进行跳转，而不指向直接的地址进而出现错误<br><br><img alt="Pasted image 20250426113810.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426113810.png"><br><br>——操作数放在堆栈中，隐含使用堆栈指针 sp 指向操作数地址<br>
堆栈是存储器（或者专门的寄存器组）中一块特定的，按照先进后出的原则管理的存储区，该存储单元中的地址是由一个特定的寄存器给出的，该寄存器称为堆栈指针 sp<br>硬堆栈——使用寄存器组来表示栈的操作，通过 SP 来指向对应寄存器的编号，对应的 POP、PUSH 操作时 SP 的指向也会跟着变，但是使用寄存器堆栈的成本会很高，速度快<br>软堆栈——使用一段主存来表示栈，对应的 POP 和 PUSH 操作和栈的操作一样，但是访问速度相对硬堆栈来说会更慢，成本会更低]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\扩展操作码指令格式与寻址方式.html</link><guid isPermaLink="false">review/计算机组成原理/4.指令系统/扩展操作码指令格式与寻址方式.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 26 Apr 2025 06:25:50 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426092206.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\img\pasted-image-20250426092206.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[指令的基本结构]]></title><description><![CDATA[ 
 <br> 任何一条指令都由操作码和地址码组成，操作码表明要做什么，地址码表示对什么操作<br><br>
<br>指令格式——指令的寻址方式、操作类型、以及每种操作对应的操作数相应的规定
<br>操作数的类型——操作数的寻址方式以及是按大端存储还是按小端存储
<br>程序可以访问寄存器的编号、个数、和位数，存储空间的大小和编址方式
<br>指令执行过程中的控制方式等，包括程序计数器、条件码的定义等
<br><br>可以按照指令的地址码的个数对指令进行分类，可以将其分为 0 地址指令、1 地址指令 ……<br>零地址指令<br>
特点：只需要操作码，不需要操作数，<br>
例如：<br>
1.空操作、停机、中断等指令<br>
2.堆栈计算机：两个操作数隐含在栈顶和次栈顶，进行计算之后压回栈顶【注意此时并不是不需要操作数，只是操作数存放的位置是在栈顶和次栈顶，可以直接访问而不需要提供地址】<br>一地址指令<br>
特点：需要操作码和一个操作数<br>
例如：<br>
1.加一、减一、取反、求补等操作<br>
指令含义：OP (A 1)-&gt;A 1<br>
2.需要两个操作数，但是其中一个操作数隐含在某个寄存器中（如隐含在 ACC）<br>
指令含义：（ACC）OP（A 1）-&gt;ACC<br>
A 1 表示某个主存地址，（A 1）表示 A1 所指向地址的内容<br>
完成这样一条指令需要进行三次访存：取指令、读数据、写数据
<br>二地址指令<br>
OP  |  目的操作数  |  源操作数<br>
特点：需要两个操作数<br>
常用于需要两个操作数的算数运算、逻辑运算等相关指令<br>
指令含义：（A 1）OP（A 2）——&gt;（A 1）<br>
完成二地址指令需要进行四次访存操作：取指令、读源操作数、读目的操作数、写回数据
<br>三地址指令<br>
与二地址指令的功能是一样的，但是多了一个计算结果的存储地址<br>
OP  |  操作数 1  |  操作数二  |  结果<br>
指令含义：（A 1）OP（A 2）——&gt;A 3<br>
完成一条三地址指令需要进行四次访存: 取指令, 读操作数 1, 读操作数 2, 将结果写入对应地址
<br>四地址指令<br>
与三地址和二地址指令的操作都是一样的, 不同的是, 四地址指令在三地址的基础上添加了下一个指令的地址, 存放在第四个地址中<br>
<br><br>指令字长: 指令的总长度 (可能会变)<br>
机器字长: CPU 进行一次整数运算所能处理的二进制位数<br>
存储字长: 一个存储单元中所能存储的二进制代码位数<br>单字长指令、双字长指令、半字长指令——指令长度是机器字长的多少倍<br>
指令字长会影响到取指令所需时间，因为总线带宽一定，指令字长越宽，所需要的取指令时间越长<br><br>定长操作码：指令系统中所有指令的操作码长度都相同<br>
可变长操作码：指令系统中指令的操作码长度可变<br><br>1：数据传送：<br>
LOAD：把存储器中的内容存放到寄存器中<br>
STORE：把寄存器中的数据存放到存储器中<br>
2：算数逻辑操作<br>
算数：加减乘除、自增、自减、求补、浮点运算、十进制运算<br>
逻辑：与或非、异或<br>
3：移位操作<br>
算数移位、逻辑移位、循环移位（带进位、不带进位）<br>
4：转移操作<br>
无条件转移 JMP 操作<br>
条   件转移 JZ：结果位 0 ；JO：结果溢出；JC：结果产生进位<br>
调用与返回：CALL、RETURN<br>
陷阱 TRAP 指令<br>
5：输入输出操作<br>
CPU 寄存器与 IO 端口之间的数据传送]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\4.指令系统\指令的基本结构.html</link><guid isPermaLink="false">review/计算机组成原理/4.指令系统/指令的基本结构.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 03 May 2025 23:29:32 GMT</pubDate></item><item><title><![CDATA[5.6：多处理器]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20250514162556.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250514162556.png"><br><br><img alt="Pasted image 20250514163059.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250514163059.png"><br><br><img alt="Pasted image 20250514163742.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250514163742.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.6：多处理器.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.6：多处理器.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 14 May 2025 08:37:44 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250514162556.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250514162556.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5.5：五段式指令流水线]]></title><description><![CDATA[ 
 <br><img alt="Pasted image 20250513170812.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513170812.png"><br>再不同部分之间会有锁存器用来存储上一过程经过计算之后的结果和数据等信息<br><br>IF：根据 PC 从指令 Cache 中取指令至 IF 阶段的锁存器<br>
ID：取出操作数到 ID 阶段锁存器<br>
EX：运算，将运算结果存入 EX 锁存器<br>
M：【对于运算类指令，不需要将数据写回主存，所以没有访存阶段，为一个空段】<br>
WB：将运算结果写回寄存器<br>
LOAD Rd, 996 (rs)——可以理解为基址寻址，因为每个进程的起始地址是不一样的，使用 rs 寄存器指明进程在内存中的起始地址<br>
LOAD Rd，mem【注意此时虽然表示成直接从主存地址中取数据，但是实际 mem 表示的还是进行基址寻址之后得到的操作数地址】
<br>LOAD 指令执行过程中各段的作用【本质还是计算对应真实地址，类似 ADD 指令】<br>
IF: 根据 PC 从指令 Cache 中取指令到 IF 段的锁存器<br>
ID：将基址寄存器中的内容存入锁存器 A，将偏移量的值存入 Imm<br>
EX：运算得到对应的有效地址并放入锁存器<br>
M：根据计算的有效地址，从数据 Cache 中【主存中的数据有很大概率存储在 Cache 中，如果不在，那么就需要进行访存操作】取出对应的数据放入锁存器中<br>
WB：将刚才从数据 Cache 中取出的数据写回到寄存器中<br>STORE 指令执行过程中各阶段的作用<br>
IF：根据 PC 从指令 Cache 中取指令到 IF 段的锁存器<br>
ID：将基址寄存器放入锁存器 A，需要存放的数据放入锁存器 B，将偏移量放入 Imm<br>
EX：通过 ALU 计算得到正确的存放地址，并且将其放入锁存器 store<br>
M：将数据从锁存器中写入 Cache【所需要存放的地址大概率在 Cache 中有副本，先存入 Cache，然后从 Cache 写入主存中】<br>
通常 RISC 处理器只有 LOAD 和 STORE 指令才能访问主存
<br><br>——一般来说转移指令都是相对寻址的方式【相对于 PC 偏移多少】<br>
beq Rs, Rt<br>
如果 Rs == Rt，那么 PC+‘1’+偏移量* 指令字长，否则 PC+‘1’【偏移量表示的是相对下一条指令需要偏移多少条指令】<br>
IF：从指令 Cache 中取指令到 IF 段的锁存器<br>
ID：将进行比较的两个数放入锁存器 A 和 B，再将偏移量放入 Imm<br>
EX：运算比较两个数<br>
M：将目标 PC 的值写回 PC<br>
很多教材将上述 M 阶段的操作叫做 WrPC 段，其耗时比 M 更短，可安排在 M 段处理<br><br>对于无条件跳转指令与条件跳转指令的区别就是无条件跳转指令不需要进行 ALU 计算比较的过程，其他部分执行的操作基本一致<br>注意：只有等上一条指令进入 ID 段之后，下一条指令才能进入 IF 段，否则上一指令的 IF 段的数据会被覆盖掉]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.5：五段式指令流水线.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.5：五段式指令流水线.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 14 May 2025 07:06:38 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513170812.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513170812.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5.4：指令流水线]]></title><description><![CDATA[ 
 <br>传统的冯诺依曼机对于指令的执行方式就是，取指令，分析指令，执行指令，取指令，分析指令，执行指令串行执行<br>
但是我们注意到，在指令执行的不同时间段，所需要的计算机硬件是不一样的，所以我们可以在此基础上进行优化，在前一条指令取值周期结束之后，可以进行第二条指令的取指周期<br><br><img alt="Pasted image 20250513153915.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513153915.png"><br><br><img alt="Pasted image 20250513154044.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513154044.png"><br><br><br>——表示单位时间内流水线完成的任务的数量【单位时间内可以完成多少条指令】<br>
<img alt="Pasted image 20250513154729.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513154729.png"><br>
将指令分为 k 个执行阶段，每个阶段耗时 t，最终求解得到的吞吐率最理想的状况为 1/t，一般取 t 等于一个时钟周期<br>
装入时间：第一条指令从开始执行到执行结束所需要的时间<br>
排空时间：最后一条指令从开始执行到执行结束所需要的时间<br><br>——同一批任务，不使用流水线和使用流水线所用时间之比<br>
<img alt="Pasted image 20250513155156.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513155156.png"><br><br>——流水线的设备的利用率，设备的使用时间占总的时间的比例<br>
<img alt="Pasted image 20250513155435.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513155435.png"><br><br>为了方便安排流水线：所有指令必须安排为相同的执行周期和相同时间长度的周期<br>
<img alt="Pasted image 20250513161021.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513161021.png"><br><br>——操作系统的互斥问题<br>
多条指令在同一时刻争用同一资源形成的冲突<br>
<img alt="Pasted image 20250513161505.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513161505.png"><br>
对于指令 1 和指令 3 在同一时刻进行了主存的访问，所以可能会出现资源冲突的问题<br>
解决方法：<br>
<br>如果产生了冲突，那么把后面的指令暂停一个周期再执行
<br>将取指访存的 cache 体和访存访问的 cache 体放在不同的 cache 体中，这样就可以解决资源冲突的问题
<br><br>——数据冲突<br>
<img alt="Pasted image 20250513162001.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513162001.png"><br>
后面的指令操作的数据需要使用前面指令的运算结果，由上图可以看到第二、三、四条指令读取的 R1 寄存器中的内容是未更改的数据，最后一条指令的数据取 R1 能够得到正确的 R1 的值，因为此时 R1 的数据被写回<br>
解决方法：<br>
如果后面的指令需要依赖前面指令的执行结果，则后面的指令可以添加空操作，确保前面指令执行完成，数据被正确写入，或者后面的指令都暂停几个周期<br>
2. 使用数据旁路技术，由于第一条指令在执行运算周期之后已经存在数据了，所以只需要将 ALU 的输出端连接一条线到 ALU 的输入端也可以解决上述问题
<br>使用空操作或者硬件暂停周期<br>
<img alt="Pasted image 20250513162347.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513162347.png"><br>旁路技术——将 ALU 的输出连接一条线到 ALU 的其他输入端，从而不用等待数据写回寄存器<br>
<img alt="Pasted image 20250513162841.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513162841.png"><br>
编译优化——通过编译器调整指令顺序来解决上述问题<br>
将后面不依赖前面指令移动到前面优先执行<br><br>——控制冲突：当流水线遇到跳转指令或者其他改变 PC 值的指令而造成断流，会引起控制相关的冲突<br>
<img alt="Pasted image 20250513163623.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513163623.png"><br><br><img alt="Pasted image 20250513164240.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513164240.png"><br><img alt="Pasted image 20250513164556.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513164556.png"><br><br><br><img alt="Pasted image 20250513164842.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513164842.png"><br><br>——把一个时钟周期再分成多个部分，然后再这几个部分中采用流水线技术<br>
<img alt="Pasted image 20250513165049.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513165049.png"><br><br><img alt="Pasted image 20250513170305.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513170305.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.4：指令流水线.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.4：指令流水线.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 14 May 2025 07:15:32 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513153915.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513153915.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5.3：微程序控制器]]></title><description><![CDATA[ 
 <br>——将对应多个或单个微操作【硬布线控制器中的各个节拍发出的信号】集成在一起称为微指令<br>
——由多个微操作集成在一起形成形成了微指令<br>
对于不同机器指令来说，其微指令也是不同的，因为其对应着不同的微操作<br>
<img alt="Pasted image 20250510164842.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510164842.png"><br>
<img alt="Pasted image 20250510170152.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510170152.png"><br><img alt="Pasted image 20250510170125.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510170125.png"><br>
对于有些指令，在取址周期完成之后并不进入间址周期，所以微指令的下地址可能需要改变，这时候就需要顺序逻辑单元起到作用，在取完指令之后，微地址形成部件会告诉顺序逻辑现在执行的指令的地址位置，这样顺序逻辑就会将地址送入 CMAR 中进行指令的查找以及对应指令的解析等操作<br>
一般通过顺序逻辑来改变微指令的执行顺序
<br><img alt="Pasted image 20250510171614.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510171614.png"><br>
注意：这里一条指令的不同周期使用不同的微程序组成，但是在远古 CPU 中，一般不提供间址和中断，所以一般对于 n 条指令需要 n+1 个微程序段，一条指令对应一条微指令
<br><br>如何根据微指令发出与之对应的微命令【微命令与微操作是一一对应的，每一个微命令都对应一根输出线】<br><br>——在设计指令时，一条指令可能会对应多个可并行的微操作，<br>
<img alt="Pasted image 20250513143346.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513143346.png"><br><br>——在设计指令时，一条指令只对应一条微指令<br><br>
<br>直接编码方式——每一个操作为对应一个微操作<br>
<img alt="Pasted image 20250513143929.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513143929.png">
<br>字段直接编码<br>
将互斥的指令放在同一个段中，使用段中译码来选择需要哪些对应的输出信号<br>
<img alt="Pasted image 20250513144326.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513144326.png">
<br>字段间接编码<br>
——一些字段中的某些微命令需要由另一个字段中的某些微命令来解释，由于不是靠字段译码来表示的，所以称为字段间接编码<br>
<img alt="Pasted image 20250513145207.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513145207.png">
<br><br>
<br>微指令的下地址字段直接给出
<br>根据机器指令的操作码形成——微指令的地址由操作码经微地址形成部件生成
<br>增量计数法——类似指令中的 PC+1，对于微指令就是直接在地址上+1，CMAR+1
<br>分支转移——类似 JMP 指令，
<br>由硬件直接产生微程序入口地址，如果程序进入了中断周期，那么会有硬件会专门记录中断周期微程序的首地址
<br>通过连接测试<br>
<img alt="Pasted image 20250513150400.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513150400.png">
<br><br>——类似于硬布线控制器设计<br>
将能够同步进行的操作放在一条微指令中<br>
<img alt="Pasted image 20250513151030.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513151030.png"><br>
注意：在进行指令编码时，需要将互斥的指令放在同一个类中进行编码，需要与指令设计分开<br>
<img alt="Pasted image 20250513151720.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250513151720.png"><br>
在取指令的微操作中, 每次执行完成之后都会有一个将后续指令的地址放入 CMAR 中的操作，对于每条指令的执行，首先会有一个通过指令操作码确定微指令首地址的过程]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.3：微程序控制器.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.3：微程序控制器.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Tue, 13 May 2025 07:20:00 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510164842.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250510164842.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5.2：硬布线控制器]]></title><description><![CDATA[ 
 <br>为了确定当前状态下，根据指令的操作码，当前的机器周期、节拍信号、机器状态条件等，来确定当前节拍下 CU 该发出哪些微指令<br><br>由译码器和 CU 相联，对于 n 位操作码，有 2^n 条线与 CU 相联，译码结果是多少，对应传入的第几根线就是高电平<br><br>FE、IND、EX、INT 四个触发器集成在 CU 内部，根据不同触发器的信息来确定当前处于什么机器周期【取址周期、间址周期、执行周期、终端周期】<br><br>会有一个节拍信号发生器与 CU 进行连接，会有很多根数据线与 CU 相连，不同的节拍会有不同的线导通，以此来进行节拍信号的确定，对于节拍的输出是循环输出的<br><br>机器状态的确定是根据执行单元的反馈信息来确定的，例如 PSW、ACC、主存、I/O 设备等<br><br><img alt="Pasted image 20250509111644.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509111644.png"><br>
对于不同微指令的控制，需要根据不同的信号，例如 C1 是 PC-&gt;（MAR）此时需要节拍为 T0，FE=1，表示在 T0 节拍，取址周期，此时需要从 PC 指向的地址中取数据，则 C1 的表达式就是 T0&amp;FE，其他信号也是如此<br><br>——采用定长机器周期进行分析，每个机器周期内安排 3 个机器节拍<br>
安排操作时序：如何在 3 个节拍内完成整个机器周期内的所有微操作<br><br>
<br>微操作的先后顺序不得随意更改
<br>被控对象不同的微操作尽量放在同一个节拍
<br>占用时间较短的微操作尽量放在一个节拍内完成，并允许有先后顺序
<br><br>
<br>PC 中的地址放入 MAR
<br>产生读信号
<br>根据 MAR 指向的地址取出数据放入 MDR
<br>MDR 中的数据放入 IR
<br>将指令的操作码部分送给 ID（指令译码器）
<br>PC+1<br>
<img alt="Pasted image 20250509115117.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509115117.png"><br>
对于 CPU 内部的操作，所需的时间很短，所以可以将其安排在一个节拍内
<br><br>
<br>将指令中的间接地址取出，将其放入 MAR
<br>发出读信号
<br>根据 MAR 的地址取出数据放入 MDR
<br>将有效地址拼接到指令的地址码部分（替换指令的形式地址）<br>
<img alt="Pasted image 20250509115218.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509115218.png">
<br><br>——对于不同指令对应的操作不一样，具体指令具体分析<br>
CLA 指令——将 ACC 中的内容清空<br>
如果对于指令所需的微操作很少的话，一般把这个微操作放在最后一个节拍内完成<br>
<img alt="Pasted image 20250509115437.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509115437.png"><br>
对于访存指令，有可能会出现间址周期，结合上述间址周期来实现<br>
<img alt="Pasted image 20250509115545.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509115545.png"><br><br><img alt="Pasted image 20250509120717.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509120717.png"><br>
画出不同周期中的节拍以及指令表，表示当前指令，在当前指令周期内的当前节拍下是否可能会使用这个微操作<br>
结合画出的表，然后找出使用当前微命令的指令周期、周期内节拍，以及对应指令写出当前微指令的逻辑有效表达式<br>
根据写出的表达式画出逻辑电路图]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.2：硬布线控制器.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.2：硬布线控制器.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 09 May 2025 04:09:50 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509111644.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509111644.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5.1：CPU的功能和基本结构]]></title><description><![CDATA[ 
 <br>CPU 由控制器和运算器组成<br>
运算器主要负责进行算数运算和逻辑运算<br>
控制器主要用于取指令、分析指令、执行指令<br>
<img alt="Pasted image 20250508204854.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250508204854.png"><br><br><img alt="Pasted image 20250508210730.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250508210730.png"> ALU 没有记忆功能，必须两个操作数同时到达才能进行两个操作数的运算，所以需要添加暂存器来保存来自 CPU 内部总线的数据，否则会出现冲突<br>
ALU 必须等到输出结果稳定之后才能进行输出到总线的操作，所以在 ALU 的输出方向也需要一个暂存器来保存对应的结果<br>
对于暂存器的扩展使用：可以将其改造为移位寄存器等<br><br><img alt="Pasted image 20250508211740.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250508211740.png"> 用户不可见寄存器，MAR、MDR、IR、微程序控制器 CM 以及各种标志寄存器<br><br>指令周期：CPU 从主存中取出一条指令并执行一条指令所用的时间<br>
一个指令周期可以划分为取址周期和执行周期两个部分，其中取值周期会根据 PC 指向的地址进行取址并且 PC++，然后对指令进行译码操作【但是译码所需要的时间是很短的】<br>
指令周期一般用机器周期来表示，机器周期又叫 CPU 周期，一个 CPU 周期又包含若干个时钟周期<br>
<img alt="Pasted image 20250509090907.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509090907.png"><br>
每个指令内机器周期数可以不等、每个机器周期内的时钟周期也可以不等
<br>整个指令周期的执行过程<br>
<img alt="Pasted image 20250509092020.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509092020.png"><br><br><img alt="Pasted image 20250509092654.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509092654.png"><br><br><img alt="Pasted image 20250509093141.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509093141.png"><br>
指令的执行阶段并没有一个数据的具体流向<br><br><img alt="Pasted image 20250509093750.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509093750.png"><br><br><img alt="Pasted image 20250509094546.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509094546.png"><br>
对于流水线控制方式，在指令执行的不同阶段，使用的计算机资源是不一样的，所以在不同时期可以让不同的指令进行执行以达到资源利用最大化<br><br><img alt="Pasted image 20250509095229.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509095229.png"><br>
对于 CPU 内部单总线方式总线内同时只允许两个部件进行数据交换，否则会出现冲突<br><br><img alt="Pasted image 20250509095633.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509095633.png"><br>
对于主存和 CPU 之间的数据交换也可以相同理解，对于指令的执行，结合前面的讲解可以了解到具体数据的来源，了解到来源之后，可以结合对应的控制信号完成对应指令的执行<br>
对于单总线结构，ALU 需要配合暂存器使用<br><br><img alt="Pasted image 20250509103505.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250509103505.png">]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\5.1：cpu的功能和基本结构.html</link><guid isPermaLink="false">review/计算机组成原理/5.CPU中央处理器/5.1：CPU的功能和基本结构.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 09 May 2025 02:35:05 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250508204854.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\5.cpu中央处理器\img\pasted-image-20250508204854.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[6.2：总线操作和定时]]></title><description><![CDATA[ 
 <br><br><br>——就是采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线时钟周期，在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传输周期中，一个总线的传送周期结束之后，下一个传送周期开始。<br>
<img alt="Pasted image 20250516193221.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516193221.png"><br>
优点：<br>
<br>传送速度更快，具有高效率的传输速率，总线逻辑控制简单<br>
缺点：
<br>主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差
<br>如果从设备的速度慢于主设备就会出现数据无法及时供应<br>
同步总线适用于总线长度较短，以及总线连接部件存取时间比较接近的系统
<br>
同步串行通信方式：是发送方时钟直接控制接收方时钟，使双方完全同步的一种逐位传输的通信方式。使用同步串行通信方式时，接发双方的时钟严格一致，因此在数据的头尾部添加了开始和结束标志，传输效率更高，但是硬件实现也更为复杂。
<br><br>——系统不会提供统一的时钟信号，也没有固定的时间间隔, 依靠传送双方相互制约的“握手”信号来实现定时控制<br>
主设备提出交换的请求信号，经接口传送到设备，从设备连接到主设备的请求之后，通过接口向主设备发出“回答信号”。<br><br>主设备发出请求之后不会管从设备有没有发出“回答信号”，而是经过一段时间之后便撤销“请求信号”<br>从设备接收到“请求”信号之后，发出“回答”信号，经过一段时间之后自动撤销回答信号 <br><br>主设备发出请求信号之后，必须接收到从设备的“回答”信号才撤销“请求”信号，有互锁的关系<br>从设备在收到“请求”信号之后，不用等主设备的请求信号撤销，而是一段时间之后自动撤销“回答”信号<br><br>主设备发出请求信号之后，必须等收到从设备的“回答”信号之后才撤销请求信号<br>从设备在接收到“请求”信号之后，发送“回答”信号，必须检测到主设备撤销“请求”信号之后才会撤销回答信号<br>异步定时的优点：<br>
<br>总线周期长度可变，能保证两个工作速度相差较大的部件或设备之间可靠的进行信息交换，自动适应时间的配合<br>
异步通信的缺点：
<br>比同步控制方式稍微复杂一点，速度比同步定时要慢
<br><br>——在同一时钟周期的基础之上，增加 wait 信号，如果出现主从设备速度不匹配的问题，那么就添加 wait 信号，调整主从设备之间的速度差异<br>
<img alt="Pasted image 20250516195157.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516195157.png"><br><br>在一个总线传输周期中<br>
<br>主模块发送地址，命令【使用总线】
<br>从模块准备数据【不使用总线】
<br>从模块向主模块发送数据【使用总线】
<br>由于从模块准备数据的时候不占用总线，所以把这一个总线传输周期分为两个独立的子周期<br>
子周期 1：主模块占用总线，发送地址和命令，发送完毕之后释放总线<br>
子周期 2：从模块占用总线，将数据传输给主设备，发送完毕之后释放总线<br>特点：<br>
各模块均有权力占用总线<br>
采用同步通信方式，不等对方回答<br>
各模块准备数据时，不占用总线<br>
总线利用率更高]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\6.2：总线操作和定时.html</link><guid isPermaLink="false">review/计算机组成原理/6.总线/6.2：总线操作和定时.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 16 May 2025 11:59:16 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516193221.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516193221.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[6.1：总线概述]]></title><description><![CDATA[ 
 <br>——总线是一种能为多个部件实现分时共享的公共信息传输线路<br>分时和共享是总线的两个基本特征<br>
<br>分时指的是同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，那么他们只能分时的像总线传送数据
<br>共享指的是总线上可以挂接多个部件，各部件之间相互交换的信息都可通过者组线路实现分时共享，多个部件可以同时从总线上接收数据<br>
为什么要采用总线
<br>为了解决 I/O 设备和主机之间连接的灵活性的问题，计算机结构从分散连接变为总线连接<br>
总线设备
<br>总线上所连接的设备，按其对总线是否有控制能力分为主设备和从设备两种
<br>主设备：发出总线请求获得总线控制权的设备
<br>从设备：指被主设备访问的设备，他只能相应主设备发来的各种总线命令<br>
总线特性
<br>机械特性：总线的尺寸、形状
<br>电气特性：传输方向、有效的电平范围
<br>功能特性：每根传输总线的内容
<br>时间特性：信号和时序的关系<br>
<img alt="Pasted image 20250516132847.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516132847.png">
<br><br><br>
<br>串行总线——每次只能传递一位数据【USB】<br>
优点：只需要一根传输线，成本低廉，广泛应用于长距离传输，应用于计算机内部时，可以节省布线空间，抗干扰能力强<br>
缺点：在数据发送和接收的时候，需要进行拆卸和装配，要考虑串行和并行转换的问题
<br>并行总线——每次可以同时传递多位数据<br>
优点：总线的逻辑时序比较简单，电路实现起来比较容易<br>
缺点：信号线数量多，占用更多的布线空间，远距离传输成本高昂，在由于工作频率较高时，信号线之间会形成严重的干扰，对每条线等长的要求也比较高，所以无法提升工作频率
<br><br><br>——CPU 内部的总线，是 CPU 芯片内部寄存器于寄存器之间、寄存器于 ALU 之间的公共连接总线<br><br>——系统总线是计算机系统内各部件【CPU、主存、IO 接口】之间相互连接的总线，按照系统总线传输内容的不同又被分为数据总线、地址总线、控制总线<br>
<br>数据总线——用来在各部件之间传输数据，指令，中断类信号等，它是双向传输总线，数据总线，总线数据的位数反映了一次能传输的数据位数
<br>注意区分数据通路和数据总线：数据通路指的是由各功能部件通过数据总线连接形成的数据传输路径称为数据通路，主要描述的是数据流经的路径，而数据总线是数据传输的媒介<br>
<br>
地址总线——用来指出数据总线上源数据或者目的数据所在的主存单元或者 IO 接口的地址，他是单向传输总线，地址总线的位数反映了最大的寻址空间

<br>
控制总线——用来传输各种命令、反馈和定时信号，典型的控制信号包括时钟、复位、总线请求/允许、中断请求/回答、存储器读/写、IO 读/写、传输确认等

<br><br>计算机系统时间以及计算机系统和其他系统之间传送信息的总线，通信总线也成为外部总线<br><br>双总线结构由两条总线，一条是存储总线，用在 CPU 于主存和通道间传递数据，另一条是 I/O 总线，用于在多个外设于通道间传递数据<br><img alt="Pasted image 20250516141920.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516141920.png"><br>
对于通道来说，主要作用是要管理外部设备，所以需要运行外部设备管理程序，该程序是存储在主存中的，所以主存和通道之间也可以通过总线进行交互
<br>对于上述主存总线是可以进行猝发传送的【送出一个地址可以收到多个连续的数据】<br>优点：将外部设备于原单总线上分离出来，实现了存储器总线和 I/O 总线分离<br>
缺点：需要增加通道等硬件设备<br><br>——三总线结构是在计算机之间采用三条总线来构成信息通路，这三条总线分别为主存总线、I/O 总线、和内存直接访问总线【DMA 总线】<br>
<br>主存总线用于 CPU 与主存之间传送地址、数据、控制信息
<br>I/O 总线用于 CPU 和各类外设之间进行通信
<br>DMA 总线主要用于内存和高速外设之间传送数据<br>
<img alt="Pasted image 20250516142801.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516142801.png">

由于磁盘是按块读取数据的，所以可以使用 DMA 总线读入很多个块，然后 CPU 直接从快速主存中读取数据，从而缓解 CPU 和磁盘之间的冲突


<br>优点：提高了 I/O 设备的性能，使其能够更快的相应命令，提高系统吞吐量<br>
缺点：任意时刻只能使用一条总线，系统工作效率更低<br><br><br>一次总线数据传输所需要的时间，通常包括申请阶段、寻址阶段、传输阶段、结束阶段，总线传输周期通常由多个总线时钟周期构成<br>
申请阶段：总线仲裁【决定是否把总线给某个设备使用】<br>
寻址阶段：主设备会通过地址总线将需要读或者写的地址单元传递给从设备<br>
传输阶段：通过数据总线从从设备中读出数据或者写入数据<br>
结束阶段：释放总线的使用权<br>经过一个传输周期之后可以传送一组数据<br><br>总线的时钟周期通常是由 CPU 发出的，所以总线的时钟周期通常就是机器的时钟周期<br>
计算机有一个统一的时钟，以控制计算机的各个部件，总线也需要受时钟周期控制<br>
大多数情况下<br>
一个总线传输周期对应多个总线时钟周期<br>
但是一个总线的传输周期也可能对应一个总线的时钟周期<br>
也有可能多个总线的传输周期对应一个总线的时钟周期【对于多对一的情况，可能是总线上升沿进行一次传输，下降沿进行一次数据传输】<br><br>指的是总线上一秒钟可以传递多少数据，为总线周期的倒数<br>
若总线周期=N 个总线时钟周期，那么每进行一次数据传输需要占用 N 个总线时钟周期，所以此时总线的工作频率 = 总线的时钟频率/N<br><br>既机器的时钟频率，表示可以将 1s 分为多少个时钟周期，如果时钟周期为 T，那么总线的时钟频率为 1/T<br><br>总线宽度指的是能够同时在总线上传递的数据位数，通常指的是数据总线的根数，如 32 为称为 32bit<br><br>单位时间内总线上最多可传递的数据位数，通常用每秒传送的字节数来衡量，单位可用字节/秒，总线带宽= 总线宽度 * 总线频率 bit/s，或者总线宽度/总线周期<br><br>总线复用指的是一根信号线来实现不同的信息传输，例如数据线、地址线复用，将总线进行分时使用，在某一段时间内传递的是数据，某一段时间传输的是地址数据<br><br>地址总线、数据总线、控制总线三种总线综合称为信号线数<br>其中总线最重要的性能指标为总线宽度，总线工作频率、总线带宽，总线带宽为衡量总线性能的重要指标<br><br>——解决多个设备对总线的使用<br><br>
<br>主设备发送请求信号
<br>若有多个设备同时要使用总线，则由总线控制器判优，仲裁逻辑按一定的优先等级顺序确定哪个设备能使用总线
<br>获得总线使用权的设备从主设备开始传输数据
<br><br><img alt="Pasted image 20250516152219.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516152219.png"><br>加入三根控制线 BS,BG,BR 来进行总线的控制<br>
步骤：<br>
<br>首先设备 1 和设备 n 分别向 BR 总线上发送请求
<br>总线控制部件通过 BG 发送总线允许信号，先经过谁，谁就优先使用总线
<br>当经过设备 0 的时候，由于该设备不需要使用，所以会放行信号
<br>当经过设备 1 的时候，由于该设备需要使用总线，则截断总线允许信号然后再 BS 线上发送总线忙的信号
<br>直到设备 1 使用总线结束之后才放行总线允许信号

总线忙是由获得总线控制权的设备发出的, 离控制器越近的设备越优先能够控制总线, 优先级固定


<br>优点: 链式查询优先级固定, 只需要很少的线就能实现总线控制, 结构简单扩充容易<br>
缺点: 硬件电路很敏感, 并且优先级不能改变, 当优先级高的部件频繁请求使用总线时, 会使优先级低的部件长时间不能使用总线 <br><br>在总线控制部件中会有一个计数器来标记是谁要使用总线, 如果不是就将计数器+1, 表示是不是下一个设备需要使用总线<br>
<img alt="Pasted image 20250516153750.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516153750.png"><br>步骤:<br>
<br>当设备 1 在 BR 发起总线请求时, 从 0 开始 (不是固定从 0 开始，也可能从上一次询问的结果开始)询问是不是设备 0 要使用总线
<br>设备 0 不使用总线，那么计数器就+1，询问是不是设备 1 要使用总线
<br>设备 1 使用总线，所以在 BS 控制信号上发送总线忙的信号
<br>设备 1 进行总线的使用和传输数据
<br>当使用完毕之后移除总线忙的信号<br>
优点：<br>
 -计数器的初始值可以改变优先级<br>
- 计数器从 0 开始，设备的优先级就按照顺序排列，固定不变<br>
- 计数器从上一次终点开始，此时设备使用总线的优先级相等<br>
- 计数器的初值还可以由程序设置<br>
- 对电路的故障没有链式敏感
<br>缺点：<br>
- 增加了控制线数【如果设备有 n 个，那么就需要能够表示 log2n 上取整条设备地址线，另外加上 2 条 BR 和 BS 控制线】<br>
- 控制相对比链式复杂<br><br>每个设备都有一根独立的总线请求线和总线允许线<br>
<img alt="Pasted image 20250516154837.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516154837.png"><br>
当接收到多个请求信号的时候，排队器会决定优先将总线给什么设备使用<br>优点：<br>
- 响应速度快，总线允许信号 BG 直接从控制器发送到相关设备，不必在设备间传递或者查询<br>
- 对优先级的控制相当灵活<br>缺点：<br>
- 控制线数量多，多设备有 n 个，则需要 2 n+1 条线，其中+1 条是 BS 线，用来表示总线忙，<br>
- 总线的逻辑控制更加复杂<br><br>不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线<br>
当有设备请求总线时，他们就把自己的仲裁号发送到共享的仲裁总线上，每个仲裁器将总线上的仲裁号与自己的进行比较，如果仲裁号比自己的高，则它的总线请求不做处理，并撤销它的仲裁号，最终仲裁号优先级高的保留在仲裁总线上获得总线使用权]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\6.1：总线概述.html</link><guid isPermaLink="false">review/计算机组成原理/6.总线/6.1：总线概述.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 16 May 2025 08:00:16 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516132847.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\6.总线\img\pasted-image-20250516132847.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7.2：IO接口]]></title><description><![CDATA[ 
 <br>——IO 接口，IO 控制器、设备控制器，负责协调主机与外部设备之间的数据传输<br>
作用：<br>
<br>数据缓冲：通过缓冲寄存器达到主机和外设之间的速度匹配
<br>错误或状态检测：通过状态寄存器反应各种错误、状态信息，供 CPU 查询
<br>控制器和定时：接收从控制总线发来的控制信号和时钟信号
<br>数据格式的转换：串行数据转并行数据，并行数据转串行数据
<br>与主机进行通信：主机通过 IO 接口与外部设备进行通信<br>
<img alt="{1F7BE879-92EA-444C-A508-1D4876249E02}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{1f7be879-92ea-444c-a508-1d4876249e02}.png">
<br>设备侧<br>
<br>外部接口：通过接口电缆与外部相联，外部接口的数据传输可能是串行传输也可能是并行传输
<br>内部接口：与系统总线相连，实际上始于内存 CPU 相连<br>
【例如显卡的金手指就是内部接口，外部的 HDMI 和 DP 就是外部接口】
<br><br>
<br>发命令：CPU 发送设备字到 IO 控制寄存器，向设备发送命令【一般来说对于设备的操作，CPU 是不知道设备字的，所以需要结合对应设备的驱动来进行设备字的发送】
<br>读状态：从状态寄存器中读取数据，获得设备或 IO 控制器的状态信息
<br>读写数据：从数据缓冲寄存器中发送或者读取数据，完成主机与外设的数据交换<br>
<img alt="{981C8C9F-857D-407E-ADB8-4C6879BD11EB}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{981c8c9f-857d-407e-adb8-4c6879bd11eb}.png"><br>
状态/控制寄存器的复用<br>
有的状态寄存器和设备寄存器使用时间上是错开的，所以有的 IO 接口中会将状态寄存器和控制寄存器进行复用
<br>IO 端口的概念<br>
对于数据寄存器、状态/控制寄存器，CPU 会称为端口，不同的寄存器称为不同的端口，所以 CPU 进行寄存器的访问时，就伴随着访问哪个端口，所以会给端口进行编号以及通过地址线控制 CPU 对端口的访问<br>中断<br>
当设备出现故障等会通过控制线向 CPU 发送一个中断请求信号，由于各种中断类型不一样，IO 接口会结合状态、控制寄存器等信息通过数据线向 CPU 发送一个中断类型号<br><br><br>与内存进行一块编址，靠不同的地址码就可以区分主存地址还是 IO 端口地址<br>
进行统一编制，可以靠不同的地址码区别主存还是 IO 端口，IO 地址要求相对固定在地址的某个部分，又称存储器映射方式<br>
优点：<br>
<br>不需要设计专门的输入、输出指令，所有访存指令都可以直接访问 IO 端口，程序设计灵活性高
<br>端口的编址空间很大<br>
缺点：
<br>端口占用了主存空间，主存编址范围变小
<br>外设寻址时间较长（地址位数多，地址译码速度慢）
<br><br>与内存分开编址，靠指令进行区分访问的是主存地址还是 IO 端口地址<br>
进行独立编址，CPU 需要设计专门的输入、输出指令访问 IO 端口，又称 IO 映射方式<br>优点：<br>
<br>有专门的 IO 指令，程序编制清晰
<br>IO 端口地址位数比较少，地址译码速度快
<br>IO 端口不会占用主存的空间<br>
缺点：
<br>程序的设计灵活性较差
<br>IO 指令类型少，只能对端口进行传送操作
<br>需要 CPU 提供存储器读写，IO 读写两组控制信号，增加了逻辑信号的复杂性
<br><br><img alt="{7E0ED88C-69D2-4840-887F-21E4063D9904}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{7e0ed88c-69d2-4840-887f-21e4063d9904}.png"><br>
对于程序查询控制方式，CPU 一致检查外设的状态是否在就绪状态，如果在就绪态 CPU 就发送工作给外设，当状态为 busy 状态时，CPU 就会一直等待，CPU 与外设是串行工作的，CPU 利用率低<br>
查询还可以分为独占查询还有定时查询<br>
独占查询<br>
<br>CPU 在操作外设的过程中，100%的时间都在查询状态寄存器，完全串行<br>
分时查询
<br>CPU 在操作外设的过程中，保证数据不丢失的情况下，每隔一段时间 CPU 查询一次 IO 状态，查询时间间隔内，CPU 可以进行其他的操作
<br><br><br>——程序中断指的是在计算机执行程序的过程中，出现某些异常的情况或者特殊请求需要处理，CPU 暂时终止当前程序的执行，转而去对这些异常情况或者特殊请求进行处理，处理完毕之后 CPU 再回到程序断点处，继续执行源程序<br>中断工作流程<br>
<br>中断请求：中断源向 CPU 发送中断请求信号
<br>中断相应：

<br>进行中断相应条件判断（当 CPU 处于关中断状态，再一段时间内 CPU 不会对中断进行相应）
<br>如果当前 CPU 条件允许处理中断，那么就会进行中断判优（如果同一时刻有多个中断请求，需要进行中断优先级的判断）


<br>中断处理<br>
- 中断隐指令：将其指向中断服务的正确的指令的位置，也就是修改 PC 的值，使其指向中断服务的第一条指令的值<br>
- 中断服务执行：从 PC 指向的地址开始开始执行指令<br>
如何判断 CPU 是否处于关中断状态呢，再 PSW（状态寄存器）中有一个字段 IF 表示当前 CPU 是否处于关中断状态，IF 为 1 表示开中断，IF 为 0 表示关中断
<br>中断请求标记<br>
为了区分中断请求的发送源，终端系统需要对每个中断源设置中断请求标记 INTR，当其字段为 1 的时候表示中断来自它, 这些触发器可组成中断请求标记寄存器组，改寄存器可集成在 CPU 中，也可分散再各中断源中<br>
对于外部中断，CPU 在统一的时刻，既在程序执行完成之前，向接口发出中断查询信号，以获取 IO 的中断请求，也就是说，CPU 相应中断的时间是在每条指令执行阶段的结束时刻<br>CPU 相应中断必须满足 3 个条件<br>
<br>中断源有中断请求
<br>CPU 允许中断
<br>一条指令执行完成，且没有更紧迫的任务
<br>中断判优<br>
中断判优可以由硬件实现也可以由软件实现<br>
硬件实现是通过硬件排队器实现的，它既可以设置在 CPU 中也可以分散在各个中断源中<br>
软件实现就是通过查询程序实现的<br>
<img alt="{D6AC7A5D-1435-4128-831B-9E8800038A2F}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{d6ac7a5d-1435-4128-831b-9e8800038a2f}.png"><br>
上图所示硬件排队器，左边优先级更高，右边优先级更低，通过与非门进行连接，当前面出现 1 的时候后面的输出就会置为 0<br>软件检查方法，一位一位的检查，检查速度较硬件来说比较慢<br>优先级设置<br>
<br>硬件故障属于最高级，其次是软件中断
<br>非屏蔽中断优先于可屏蔽中断
<br>DMA 请求优于 IO 设备请求
<br>高速设备由于低速设备
<br>输入设备优于输出设备
<br>实时设备优于普通设备
<br>中断处理过程<br>
<img alt="{09910E42-35B1-45D3-8173-A56967FAACA5}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{09910e42-35b1-45d3-8173-a56967faaca5}.png"><br>
将之前的硬件排队器可以看作为中断向量地址形成部件，因为最终硬件排队器只会输出一位 1，确定当前的中断源可以形成中断向量地址，然后再根据中断向量地址找到对应的中断向量（中断程序的入口地址）找到对应中断所需要进行的中断处理程序<br>注意区分中断向量和向量地址：<br>
中断向量可以理解为指向中断服务函数的指针；<br>
向量地址可以理解为指向中断服务函数指针存放的地址<br>使用两级指针的优点，当中断服务程序的地址发生变化之后可以直接修改中断向量的指向，而不用修改硬件电路<br>中断服务的主要任务<br>
保护现场：保存通用寄存器的值和状态寄存器中的内容，以便于返回原程序之后可以恢复 CPU 环境，可以使用堆栈也可以使用特定的存储单元<br>
中断服务：主要内容，根据中断的类型，执行不同的中断服务程序<br>
恢复现场：通过堆栈将各类寄存器的值把之前保存的信息送回各寄存器中<br>
中断返回：将 PC 的值回到正常程序的指令地址<br><br><img alt="{6B7A1C8D-221C-4469-8368-753E9EDCABFC}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{6b7a1c8d-221c-4469-8368-753e9edcabfc}.png"><br>中断屏蔽字<br>
中断屏蔽字主要用于多重中断，CPU 要具备多重中断的功能，必须满足以下条件<br>
<br>在执行中断程序之前提前开中断
<br>优先级别高的中断源有权屏蔽优先级别低的中断源信号<br>
每个中断源都有一个屏蔽触发器，置为 1 时表示屏蔽该中断源的请求，置为 0 时表示正常申请，所有屏蔽字触发器放在一起可以构成屏蔽字寄存器，内容就放各中断源的屏蔽字，每个屏蔽字至少有一个屏蔽字，至少不能被自己中断
<br>
中断屏蔽字的原理，当执行某个中断时，会对应一个中断屏蔽字，当有其他中断源发出中断请求之后，会将当前中断的屏蔽字与中断请求信号一并放入增加了屏蔽字的硬件排队器中，最终输出的结果如果全为 0，则表示当前中断不能中断上一个中断，若存在一个 1，则说明当前中断可以中断上一中断
<br><img alt="{6A048551-0582-457E-81F6-565731E9F367}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{6a048551-0582-457e-81f6-565731e9f367}.png"><br><br><img alt="{D9777C2B-30B4-4A43-8DCC-04B7A2CD214A}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{d9777c2b-30b4-4a43-8dcc-04b7a2cd214a}.png"><br>
引入中断机制之后，CPU 可以和外部设备同时工作<br><br>CPU 向 DMA 控制器指明需要操作的地址以及操作方式（读/写），需要传多长的数据<br>
<img alt="{DA1F6345-9C43-4E33-9FDD-C95325E87271}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{da1f6345-9c43-4e33-9fdd-c95325e87271}.png"><br>DMA 向 CPU 报告操作的结束使用的是中断操作<br>
<img alt="{B15F63F5-91B5-48DE-8DD3-473C837305CD}.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{b15f63f5-91b5-48de-8dd3-473c837305cd}.png"><br>DMA 工作时 CPU 的工作流程<br>
<br>预处理

<br>主存起始地址放到 AR（贮存地址计数器）中
<br>IO 设备地址放入 DAR 中，进行设备选择
<br>传送数据个数到 WC （传送长度寄存器）中
<br>启动 IO 设备


<br>数据传送

<br>CPU 继续执行主程序
<br>同时外部设备完成对数据的传送


<br>后处理

<br>中断服务程序
<br>作 DMA 结束处理


<br>在进行数据传送的过程中，DMA 会一直接收从外部设备传送的数据，当等到数据缓冲寄存器中写满之后，DMA 会通过 DMA 请求触发器发送 DMA 请求申请总线控制权，CPU 将总线交给 DMA，DMA 通过总线向主存中写数据<br><br>——停止 CPU 访问主存<br>
当 DMA 申请主存时，会停止 CPU 对主存的访问，<br>
优点：<br>
<br>此方法控制简单<br>
缺点：
<br>无法发挥 CPU 对主存的利用率
<br>——DMA 和 CPU 交替访存<br>
将一个 CPU 周期分为两个部分，第一个部分专供 DMA 使用，第二个部分专供 CPU 使用<br>
优点：<br>
<br>不需要进行总线使用权的申请、建立和归还<br>
缺点：
<br>硬件逻辑过于复杂，DMA 对主存的访问频率要比 CPU 要低，还是无法发挥 CPU 对主存的利用率<br>
——周期挪用<br>
DMA 访问主存时有三种情况
<br>CPU 此时不访存
<br>CPU 此时正在进行访存【在存取周期结束之后让出总线】
<br>CPU 和 DMA 同时申请访存【DMA 优先进行访存】
]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\7.2：io接口.html</link><guid isPermaLink="false">review/计算机组成原理/7.输入输出系统/7.2：IO接口.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 17 May 2025 09:06:04 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{1f7be879-92ea-444c-a508-1d4876249e02}.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\{1f7be879-92ea-444c-a508-1d4876249e02}.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7.1：IO系统基本概念]]></title><description><![CDATA[ 
 <br><br>IO 接口：又称为 IO 控制器、设备控制器，负责协调主机与外部设备之间的数据传输<br>
<img alt="Pasted image 20250516202542.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516202542.png"><br>
CPU 控制键盘 IO 的方式：<br>
<br>
程序查询方式，CPU 不断轮询 IO 控制器中的状态寄存器，检测到状态为已完成之后再从数据寄存器中拿数据

<br>
中断方式：等待键盘 IO 时，CPU 可以先去执行其他程序，键盘 IO 完成之后 IO 控制器向 CPU 发出中断请求，CPU 从数据寄存器中取走数据

<br><br>对于快速 IO 设备，例如磁盘等，会通过 DMA 总线与主存连接，CPU 向 DMA 接口发送读/写指令，并指明主存地址、磁盘地址、读写数据量等参数<br>
当 DMA 接收到指令之后，自动控制磁盘与主存的读写，每完成一整块数据的读写，才向 CPU 发出中断请求<br>
<img alt="Pasted image 20250516203930.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516203930.png"><br><br><img alt="Pasted image 20250516204259.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516204259.png"><br>
就是相当于通道是 CPU 的代理，代替 CPU 与 IO 设备进行交互<br>
<img alt="Pasted image 20250516204418.png" src=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516204418.png"><br><br>驱动程序、用户程序、用户程序、管理程序、设备补丁等<br>
IO 指令<br>
IO 指令是指令的一部分<br>
操作码 | 命令码 | 设备码<br>
操作码指明 CPU 要对 IO 接口做什么<br>
命令码指明 IO 接口要对 IO 设备做什么<br>通道程序<br>
通道程序提前编制好放在主存中，CPU 通过执行 IO 指令对通道发出命令，由通道执行一系列通道指令，代替 CPU 对 IO 设备进行管理]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\7.1：io系统基本概念.html</link><guid isPermaLink="false">review/计算机组成原理/7.输入输出系统/7.1：IO系统基本概念.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 17 May 2025 06:05:13 GMT</pubDate><enclosure url=".\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516202542.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.\https:\\cs-note-three.vercel.app\review\计算机组成原理\7.输入输出系统\img\pasted-image-20250516202542.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SRAM与DRAM]]></title><description><![CDATA[ 
 <br><br>
<br>主存由DRAM实现，Cache由SRAM实现
<br>SRAM【随即静态存储器】的存储单元是双稳态触发器，非破坏性读出，存取速度快，但是集成度低功耗大
<br>DRAM的存储单元是栅极电容的采用的是地址复用技术地址线为原来的一半
<br><br>行列地址复用：假设你的存储器容量是16bit，那么可以将这16个比特组织成一个4*4的矩阵，为了找到某个你想要找的bit，比如第1行第2列的那个bit。你先发送二进制的01，表示要找的数据在第1行；接着发送二进制的10，表示要找的数据在第2列。这样一来你就找到了第1行第2列的那个bit。可以发现只要两根地址线就能寻找16个bit了，但是要发送两次地址（一次行地址，一次列地址）‍<br>行列独立：同样的16bit存储器，这16个bit不是组织成一个矩阵，而是一个数组，标号0~15，所以需要四根地址线来寻找，譬如要找第12个bit，你发送地址线信号1100就能找到。可以发现行列独立的地址线数量比行列地址复用要多，但是地址数据只要一次就能传输完成。<br>DRAM一般使用行列地址复用技术，而SRAM一般使用行列独立技术。<br><br>DRAM 普遍采用的是行与列地址分时复用技术进行寻址。在 DRAM 的矩阵存储单元中，地址可以分成行地址和列地址。在寻址时，必须先进行行寻址然后在进行列寻址，这是由 DRAM 的硬件电路所决定的。所以，对行地址线和列地址线进行共用，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可。既节省了地址线，也不会降低 DRAM 原有的工作速率（因为 DRAM 的行地址和列地址就是要分时传送的）。<br>如果是 SRAM 采用这种寻址方式的话，则会大大降低其工作速度。Cache多为SRAM，存储单元是线性排列，不像DRAM那样分行列，所以不适用行列地址线复用方式。不过说到底是因为Cache就是为了快才存在的，容量又小，所以SRAM也用得起。<br><br>DRAM为什么需要刷新?<br>
由于DRAM结构的特殊性，电容中的电荷会随时间流出，所以在一定的时间间隔内需要对存储单元中的电荷进行补充
<br>
<br>DRAM的刷新时间为2ms，以行为单位需要行地址,每次刷新一行存储单元
<br>刷新方式分为两种：<br>
- 分散刷新：前一半读写，后一半刷新。优点：没有死区；缺点：增加了系统的存取周期<br>
- 集中刷新：有专门的时间进行在刷新。优点：读写不受刷新影响，缺点：有死区<br>
- 异步刷新：隔一段集中读写时间进行刷新一次，既可以缩短死区，又可以充分利用刷新时间

DRAM刷新死区（Refresh Dead Time） 是指在进行刷新操作时，DRAM无法响应正常读写请求的时间段。在这段时间内，内存控制器必须暂停所有其他访问操作，导致系统内存带宽暂时性损失，表现为延迟增加或吞吐量下降。


<br><br>ROM具有结构简单，可靠性高等特点<br>
容量1024x8bit，前1024表示存储单元个数，用10根线表示，后8bit表示存储单元的字节]]></description><link>.\https:\\cs-note-three.vercel.app\review\计算机组成原理\sram-dram.html</link><guid isPermaLink="false">review/计算机组成原理/SRAM DRAM.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 08 May 2025 11:29:55 GMT</pubDate></item><item><title><![CDATA[Kmp 算法的组成]]></title><description><![CDATA[ 
 <br><br>Kmp 算法由 getnext 和 kmp 算法本身构成<br><br>void get_next(chat *p,int *next)
{
	int k=-1,j=0;
	next[0] = -1;
	int len = strlen(p);
	while(j&lt;len-1)
	{
		if(k==-1||p[j]==p[k])
		{
			k++;
			j++;
			next[j] = k;
		}
		else
		{
			k = next[k];
		}
	}
}

int KMP(char *S,char *T)
{
	//申请对应模式串长度的数组
	int *next = (int *)malloc(sizeof(int)*strlen(T));
	int len1 = strlen(S);
	int len2 = strlen(T);
	int i=0,j=0;
	//获取next数组
	get_next(T,next);
	while(i&lt;len1&amp;&amp;j&lt;len2)
	{
		if(j==-1||S[i]==T[j])//分别表示模式串需要从头匹配或者当前匹配上
		{
			i++;
			j++;
		}
		else
		{
			j = next[j];
		}
	}
	if(j==len2)//检查是否匹配到模式串的尾部
		return i-j;  //返回对应匹配上的首部位置
	else
		return -1;  //返回-1，表示没有匹配上
}

]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\代码题\kmp算法.html</link><guid isPermaLink="false">review/数据结构/代码题/Kmp算法.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Fri, 30 May 2025 09:29:37 GMT</pubDate></item><item><title><![CDATA[滑动窗口]]></title><description><![CDATA[ 
 <br><br>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组&nbsp;fruits&nbsp;表示，其中&nbsp;fruits[i]&nbsp;是第&nbsp;i&nbsp;棵树上的水果&nbsp;种类&nbsp;。<br>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：<br>
<br>你只有&nbsp;两个&nbsp;篮子，并且每个篮子只能装&nbsp;单一类型&nbsp;的水果。每个篮子能够装的水果总量没有限制。
<br>你可以选择任意一棵树开始采摘，你必须从&nbsp;每棵&nbsp;树（包括开始采摘的树）上&nbsp;恰好摘一个水果&nbsp;。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
<br>给你一个整数数组&nbsp;fruits&nbsp;，返回你可以收集的水果的&nbsp;最大&nbsp;数目。<br>示例 1：<br>输入： fruits = [1,2,1]<br>
输出： 3<br>
解释： 可以采摘全部 3 棵树。<br>示例 2：<br>输入： fruits = [0,1,2,2]<br>
输出： 3<br>
解释： 可以采摘 [1,2,2] 这三棵树。<br>
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。<br>示例 3：<br>输入： fruits = [1,2,3,2,2]<br>
输出： 4<br>
解释： 可以采摘 [2,3,2,2] 这四棵树。<br>
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。<br>示例 4：<br>输入： fruits = [3,3,3,1,2,1,1,2,3,3,4]<br>
输出： 5<br>
解释： 可以采摘 [1,2,1,1,2] 这五棵树。<br>代码思想：滑动窗口<br>class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        unordered_map&lt;int, int&gt; mp;
        int left = 0, right = 0;
        int res = 0;
        for(; right &lt; fruits.size(); ++right){
            mp[fruits[right]]++;
            while(mp.size() &gt; 2){
                mp[fruits[left]]--;
                if(mp[fruits[left]] == 0) mp.erase(fruits[left]);
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};
<br>
使用 map 对当前选择的水果种类进行记录, 如果此时哈希表中的长度超过 2, 则说明当前水果的种类超过 2, 则需要对左端进行移动, 如果对应位置上的数值变为 0 的话, 则需要进行擦除操作, 并且更新当前能选择的最多种类的水果
<br><br>给你字符串&nbsp;s&nbsp;和整数&nbsp;k&nbsp;。<br>请返回字符串&nbsp;s&nbsp;中长度为&nbsp;k&nbsp;的单个子字符串中可能包含的最大元音字母数。<br>英文中的&nbsp;元音字母&nbsp;为（a,&nbsp;e,&nbsp;i,&nbsp;o,&nbsp;u）。<br>示例 1：<br>输入： s = "abciiidef", k = 3<br>
输出： 3<br>
解释： 子字符串 "iii" 包含 3 个元音字母。<br>示例 2：<br>输入： s = "aeiou", k = 2<br>
输出： 2<br>
解释： 任意长度为 2 的子字符串都包含 2 个元音字母。<br>示例 3：<br>输入： s = "leetcode", k = 3<br>
输出： 2<br>
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。<br>示例 4：<br>输入： s = "rhythms", k = 4<br>
输出： 0<br>
解释： 字符串 s 中不含任何元音字母。<br>示例 5：<br>输入： s = "tryhard", k = 4<br>
输出： 1<br>提示：<br>
<br>1 &lt;= s.length &lt;= 10^5
<br>s&nbsp;由小写英文字母组成
<br>1 &lt;= k &lt;= s.length
<br>
class Solution {
public:
    bool check(char s)
    {
        if(s=='a'||s=='e'||s=='i'||s=='o'||s=='u')
            return true;
        else
            return false;
    }
    int maxVowels(string s, int k) {
        int cnt = 0,res = 0;
        for(int i=0;i&lt;s.length();i++)
        {
            if(check(s[i]))
            {
                cnt++;
            }
            res = res&gt;cnt?res:cnt;
            if(res == k)
                return res;
            if(i&lt;k-1)
                continue;   //一直循环直到定长窗口大小
            if(check(s[i-k+1]))
                cnt--;
        }
        return res;
    }
};

<br>
对于定长的滑动窗口的题目, 算法本身维护的是 k-1 个长度的窗口, 当后面移入窗口的元素满足条件时, 更新当前结果, 然后移动窗口, 首先先移动窗口尾部, 查看移除的元素是否满足条件, 如果满足条件则将当前记录的结果--, 反之在不变, 然后移动窗口头部, 如果移入的元素满足条件, 则将当前记录的结果++, 更新最大的结果
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\代码题\滑动窗口.html</link><guid isPermaLink="false">review/数据结构/代码题/滑动窗口.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 30 Apr 2025 21:56:44 GMT</pubDate></item><item><title><![CDATA[静态链表]]></title><description><![CDATA[ 
 <br>静态链表是用数组来表述的数据结构<br><br>上述静态链表表示的就是a-&gt;b-&gt;c-&gt;d的链表<br>
<br>与链表不同的是，next存储的是数据在数组中存储的相对位置，而不是指向内存中的实际位置
<br>和顺序表一样，静态链表也需要在内存中提前申请一段连续的空间
<br>静态链表以next=-1作为链表的结尾
<br>静态链表在插入删除等操作时与链表的操作基本相似
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\静态链表.html</link><guid isPermaLink="false">review/数据结构/线性表/静态链表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 12:01:04 GMT</pubDate></item><item><title><![CDATA[顺序表]]></title><description><![CDATA[ 
 <br>线性表是由相同数据类型的n(n&gt;=0)个元素的有限序列<br><br><br>#define MAX_SIZE 10

typedef struct LinearList{
    int data[MAX_SIZE];	 //使用连续的数组表示线性表
    int length;			//表示线性表的长度
}SQlist;
<br><br>void InitSQlist(Sqlist &amp;L)
{
    L.data = (int*)malloc(sizeof(SQlist)*MAX_SIZE);		//向内存中申请空间
    L.length = 0;					//初始化长度为0
}
<br><br>bool InsertList(SQlist &amp;L,int pos,int data)
{
    //判断插入的位置是否合法,顺序表数组下表从0开始
    if(pos&lt;1||pos&gt;L.length+1)
        return false;
    if(L.length&gt;=MAX_SIZE)
        return false;		//顺序表中已满
    for(int i=L.length;i&gt;=pos;i--)
        L.data[i] = L.data[i-1];		//将元素往后移
    L.data[i] = data;					//将要插入的元素插入到指定位置
    L.length++;
    return true;
}
<br>分析：<br>最好情况：插入的位置在表尾，插入之后不需要移动，时间复杂度为O(1)<br>最坏情况：插入的位置在表头，插入之后需要移动整个表长，时间复杂度为O(n)<br>平均时间复杂度：每个位置出现的概率为1/n,按照各个位置出现的情况求解其期望，为n/2,既平均时间复杂度为O(n)<br>顺序表的删除操作<br>bool DeleteList(SQlist &amp;L,int pos,int &amp;e)
{
    if(pos&lt;1||pos&gt;L.length)
        return false;
    e = L.data[pos-1];		//将删除的元素的值赋给e
    for(int i = pos;i&lt;L.length;i++)
        L.data[i-1] = L.data[i];		//调整后面的顺序表，将删除的空位补齐
    L.length--;
    return true;
}
<br>分析：<br>最好情况：删除的为表尾的元素，需要移动的元素为0个，此时时间复杂度为O(1)<br>最坏情况：删除的为表头的元素，需要移动的元素为n-1，时间复杂度为O(n)\<br>平均情况：与插入操作的平均情况相同，求和之后时间复杂度为O(n)<br><br>int SearchByElem(SQlist &amp;L,int elem)
{
    for(int i=0;i&lt;L.length;i++){
        if(L.data[i] == elem)
            return i+1;			//数组下标从0开始，实际元素的位置为i+1
    }
    return 0;			//查找失败
}
<br>分析：<br>最坏情况：查找的元素在表尾，需要比较n次，则时间复杂度为O(n)<br>最好情况：查找的元素在表头，需要比较1次，时间复杂度为O(1)<br>平均情况：同上，求和之后为O(n)<br><br>int SearchByPos(SQlist &amp;L,int pos)
{
    if(pos&lt;1||pos&gt;L.length)
        return 0;	//传入的位置不合法，退出函数
    return L.data[pos-1];		//返回对应位置的元素
}
<br>分析：<br>顺序表可以随机存取，则时间复杂度为O(1)]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\顺序表.html</link><guid isPermaLink="false">review/数据结构/线性表/顺序表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 12:35:15 GMT</pubDate></item><item><title><![CDATA[线性表]]></title><description><![CDATA[ 
 <br>链表<br>
顺序表和链表的相互比较<br>
<br>读写方式<br>
顺序表可以顺序读取，也可以随机读取，链表只能从头开始依次顺序访问
<br>逻辑结构与物理结构<br>
顺序表逻辑相邻的元素在物理上一定相邻，链表在逻辑上相邻的元素在物理上不一定相邻，链表的逻辑结构是通过链指针来表示其中关系的
<br>查找、插入、和删除结构<br>
按值查找，若元素无序，顺序表和链表的时间复杂度都为 O(n)，但是如果是有序的元素，顺序表可以使用折半查找，时间复杂度为 O(log2n)，对于按序查找，顺序表可以进行随机存取，时间复杂度为 O(1)，链表的时间复杂度为 O(n)，顺序表的插入和删除操作平均都需要移动半个表的元素，链表的插入删除操作不需要移动元素，所以时间复杂度为 O(1)
<br>空间分配<br>
对于线性表来说，在初始化的时候已经分配好了空间，如果空间不足，则可以继续向内存中申请需要的连续空间，
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\线性表.html</link><guid isPermaLink="false">review/数据结构/线性表/线性表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:01:24 GMT</pubDate></item><item><title><![CDATA[循环链表]]></title><description><![CDATA[ 
 <br><br>与单链表的区别<br>
<br>与单链表不同的是循环单链表最后一个元素会有一个指针指向头节点
<br>既最后一个节点的next不再为NULL，而是指向head
<br>可以用指针指向任意位置实现对循环链表的遍历
<br><br><br><br>与双向链表的区别<br>
<br>头部指针的prior指针有一个指针指向最后一个节点
<br>尾部指针的next指针指向头节点head
<br><br>]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\循环链表.html</link><guid isPermaLink="false">review/数据结构/线性表/循环链表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 11:37:09 GMT</pubDate></item><item><title><![CDATA[双向链表]]></title><description><![CDATA[ 
 <br><br>typedef struct DNode{
	int val;        //数据域
	struct DNode *next,*prior;        //指针域，指向前一个节点和后一个节点
}DNode,*DLinklist;
<br><br>bool Insert(DLinklist &amp;DL,int pos,int data)
{
	//首先找到指定位置
	DNode *p = DL;
	int i=0;
	while(i&lt;pos-1&amp;&amp;p)
	{
		p = p-&gt;next;
		i++;
	}
	//判断当前节点是否为空
	if(p==NULL)
		return false;
	DNode *temp = (DNode *)malloc(sizeof(DNode));
	temp-&gt;val = data;
	temp-&gt;next = NULL;
	temp-&gt;prior = NULL;
	//先将当前节点和后面的节点相连接，再将当前节点和前面的节点相连接
	temp-&gt;next = p-&gt;next;
	p-&gt;next-&gt;prior = temp;
	tmep-&gt;prior = p;
	p-&gt;next = tmep;
}
<br><br>bool DeleteNode(DLinkList &amp;DL,int pos)
{
	//首先找到指定位置
	DNode* p = DL;
	int i=0;
	while(i&lt;pos-1&amp;&amp;p)
	{
		p = p-&gt;next;
		i++;
	}
	if(p==NULL)
		return false;
	DNode* q = p-&gt;next;
	p-&gt;next = q-&gt;next;
	q-&gt;next-&gt;prior = p;
	free(q)
}
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\双向链表.html</link><guid isPermaLink="false">review/数据结构/线性表/双向链表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 11:17:57 GMT</pubDate></item><item><title><![CDATA[单链表]]></title><description><![CDATA[ 
 <br><br>typedef struct LNode{
    int data;
    LNode *next;
}LNode,*LinkList;
<br><br>void InitList(LinkList &amp;L)
{
	L = (*LNode)malloc(sizeof(LNode));
    L-&gt;next = NULL;
}
<br><br>int Length(LinkList &amp;L)
{
    int length = 0;
    LNode *P = L;
    while(p-&gt;next){		//如果单链表为不带头节点的则将条件修改为while(p)
        length++;
        p = p-&gt;next;
    }
    return length;
}
<br>分析：<br>求解单链表的长度的时间复杂度为O(n) <br><br>int GetElem(LinkList &amp;L,int pos)
{
    LNode *p = L;
    int i=0;
    while(p&amp;&amp;i&lt;pos)
    {
        j++;
        p = p-&gt;next;
    }
    return p-&gt;data;
}
<br>分析：<br>查找的时间复杂度为O(n)<br><br>LNode *GetElem(LinkList &amp;L,int value)
{
    LNode *p = L-&gt;next;
    while(p&amp;&amp;p-&gt;data!=value)
		p = p-&gt;next;
    return p;
}
<br>分析：<br>按值查找时间复杂度为O(n)<br><br>bool ListInsert(LinkList &amp;L,int pos,int value)
{
    LNode *p = L;
    int i=0;
    while(p&amp;&amp;i&lt;pos-1)		//需要找到插入位置的前一个节点位置
    {
        p = p-&gt;next; 
        i++;
    }
    if(p=NULL)
        return false;		//如果找到的位置为空，那么说明插入的位置不合法
    LNode *temp = (LNode *)malloc(sizeof(LNode));
    temp-&gt;data = value;
    temp-&gt;next = NULL;
    temp-&gt;next = p-&gt;next;
    p-&gt;next = temp;
    return true;
}
<br>分析；<br>插入算法的时间复杂度为O(n)<br>如果指针指向的位置正好是要数据要插入的位置怎么办<br>可以实现先往后插入，然后将两个节点的数据进行交换<br>/*
注意此时的指针p指向的位置为pos
*/
temp-&gt;next = p-&gt;next;
p-&gt;next = temp;
int t = temp-&gt;data;
tmep-&gt;data = p-&gt;data;
p-&gt;data = t;
<br><br>bool ListDelete(LinkList &amp;L,int pos,int &amp;e)
{
    LNode *p = L;
    int i=0;
    while(p&amp;&amp;i&lt;pos-1)
    {
        p = p-&gt;next;
        i++;
    }
    if(p-&gt;next = NULL||i&gt;pos-1)				//插入的位置不合法
        return false;
    LNode *q = p-&gt;next;
    p-&gt;next = p-&gt;next-&gt;next;
    free(q);
    return true;
}
<br>分析：<br>删除操作的时间复杂度为O(n)<br><br>LinkList List_HeaderInsert(LinkList &amp;L,int data)
{
    LNode *temp = (LNode*)malloc(sizeof(Lnode));
    temp-&gt;data = data;
    temp-&gt;next = NULL;
    LNode *p = L;
    tmep-&gt;next = p-&gt;next;
    p-&gt;next = tmep;
    return L;
}
<br>分析：<br>若插入一个元素时，时间复杂度为O(1)，若构建整个链表，则时间复杂度为O(n)<br><br>LinkList List_TailInsert(LinkList &amp;L,int data)
{
	LNode *p = L;
	while(L-&gt;next)
	{
		p=p-&gt;next;
	}
	LNode *temp = (LNode *)malloc(sizeof(LNode));
	temp-&gt;next = NULL;
	temp-&gt;data = data;
	p-&gt;next = temp;
	return L;
}
<br>分析：<br>由于每次构建表都需要将指针指向链表的最后一个元素，所以时间复杂度为O(n)]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\线性表\单链表.html</link><guid isPermaLink="false">review/数据结构/线性表/单链表.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 11:30:21 GMT</pubDate></item><item><title><![CDATA[链队列]]></title><description><![CDATA[ 
 <br>链队列的操作可以参照单链表对应的插入和查找删除操作<br><br>链循环队列的操作可以参考循环链表的操作]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\队列\链队列.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/队列/链队列.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:02:10 GMT</pubDate></item><item><title><![CDATA[双端队列]]></title><description><![CDATA[ 
 <br>双端队列就是可以在两端进行操作的线性表，双端队列的两端是平等的，为了方便理解，把队列的左端称为前端，队列的右端称为后端<br><br>队列的插入、删除<br>
双端队列可以在两端进行插入和删除操作<br><br>对于受限制的双端队列的操作，规定只能从一端进行压入操作，或者只能从一端进行删除操作]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\队列\双端队列.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/队列/双端队列.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 10 Apr 2025 09:16:41 GMT</pubDate></item><item><title><![CDATA[循环队列]]></title><description><![CDATA[ 
 <br>为了解决顺序队列的假溢出问题，循环队列产生了<br>
循环队列的本质还是顺序队列<br>
此时需要在插入和删除之后指针的移动上动手脚<br>
<br>初始化：Q.rear = Q.front = 0
<br>插入：队尾指针进1：Q.rear = (Q.rear+1)%MAX_SIZE
<br>删除：队首指针进1：Q.front = (Q.front+1)%MAX_SIZE 
<br>队列长度：(Q.rear-Q.front+MAX_SIZE)%MAX_SIZE
<br><br>当队列中元素为空时，此时由Q.rear == Q.front，但是是否Q.front == Q.rear时队列就为空呢，西安然不是的，当循环队列中元素满时，此时也有Q.rear == Q.front<br>为了区分这种情况，我们有三种处理方式<br><br>牺牲一个存储单元<br>
<br>队满条件：(Q.rear+1)%MAX_SIZE == Q.front，牺牲一个存储单元之后，最后队尾指针指向的队尾元素的下一个位置为一开始预留的空位置
<br>队空条件：Q.front == Q.rear
<br>队列中的元素：(Q.rear-Q.front+MAX_SIZE)%MAX_SIZE
<br><br>设置一个size成员、<br>
插入成功size+1，删除成功size-1，如果最终Q.rear == Q.front，若由size == MAX_SIZE，此时队满，否则队空<br><br>设置一个tag<br>
若最终为删除成功的操作，将tag置为0，此时Q.rear == Q.front表示的是队空<br>
若最终为插入成功的操作，将tag置为1，此时Q.rear == Q.front表示的是队满]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\队列\循环队列.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/队列/循环队列.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 13:09:42 GMT</pubDate></item><item><title><![CDATA[顺序队列]]></title><description><![CDATA[ 
 <br>队列的顺序存储，具体数据结构如下<br>typedef struct{
	ElemType data[MAX_SIZE];
	int front,rear;
}SqQueue;
<br>
<br>初始化：Q.front = Q.rear = 0
<br>入队：送值到队尾，队尾指针+1，所以队尾指针始终指向队尾元素的下一个位置
<br>出队：取队首的值，队首指针+1，所以队首指针指向的位置是队首元素的位置
<br>队列判满：在进行判满操作时，不能仅仅看Q.rear是否指向MAX_SIZE,因为可能队首可能删除了一些元素
<br>判空：如果Q.rear == Q.front，此时队列为空
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\队列\顺序队列.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/队列/顺序队列.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 12:52:35 GMT</pubDate></item><item><title><![CDATA[队列]]></title><description><![CDATA[ 
 <br>队列是一种一端操作受限制的线性表结构<br>
<br>队列分为顺序队列、链队列、循环队列、双端队列
<br>队列是一端操作受限制的一种线性数据结构，其具体表现为，一端只能读取、另一端只能写入
<br>队列中元素的基本特征、FIFO（first in first out）
<br>队头：Front，这端只允许被删除
<br>队尾：Rear，这端只允许被插入 
<br>空队列：不含任何元素的空表
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\队列\队列.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/队列/队列.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:01:59 GMT</pubDate></item><item><title><![CDATA[数组]]></title><description><![CDATA[ 
 <br>数组是由一系列相同类型的数据元素构成的有限序列一般来说这些数组下标一般从0开始<br>
一维数组是从0开始的一端连续空间<br>
二维数组是逻辑上是二维的，但是实际山存储的是一维连续的空间上存储的，计算机可以通过数组下标计算出来对应二维数组下标位置的地址<br><br><br>如果对于二维矩阵来说关于对角线对称的元素都是相等的话，那么就可以仅存储一般的数组内容，进而节省空间，对于另一半的内容可以通过计算得到<br>
对于二维数组a[n]  [n]和a [0...n-1]  [0...n-1]是等价的<br><br><br>对于下三角的元素都一样，那么就可以只存储上半三角矩阵的元素，可以通过计算得到对应位置在一维数组中的位置<br><br>对于上三角矩阵跟下三角矩阵是一样的，都是将对应相同的那一边的三角压缩存储，也可以计算的到对应在一位数组中的位置<br><br>对应在矩阵中只有中间三行存储元素，其余位置不存储元素，通过按照一行一行的看可以发现规律，除了第一行和最后一样其余每行都是三个元素，所以可以通过计算得到对应位置在一位数组中的坐标<br><br>对于稀疏矩阵来说，矩阵中存储的元素的个数比较少，并且没有任何规律，所以一般采用三元组的形式来进行存储，三元组存储的分别是，非0元素的横坐标、纵坐标、对应非0值]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\数组\数组.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/数组/数组.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 12 Apr 2025 03:07:45 GMT</pubDate></item><item><title><![CDATA[中缀表达式转后缀表达式]]></title><description><![CDATA[ 
 <br><br>
<br>如果遇到操作数，直接加入后缀表达式，入栈
<br>如果遇到操作符，若为"("，那么直接入栈，如果遇到“)”，则不入栈，并且依次弹出栈中的运算符，直到遇到"("为止，并且直接删除“(”。
<br>遇到运算符，如果其优先级高于栈顶的优先级，或者栈顶为“(”，则直接入栈
<br>如果其优先级低于或等于栈顶的优先级，以此弹出栈中的运算符并且加入后缀表达式，直到遇到优先级低于当前运算符或者遇到“(”
<br>//中缀表达式转后缀
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;stack&gt;

using namespace std;

int prio(char op) {                 //给运算符优先级排序
	int priority;
	if (op == '*' || op == '/')
		priority = 2;
	if (op == '+' || op == '-')
		priority = 1;
	if (op == '(')
		priority = 0;
	return priority;
}

bool Trans(string &amp;str,string &amp;str1) {   //引用传递
	stack&lt;char&gt; s;                   //定义一个char类型的栈s
	int i;
	for (i = 0; i&lt;str.size(); i++) {
		if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {    //如果是数字，直接入栈
			str1+=str[i];
		}
		else {                        //否则不是数字
			if (s.empty())            //栈空则入站
				s.push(str[i]);
			else if (str[i] == '(')   //左括号入栈
				s.push(str[i]);
			else if (str[i] == ')') {  //如果是右括号，只要栈顶不是左括号，就弹出并输出
				while (s.top() != '(') {  
					str1+= s.top();
					s.pop();
				}
				s.pop();                 //弹出左括号，但不输出
			}
			else {
				while (prio(str[i]) &lt;= prio(s.top())) { //栈顶优先级大于等于当前运算符，则输出
					str1+= s.top();
					s.pop();
					if (s.empty())      //栈为空，停止
						break;
				}
				s.push(str[i]);   //把当前运算符入栈
			}
		}
	}
	while (!s.empty()) {      //最后，如果栈不空，则弹出所有元素并输出
		str1+= s.top();
		s.pop();
	}
	return true;
}

int main() {                //主程序
	string infix;
	string postfix;
	cout &lt;&lt; "请输入中缀表达式：" &lt;&lt; infix &lt;&lt; endl;
	cin &gt;&gt; infix;
	Trans(infix,postfix);
	cout &lt;&lt; "后缀表达式为：" &lt;&lt; postfix &lt;&lt; endl;
	return 1;
}
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\应用\中缀表达式转后缀表达式.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/应用/中缀表达式转后缀表达式.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:02:40 GMT</pubDate></item><item><title><![CDATA[算术表达式求值]]></title><description><![CDATA[ 
 <br>栈在算数表达式求值中的应用<br>
在面对算数表达式求值的过程中，需要用到数栈<br>
<br>首先将算术表达式转换为后缀表达式在进行操作
<br>如果遇到的是操作数那么就将其压入操作数栈中
<br>如果遇到的是操作符，那么就取出两个操作数，将其运算之后将其压入操作数栈中
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\应用\算术表达式求值.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/应用/算术表达式求值.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:02:37 GMT</pubDate></item><item><title><![CDATA[括号匹配算法]]></title><description><![CDATA[ 
 <br>栈在括号匹配中的使用<br><br>
<br>初始化一个空栈，按照顺序读取传入的字符串
<br>如果读取的是左括号，那么就将其压入栈中
<br>如果是右括号，查看其是否与栈顶的左括号相匹配
<br>如果匹配，那么就将栈顶的括号弹出，继续向后读取括号重复步骤2之后的步骤
<br>如果不匹配，那么就退出程序
<br>#include&lt;iostream&gt;
#include&lt;stack&gt;
 
using namespace std;
 
bool left(char s) {
    return s=='(' || s=='{' || s=='[';
}
bool right(char s) {
    return s==')' || s=='}' || s==']';
}
bool check(char a,char b) {
    return (a=='(' &amp;&amp; b==')') || (a=='{' &amp;&amp; b=='}') || (a=='[' &amp;&amp; b==']');
}
 
bool match(string s)
{
    stack&lt;char&gt; p;
    for(int i=0; i&lt;s.size(); i++)
    {
       if(left(s[i])) {
           p.push(s[i]);
       }else if(right(s[i])) {
           if(!p.empty() &amp;&amp; check(p.top(),s[i])) { //栈不空，且匹配正确
               p.pop();
           } else {
               return false; //不匹配，直接返回false
           }
       }
 
    }
    if(!p.empty()) return false; //栈不空，说明存在没有匹配的左括号，返回false
    return true; //全都匹配成功
}
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\应用\括号匹配算法.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/应用/括号匹配算法.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:02:32 GMT</pubDate></item><item><title><![CDATA[共享栈]]></title><description><![CDATA[ 
 <br>共享栈利用栈底不变的特性，可以让两个栈共享一个数组空间<br><br>设上述数组的长度为MAX_SIZE<br>
<br>判断栈空：S1.top == -1 &amp;&amp; S2.top == MAX_SIZE
<br>判断栈满：S2.top-S1.top == 1 (表示两个栈之间只相差1)
<br>共享栈的是为了更好的利用空间，两个站的空间可以自由调节]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\栈\共享栈.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/栈/共享栈.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 09 Apr 2025 12:26:42 GMT</pubDate></item><item><title><![CDATA[链栈]]></title><description><![CDATA[ 
 <br>栈中元素采用链式存储称为链栈<br>
数据结构描述如下<br>typedef struct LinkStack{
	ElemType data;
	struct LinkStack *next;
}ListStack;
<br>对于链栈的压栈、出栈、获取栈顶元素的算法可以参考前面单链表的插入、删除、查找算法]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\栈\链栈.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/栈/链栈.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:02:48 GMT</pubDate></item><item><title><![CDATA[顺序栈]]></title><description><![CDATA[ 
 <br><br><br>由顺序表结构构成<br>typedef struct{
	Elemtype data[MAX_SIZE];
	int top;
}SqStack;
<br>栈顶指针，初始化为top = -1;<br>
入栈操作：S.data[++S.top] = data<br>
出栈操作：e = S.data[S.top--]<br>
栈空操作：S.top = -1<br>
栈满条件：S.top = MAX_SIZE-1<br><br>void InitStack(SqStack $S)
{
	S.top = -1;
}
<br><br>bool StackEmpty(SqStack &amp;S)
{
	//判断top指针是否指向-1
	return (S.top==-1);
}
<br><br>void Push(SqStack &amp;S,int data)
{
//判断栈是否满
	if(S.top==MAX_SIZE-1)
		return false;
	S.data[++S.top] = data;
	return true;
}
<br><br>bool Pop(SqStack &amp;S,EleType &amp;e)
{
//判断栈是否为空
	if(S.top == -1)
		return false;
	e = S.data[S.top--];
	return true;
}
<br><br>bool GetTop(SqStack &amp;S,ElemType &amp;e)
{
	if(S.top == -1)
		return false;
	e = S.data[S.top]
	return true;
}
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\栈\顺序栈.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/栈/顺序栈.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:03:37 GMT</pubDate></item><item><title><![CDATA[栈]]></title><description><![CDATA[ 
 <br>栈是只允许在一端操作的顺序栈或链栈，但是这个线性表限定只能在一端进行插入和删除<br>
<br>栈顶：线性表允许被插入和删除的一端
<br>栈底：固定的，不允许被插入和删除的一端
<br>空栈：不含任何元素的空表
<br>公式：当n个不同的元素进行入栈操作，出栈的元素顺序有<br>]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\栈、队列、数组\栈\栈.html</link><guid isPermaLink="false">review/数据结构/栈、队列、数组/栈/栈.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Wed, 16 Apr 2025 11:03:03 GMT</pubDate></item><item><title><![CDATA[1：绪论]]></title><description><![CDATA[ 
 <br><br><br>
<br>逻辑结构
<br>存储结构
<br>数据的运算
<br>数据的逻辑结构独立其存储结构【对于线性表来说，逻辑结构是线性结构，但是存储结构可以为顺序存储结构还可能是链式存储结构】<br>数据的逻辑结构分为四种：<br>
<br>线性结构 
<br>集合
<br>树形结构
<br>图
<br>数据的存储结构分为四种：【存储结构不能独立逻辑结构存在】<br>
<br>顺序存储【线性表】
<br>链式存储【链表】
<br>散列存储【哈希表】
<br>索引存储【索引表】——在存储数据的同时还维护一张索引表
<br><br>算法的五个特性：<br>
<br>有穷性——算法需要在有穷个步骤之后结束，每个步骤需要在有穷的时间内结束
<br>确定性——算法的每一步的指令需要由明确的意义，相同的输入需要有相同的输出
<br>可行性——算法的操作需要由已经实现的基本运算执行有限次来实习
<br>输入——算法有0个或多个输入
<br>输出——算法有1个或多个输出
<br>算法需要达到的目标：<br>
<br>正确性——算法需要正确的解决问题
<br>可读性——算法要有良好的可读性
<br>健壮性——算法需要对非法的输入进行一定的处理，不会产生莫名其妙的输出
<br>高效率和低存储需求——需要有较低的时间和空间复杂度
<br><br>//下面算法的时间复杂度是
int sum = 0;
for(int i=0;i&lt;n;i*=2){
    for(int j=0;j&lt;i;j++)
        sum++;
}
	
/*
设第一层循环第i次的取值为t[i]，则下层循环每次执行t[i]次
		而t[i] = 2^i &lt; n &lt;= 2^(i+1)
则内层循环的次数为sum(t[i])
	对t[i]求和可知t[i]为首项为1，公比为2的等比数列
	对其求和可知内层循环的次数为T = 2^(i+1)-1
		T &lt; 2n-1
	综上可知循环的总次数T &lt; 2n-1
那么上算法的时间复杂度为O(n)
*/
]]></description><link>.\https:\\cs-note-three.vercel.app\review\数据结构\1：绪论.html</link><guid isPermaLink="false">review/数据结构/1：绪论.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Sat, 24 May 2025 07:29:30 GMT</pubDate></item><item><title><![CDATA[程序在内存中的分布]]></title><description><![CDATA[ 
 <br><br>上述是 C 语言中各部分存储的数据]]></description><link>.\https:\\cs-note-three.vercel.app\review\程序在内存中的分布.html</link><guid isPermaLink="false">review/程序在内存中的分布.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 22 May 2025 12:50:31 GMT</pubDate></item><item><title><![CDATA[review]]></title><description><![CDATA[ 
 <br><br><br>{以下是 Gitee 平台说明，您可以替换此简介<br>
Gitee 是 OSCHINA 推出的基于 Git 的代码托管平台（同时支持 SVN）。专为开发者提供稳定、高效、安全的云端软件开发协作平台<br>
无论是个人、团队、或是企业，都能够用 Gitee 实现代码托管、项目管理、协作开发。企业项目请看 <a rel="noopener nofollow" class="external-link" href="https://gitee.com/enterprises" target="_blank">https://gitee.com/enterprises</a>}<br><br>软件架构说明<br>
git clone <a rel="noopener nofollow" class="external-link" href="https://gitee.com/zyichang/aimto408.git" target="_blank">https://gitee.com/zyichang/aimto408.git</a><br><br>
<br>xxxx
<br>xxxx
<br>xxxx
<br><br>
<br>xxxx
<br>xxxx
<br>xxxx
<br><br>
<br>Fork 本仓库
<br>新建 Feat_xxx 分支
<br>提交代码
<br>新建 Pull Request
<br><br>
<br>使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md
<br>Gitee 官方博客 <a data-tooltip-position="top" aria-label="https://blog.gitee.com" rel="noopener nofollow" class="external-link" href="https://blog.gitee.com" target="_blank">blog.gitee.com</a>
<br>你可以 <a rel="noopener nofollow" class="external-link" href="https://gitee.com/explore" target="_blank">https://gitee.com/explore</a> 这个地址来了解 Gitee 上的优秀开源项目
<br><a data-tooltip-position="top" aria-label="https://gitee.com/gvp" rel="noopener nofollow" class="external-link" href="https://gitee.com/gvp" target="_blank">GVP</a> 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目
<br>Gitee 官方提供的使用手册 <a rel="noopener nofollow" class="external-link" href="https://gitee.com/help" target="_blank">https://gitee.com/help</a>
<br>Gitee 封面人物是一档用来展示 Gitee 会员风采的栏目 <a rel="noopener nofollow" class="external-link" href="https://gitee.com/gitee-stars/" target="_blank">https://gitee.com/gitee-stars/</a>
<br><br><br>FCAPS——对应解释<br><br>BER编码——TLV编码格式【重点】<br>
字典式编码——NLV编码格式<br>
TLV编码中的T与数据类型相关（TYPE）<br><br>snmp协议<br><br>trap UDP 162端口<br>UDP编程示例：简单的UDP编程模型、并发的UDP模型<br>管理信息树：MIT、MIB<br>
考点：由ASN.1定义的组   msystem组、if-mib组、ip-mib组、画出tcp-mib组对应的结构以及，每个对象对应哪种对象类型{标量对象、表对象}<br><br>通讯模型【重点】双方沟通的语法（ASN. 1）、语义，PDU 格式，其中的 PDU 类型表示什么，会给出简单的对象进行 TLV 编码，<br>结构体串行化——sys_cpy<br>
PDU结构体的产生<br>
变量绑定的处理——使用的是单向链表，使用联合处理值<br>
结构体变成串行的放入缓冲区中进行发送<br>
send_to()<br>
memcpy()<br>
RMON 的概念<br><br><br>构建一个单实例的守护进程【实践课程】<br>
<br>守护进程
<br>单实例
<br>异步IO
<br>利用关系型DB与memcache相结合
<br>编写一个接口[web] [client] 将数据展示出来
<br>以下是一个结合了守护进程、单实例控制及异步 SNMPv 2 c 通信的 C 代码示例。代码使用了 Net-SNMP 库，请确保已安装相关开发包（如 net-snmp-dev）。<br>#include &lt;net-snmp/net-snmp-config.h&gt;
#include &lt;net-snmp/net-snmp-includes.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;syslog.h&gt;

#define LOCK_FILE "/var/run/snmp_topology_daemon.lock"
#define COMMUNITY "public"
#define OID_SYS_DESCR ".1.3.6.1.2.1.1.1.0"

typedef struct {
    const char *hostname;
    netsnmp_session *session;
    int completed;
} DeviceContext;

static DeviceContext devices[] = {
    {"www.c1.com", NULL, 0},
    {"www.c2.com", NULL, 0},
    {"www.d1.com", NULL, 0},
    {"www.d2.com", NULL, 0}
};
#define DEVICE_COUNT (sizeof(devices)/sizeof(devices[0]))

static int lock_fd = -1;
static int running = 1;

void async_callback(int operation, netsnmp_session *sp, int reqid,
                   netsnmp_pdu *pdu, void *magic) {
    DeviceContext *ctx = (DeviceContext *)magic;
    char value[1024];

    if (pdu-&gt;errstat == SNMP_ERR_NOERROR) {
        snprint_variable(value, sizeof(value), pdu-&gt;variables-&gt;name,
                        pdu-&gt;variables-&gt;name_length, pdu-&gt;variables);
        syslog(LOG_INFO, "Response from %s: %s = %s", 
               ctx-&gt;hostname, pdu-&gt;variables-&gt;name, value);
    } else {
        syslog(LOG_ERR, "Error from %s: %s", ctx-&gt;hostname, snmp_api_errstring(pdu-&gt;errstat));
    }

    ctx-&gt;completed = 1;
}

int init_snmp_sessions(void) {
    netsnmp_session session;
    snmp_sess_init(&amp;session);
    session.version = SNMP_VERSION_2c;
    session.community = (u_char*)COMMUNITY;
    session.community_len = strlen(COMMUNITY);

    for (size_t i = 0; i &lt; DEVICE_COUNT; i++) {
        session.peername = (char*)devices[i].hostname;
        devices[i].session = snmp_sess_open(&amp;session);
        if (!devices[i].session) {
            syslog(LOG_ERR, "Failed to create session for %s", devices[i].hostname);
            return -1;
        }

        netsnmp_pdu *pdu = snmp_pdu_create(SNMP_MSG_GET);
        oid anOID[] = { 1,3,6,1,2,1,1,1,0 };
        snmp_add_null_var(pdu, anOID, OID_LENGTH(anOID));

        if (snmp_sess_async_send(devices[i].session, pdu, async_callback, devices[i].hostname)) {
            syslog(LOG_INFO, "Sent request to %s", devices[i].hostname);
        } else {
            syslog(LOG_ERR, "Failed to send to %s", devices[i].hostname);
            snmp_free_pdu(pdu);
        }
    }
    return 0;
}

static void daemonize(void) {
    pid_t pid = fork();
    if (pid &lt; 0) exit(EXIT_FAILURE);
    if (pid &gt; 0) exit(EXIT_SUCCESS); // Parent exits
    
    setsid(); // Create new session
    umask(0);
    
    // Close standard file descriptors
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
}

static int single_instance(void) {
    lock_fd = open(LOCK_FILE, O_RDWR|O_CREAT, 0640);
    if (lock_fd &lt; 0) {
        syslog(LOG_ERR, "Cannot open lock file");
        return -1;
    }
    
    if (flock(lock_fd, LOCK_EX|LOCK_NB) &lt; 0) {
        syslog(LOG_ERR, "Another instance is running");
        return -1;
    }
    
    char buf[16];
    snprintf(buf, sizeof(buf), "%d\n", getpid());
    ftruncate(lock_fd, 0);
    write(lock_fd, buf, strlen(buf));
    return 0;
}

void signal_handler(int sig) {
    running = 0;
}

int main(void) {
    openlog("snmp-topology", LOG_PID, LOG_DAEMON);
    
    if (single_instance() != 0) {
        closelog();
        return EXIT_FAILURE;
    }
    
    daemonize();
    
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    
    init_snmp("snmp-topology");
    init_snmp_sessions();
    
    while (running) {
        int numfds = 0;
        fd_set fdset;
        struct timeval timeout;
        FD_ZERO(&amp;fdset);
        
        for (size_t i = 0; i &lt; DEVICE_COUNT; i++) {
            if (devices[i].session) {
                int fd = snmp_sess_session(devices[i].session);
                FD_SET(fd, &amp;fdset);
                numfds = MAX(numfds, fd+1);
            }
        }
        
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        
        int count = select(numfds, &amp;fdset, NULL, NULL, &amp;timeout);
        if (count &gt; 0) {
            snmp_read(&amp;fdset);
        } else if (count == 0) {
            // Check completion
            int all_done = 1;
            for (size_t i = 0; i &lt; DEVICE_COUNT; i++) {
                if (!devices[i].completed) {
                    all_done = 0;
                    break;
                }
            }
            if (all_done) running = 0;
        }
    }
    
    // Cleanup
    for (size_t i = 0; i &lt; DEVICE_COUNT; i++) {
        if (devices[i].session) {
            snmp_sess_close(devices[i].session);
        }
    }
    
    snmp_shutdown("snmp-topology");
    closelog();
    
    if (lock_fd != -1) {
        flock(lock_fd, LOCK_UN);
        close(lock_fd);
    }
    
    return EXIT_SUCCESS;
}
<br>代码说明：<br>
<br>
单实例控制：

<br>使用文件锁（/var/run 下的 lock 文件）确保只有一个实例运行
<br>通过 flock ()系统调用实现原子锁操作


<br>
守护进程：

<br>通过 fork ()+setsid ()创建守护进程
<br>关闭标准文件描述符
<br>使用 syslog 进行日志记录


<br>
异步 SNMP 通信：

<br>使用 Net-SNMP 库的异步 API
<br>为每个设备创建独立会话
<br>使用 select ()进行多路复用
<br>异步回调处理响应


<br>
功能特点：

<br>同时查询四个设备的 sysDescr（系统描述）信息
<br>支持优雅终止（SIGTERM/SIGINT）
<br>完善的错误处理


<br>编译运行：<br># 安装依赖
sudo apt-get install libsnmp-dev

# 编译
gcc -o topology_daemon topology_daemon.c -lnetsnmp

# 运行（需要root权限）
sudo ./topology_daemon

# 查看日志
tail -f /var/log/syslog | grep snmp-topology
<br>注意：<br>
<br>需要根据实际情况修改共同体名（COMMUNITY）和 OID
<br>确保目标设备 SNMP 服务已启用且可达
<br>日志通过 syslog 记录，查看方式取决于系统配置
<br>需要 root 权限创建 PID 文件（可调整 LOCK_FILE 路径）
<br>syslog日志【实践课程】]]></description><link>.\https:\\cs-note-three.vercel.app\review\readme.html</link><guid isPermaLink="false">review/README.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Mon, 26 May 2025 08:39:08 GMT</pubDate></item><item><title><![CDATA[review]]></title><description><![CDATA[ 
 <br><br><br>{When you're done, you can delete the content in this README and update the file with details for others getting started with your repository}<br><br>Software architecture description<br><br>
<br>xxxx
<br>xxxx
<br>xxxx
<br><br>
<br>xxxx
<br>xxxx
<br>xxxx
<br><br>
<br>Fork the repository
<br>Create Feat_xxx branch
<br>Commit your code
<br>Create Pull Request
<br><br>
<br>You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.md
<br>Gitee blog <a data-tooltip-position="top" aria-label="https://blog.gitee.com" rel="noopener nofollow" class="external-link" href="https://blog.gitee.com" target="_blank">blog.gitee.com</a>
<br>Explore open source project <a rel="noopener nofollow" class="external-link" href="https://gitee.com/explore" target="_blank">https://gitee.com/explore</a>
<br>The most valuable open source project <a data-tooltip-position="top" aria-label="https://gitee.com/gvp" rel="noopener nofollow" class="external-link" href="https://gitee.com/gvp" target="_blank">GVP</a>
<br>The manual of Gitee <a rel="noopener nofollow" class="external-link" href="https://gitee.com/help" target="_blank">https://gitee.com/help</a>
<br>The most popular members  <a rel="noopener nofollow" class="external-link" href="https://gitee.com/gitee-stars/" target="_blank">https://gitee.com/gitee-stars/</a>
<br>02/F<br>
01/F<br>
1/F<br>
2/F<br>
3/F<br>
12 芯室外单模光纤 X1 室外引入<br>
50 对室外铠装大对数钢缆 X2<br>
地下一层南侧<br>
4 芯 9um 光纤 X1 引入<br>
地上二层北侧<br>
地上二层南侧<br>
地下一层北侧<br>
线形说<br>
超 5 类 UTP<br>
3 类 4 芯电话线<br>
综合布线系统图<br>
图例主要设备材料表<br>
见系统图<br>
（含 19 机柜，光纤配线架，<br>
110 配线架模块配线架等）<br>
面板及模块<br>
建筑物配线架<br>
楼层配线架<br>
数据信息点<br>
语音信息点<br>
光纤配线架<br>
24 口接入层网络交换机<br>
六类非屏蔽双绞线<br>
管材、线槽<br>
序号<br>
图例<br>
名称<br>
规格<br>
单位<br>
数量<br>
安装位置<br>套<br>
个<br>
批<br>
网络机房内机柜内安装<br>底边距地 0.3 米安装<br>
楼层内机柜安装<br>
浪涌保护器<br>
防火分区位置示意图<br>M 1524 乙<br>
G<br>
C<br>
1<br>
5<br>
0<br>
9<br>北京房地中天<br>
建筑设计研究院<br>
有限责任公司<br>建筑工程设计甲级<br>
A 111002723<br>
文物保护设计甲级<br>
0301SJ 0050<br>设计阶段<br>
版次<br>
审定人<br>
工程主持人<br>
审核校对<br>
设计<br>
制图<br>
工程号<br>
图号<br>
日期<br>
工程名称<br>
图名<br>
专业负责<br>原北京房修艺建筑设计有限责任公司<br>
自忠小学改扩建工程<br>
弱电系统图]]></description><link>.\https:\\cs-note-three.vercel.app\review\readme.en.html</link><guid isPermaLink="false">review/README.en.md</guid><dc:creator><![CDATA[Apricity]]></dc:creator><pubDate>Thu, 05 Jun 2025 00:58:39 GMT</pubDate></item></channel></rss>