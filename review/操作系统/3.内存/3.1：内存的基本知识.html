<!DOCTYPE html> <html><head>
		<title>3.1：内存的基本知识 - review</title>
		<base href="..\..\../">
		<meta id="root-path" root-path="..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<!--<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">-->
		<meta charset="UTF-8">
		<meta name="description" content="3.1：内存的基本知识 - review">
		<meta property="og:title" content="3.1：内存的基本知识">
		<meta property="og:description" content="3.1：内存的基本知识 - review">
		<meta property="og:type" content="website">
		<meta property="og:url" content="./https://cs-note-three.vercel.app/review/操作系统/3.内存/3.1：内存的基本知识.html">
		<meta property="og:image" content=".\https:\\cs-note-three.vercel.app\review\操作系统\3.内存\img\pasted-image-20250605182554.png">
		<meta property="og:site_name" content="review">
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Expires" content="0">
		<meta name="ctime" content="1748685471873">
		<meta name="author" content="Apricity"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="./https://cs-note-three.vercel.app/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script id="minisearch-script" src="lib/scripts/minisearch.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><script defer="" id="easy-notice-script" src="lib/scripts/easy-notice.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js?v=1.8.03&amp;t=1749830987680" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><script defer="" id="img-zoom-script" src="lib/scripts/img-zoom.js?v=1.8.03" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;);"></script><link rel="stylesheet" href="lib/styles/obsidian.css?v=1.8.03"><link rel="preload" href="lib/styles/other-plugins.css?v=1.8.03" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css?v=1.8.03"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css?v=1.8.03" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css?v=1.8.03"></noscript><link rel="preload" href="lib/styles/supported-plugins.css?v=1.8.03" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css?v=1.8.03"></noscript><link rel="preload" href="lib/styles/main-styles.css?v=1.8.03" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css?v=1.8.03"></noscript><script>const LANG="zh-cn",VERSION="1.8.03",SHOW_COMMENTS=!0,SHOW_PAGE_HEADER=!0,SHOW_PAGE_FOOTER=!0,SHOW_RSS_FEED=!0,SHOW_SCROLL_TO_TOP=!0,SHOW_FILE_NUMBER=!0,EXPORT_PRESET="website",WALINE_SERVER_URL="https://cs-note-three.vercel.app/",AUTHOR="Apricity",VAULT_TITLE="review",FILE_COLORS={},DEFAULT_THEME="light",USE_FILE_COLOR_PLUGIN=!0,USE_BARTENDER_PLUGIN=!0</script><script src="https://unpkg.com/prismjs@1.29.0/prism.js" defer="defer"></script><script src="https://unpkg.com/lucide@latest"></script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css"><link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline-meta.css"><style>body{--font-ui-medium:16px}:root{--waline-font-size:16px;--waline-white:#fff;--waline-light-grey:#999;--waline-dark-grey:#666;--waline-theme-color:#27ae60;--waline-active-color:#2ecc71;--waline-color:#444;--waline-bg-color:var(--background-primary-alt);--waline-bg-color-light:#f8f8f8;--waline-bg-color-hover:#f0f0f0;--waline-border-color:#ddd;--waline-disable-bg-color:#f8f8f8;--waline-disable-color:#bbb;--waline-code-bg-color:#282c34;--waline-bq-color:#f0f0f0;--waline-avatar-size:3.25rem;--waline-m-avatar-size:calc(var(--waline-avatar-size) * 9 / 13);--waline-badge-color:#3498db;--waline-badge-font-size:0.775em;--waline-info-bg-color:#f8f8f8;--waline-info-color:#999;--waline-info-font-size:0.625em;--waline-border:1px solid var(--waline-border-color);--waline-avatar-radius:50%;--waline-box-shadow:none}.waline-theme-dark{--waline-white:#000;--waline-light-grey:#666;--waline-dark-grey:#999;--waline-color:#888;--waline-bg-color:var(--background-primary-alt);--waline-bg-color-light:#272727;--waline-border-color:#333;--waline-disable-bg-color:#444;--waline-disable-color:#272727;--waline-bq-color:#272727;--waline-info-bg-color:#272727;--waline-info-color:#666}.wl-power{display:none}.wl-reaction{margin-bottom:1em;text-align:left;margin-left:.5em}.wl-reaction-title{margin:20px auto}.wl-reaction-list{justify-content:left}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:17px!important}.wl-panel{margin:0}#waline{margin-top:50px!important;max-width:800px}.clickable-icon.sidebar-collapse-icon{width:2em!important;background-color:var(--background-secondary)}.graph-view-placeholder{width:22%;margin-left:38px}.tree-container .clickable-icon{margin-left:2px;border-radius:5px;border:none;box-shadow:none;display:flex;align-items:center;justify-content:center;margin-top:-3px}.document-container>.markdown-preview-view>.markdown-preview-sizer{max-width:100vw!important}body.show-inline-title .page-title{text-align:center}input[type=text],textarea{font-size:16px!important}input[type=search]{width:85%;border:1px solid #888;border-radius:5px;background-color:var(--background-primary);color:var(--text-muted)}.tree-container .clickable-icon{background-color:transparent}body{user-select:unset}blockquote{margin:0}#copyright{text-align:center;margin-top:80px!important}#copyright a{color:#ee802f;text-decoration:none;font-size:15px;margin-left:4px}#copyright a img{width:14px}.document-container>.markdown-preview-view>.markdown-preview-sizer pre{overflow:auto}.theme-light .document-container>.markdown-preview-view>.markdown-preview-sizer pre{position:relative;background-color:var(--background-primary-alt);border:1px solid #eeecec;border-radius:5px;padding:10px}.theme-dark .document-container>.markdown-preview-view>.markdown-preview-sizer pre{position:relative;background-color:var(--background-primary-alt);border:1px solid #373838;border-radius:5px;padding:10px}.markdown-rendered pre button.copy-code-button{position:absolute;top:7px;right:7px}.wl-header input{font-size:16px}.wl-reaction-votes{text-align:center}html>body>.webpage-container>.document-container>.markdown-preview-view>.markdown-preview-sizer>div.page-meta{text-align:center;padding:10px!important}.page-ctime,.waline-comment-count,.waline-pageview-count{margin-right:35px}.page-meta{color:#888}.page-meta svg{width:16px;vertical-align:middle}#qrcode{position:relative}#qr-zoom{position:absolute;width:170px;height:200px;z-index:999;display:none;border:1px solid #ccc;background:#fff}#qrcode:hover #qr-zoom{display:inline-block}#qr-zoom img{margin-top:10px}#qr-zoom font{margin-top:4px;display:inline-block}@media (max-width:768px){#qrcode{display:none!important}}#scrollToTopBtn{display:none;position:fixed;width:46px;height:46px;border:1px solid #ddd;border-radius:5px;background-color:var(--background-primary);text-align:center;bottom:75px;right:306px;opacity:.8}#scrollToTopBtn:hover{background-color:var(--background-primary-alt)}#scrollToTopBtn svg{margin-top:11px;color:var(--text-normal)}#scrollToTopBtn.st-collapsed{right:30px}@media (max-width:768px){#scrollToTopBtn{right:12px}#scrollToTopBtn.st-collapsed{right:12px}}.theme-dark #scrollToTopBtn{border:1px solid #999}.markdown-rendered pre button.copy-code-button{background-color:var(--background-primary);padding:3px 6px;border:1px solid #888;border-radius:5px;opacity:.9}.document-container.markdown-reading-view{background-color:var(--background-primary)}table{border:1px solid var(--table-border-color);border-radius:var(--size-2-3);border-spacing:0}td,th{padding:10px;border-right:1px solid var(--table-border-color);border-bottom:1px solid var(--table-border-color)}td:last-child,th:last-child{border-right:0}tr:last-child td,tr:last-child:not(:only-child) th{border-bottom:0}table>:only-child th{border-bottom:0}.document-container>.markdown-preview-view{margin:0;padding:var(--sidebar-margin)}.sidebar-content{background-color:var(--background-primary-alt)}.nav-folder-title[data-count]::after{content:attr(data-count);font-size:calc(100% * .8);margin-right:12px}.tree-container .tree-header{width:100%}#total-files{position:absolute;right:12px;color:var(--nav-item-color);font-size:calc(100% * .8)}.tree-container .collapse-icon{display:flex;align-items:center}.internal-embed.file-embed{cursor:pointer}.sidebar-content{padding-left:0;padding-right:0}.search-input-container{padding-left:10px}.tree-container{padding-left:12px;padding-right:12px}.graph-view-wrapper{padding-left:12px;padding-right:12px}.tree-container .tree-header,body .webpage-container .tree-container .tree-scroll-area{width:calc(100% - 12px)}.tree-container .clickable-icon svg{width:18px}ul.dataview.list-view-ul li{line-height:180%}#webpage-icon{display:none}.markdown-reading-view table{margin-block-start:var(--p-spacing);margin-block-end:var(--p-spacing)}li{line-height:180%}</style><script type="module">import{init}from"https://unpkg.com/@waline/client@v3/dist/waline.js";window.initWaline=e=>{e=e||document;const t=location.pathname.replace(/index\.html$/,"").replace(/\/$/,"")||"/",o=document.querySelector("#waline"),n=document.querySelector(".markdown-preview-sizer");if(!o){const e=document.createElement("div");e.id="waline",SHOW_COMMENTS||(e.style.display="none"),n.appendChild(e)}let i=document.querySelector(".page-meta");if(!i){const o=document.querySelector(".page-title");i=document.createElement("div"),i.className="page-meta",SHOW_PAGE_HEADER||(i.style.display="none");const n=e.querySelector('meta[name="ctime"]')?.getAttribute("content")||"";let c='<span title="创建时间"><i data-lucide="clock"></i> <span class="page-ctime">'+timestampToTimeString(+n)+"</span></span> ";SHOW_COMMENTS&&(c+='<span title="评论量"><i data-lucide="message-circle-more"></i> <span class="waline-comment-count" data-path="'+t+'">0</span></span> '),c+='<span title="阅读量"><i data-lucide="eye"></i> <span class="waline-pageview-count" data-path="'+t+'">1</span></span> ',c+='<span id="qrcode" title="手机查看"><i data-lucide="qr-code"></i><span id="qr-zoom"><img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data='+encodeURIComponent(location.href)+'" /><br /><font>手机查看</font></span></span>',i.innerHTML=c,o.after(i),lucide.createIcons()}try{(SHOW_PAGE_HEADER||SHOW_COMMENTS)&&init({el:"#waline",reaction:!0,dark:!1,copyright:!1,pageview:!0,comment:!0,path:t,serverURL:WALINE_SERVER_URL||"",locale:{reaction0:"点赞",reaction1:"踩一下",reaction2:"酷毙了",reaction3:"不屑",reaction4:"尴尬",reaction5:"无聊"}})}catch(e){console.log(e)}if(SHOW_SCROLL_TO_TOP&&!document.getElementById("scrollToTop")){const e=document.createElement("div");e.id="scrollToTop",e.innerHTML='<div id="scrollToTopBtn"><i data-lucide="arrow-up-to-line"></i></div>',n.appendChild(e),lucide.createIcons();var c=document.querySelector(".document-container>.markdown-preview-view"),a=document.getElementById("scrollToTopBtn");c.addEventListener("scroll",(function(){var e=c.scrollTop,t=.25*c.clientHeight;a.style.display=e>t?"block":"none"})),a.addEventListener("click",(function(){var e=document.querySelector(".document-container>.markdown-preview-view");"scrollBehavior"in document.documentElement.style?e.scrollTo({top:0,behavior:"smooth"}):e.scrollTop=0})),onToggleCollapsedChangedToTop();document.querySelector(".sidebar-right .clickable-icon.sidebar-collapse-icon").addEventListener("click",(()=>{setTimeout((()=>{onToggleCollapsedChangedToTop()}),42)}))}document.querySelectorAll(".document-container>.markdown-preview-view>.markdown-preview-sizer pre").forEach((e=>{e.addEventListener("scroll",(()=>{const t=e.querySelector(".copy-code-button"),o=t.getBoundingClientRect();t.style.right="auto",t.style.left=e.scrollLeft+e.offsetWidth-o.width-8+"px"}))})),setTimeout((()=>{if(!SHOW_COMMENTS)return;const e=document.querySelector(".wl-count");new MutationObserver((e=>{e.forEach((e=>{"characterData"!==e.type&&"childList"!==e.type||e.target.firstChild&&(document.querySelector(".waline-comment-count").innerHTML=e.target.firstChild.textContent)}))})).observe(e,{attributes:!1,childList:!0,subtree:!0,characterData:!0})}),100)}</script><script>function onAsyncLoadedDocument(e,t){togglePrismTheme("dark"!==localStorage.getItem("theme")),setTimeout((()=>{loadSpecialImg()}),42),initWaline(t),copyright(),initImgZoom(),attachDownload()}function toggleWalineTheme(e){e||document.body.classList.contains("waline-theme-dark")?document.body.classList.remove("waline-theme-dark"):document.body.classList.add("waline-theme-dark")}function onThemeToggle(e){toggleWalineTheme(e),togglePrismTheme(e)}function onSidebarCollapsed(e,t,o){const n=o.classList.contains("sidebar-left"),i=document.body.classList.contains("floating-sidebars");if(onToggleCollapsedChangedToTop(),i){const t=document.querySelector("#sidebarMask"),o=document.querySelector(".sidebar-left .tree-scroll-area"),i=isMobile();e?(t&&(t.style.display="none"),n&&o&&i&&(o.style.display="none")):(t&&(t.style.display="block"),n&&o&&i&&setTimeout((()=>{o.style.display="block"}),100))}}function onToggleCollapsedChangedToTop(){if("undefined"!=typeof scrollToTopBtn){document.querySelector(".sidebar-right").classList.contains("is-collapsed")?scrollToTopBtn.classList.add("st-collapsed"):scrollToTopBtn.classList.remove("st-collapsed")}}function copyright(){let e="© "+(new Date).getFullYear()+" "+(AUTHOR||document.querySelector('meta[name="author"]')?.getAttribute("content")||VAULT_TITLE)+' <font color="#ee802f">♡</font> 由obsidian强力驱动';SHOW_RSS_FEED&&(e+='&nbsp;<a href="lib/rss.xml"><img src="https://s21.ax1x.com/2024/04/21/pkpNoSf.png" />RSS</a>');const t=document.querySelector(".markdown-preview-sizer"),o=document.createElement("div");o.id="copyright",SHOW_PAGE_FOOTER||(o.style.display="none"),o.innerHTML=e,t.appendChild(o)}function timestampToTimeString(e){e=e||null;let t=new Date(e);return t.getFullYear()+"-"+((t.getMonth()+1<10?"0"+(t.getMonth()+1):t.getMonth()+1)+"-")+((t.getDate()<10?"0"+t.getDate():t.getDate())+" ")}function togglePrismTheme(e){const t=e?"":"-dark",o=document.getElementById("prism-theme"),n="https://unpkg.com/prismjs@1.29.0/themes/prism"+t+".min.css";if(o&&o.href===n)return;const i=document.createElement("link");i.id="prism-theme",i.rel="stylesheet",i.href=n,i.onload=()=>{o&&o.remove()},document.head.appendChild(i)}function onDomReady(e){"loading"!==document.readyState?e():document.addEventListener("DOMContentLoaded",e)}function isMobileMedia(e=768){return window.matchMedia("(max-width: "+e+"px)").matches}function initImgZoom(){ImgZoom(".document-container>.markdown-preview-view>.markdown-preview-sizer > div:not(.page-meta,.mod-footer,#waline,#scrollToTop,#copyright) img")}function onSearch(){document.querySelector(".sidebar-left input[type=search]").addEventListener("input",(e=>{setTimeout((()=>setTreeCount()),42)}))}function setTreeCount(){const e=document.querySelector(".sidebar-left .file-tree").querySelectorAll(".nav-file:not(.filtered-out)").length;if(document.querySelector("#total-files"))document.querySelector("#total-files").innerHTML=e;else{const t=document.querySelector(".tree-container .tree-header"),o=document.createElement("span");o.id="total-files",o.innerHTML=e,t.appendChild(o)}document.querySelectorAll(".sidebar-left .file-tree .nav-folder:not(.filtered-out) .tree-link .nav-folder-title").forEach((e=>{const t=e.parentElement.nextElementSibling.querySelectorAll(".nav-file:not(.filtered-out)").length;e.dataset.count=t}))}function observeTreeAreaResize(){const e=document.querySelector(".webpage-container .tree-container .tree-scroll-area");new ResizeObserver((()=>{document.querySelector("#total-files").style.right=e.offsetWidth-e.clientWidth+12+"px"})).observe(e)}function onSearchIndexing(){document.querySelector(".sidebar-left input[type=search]").placeholder="zh-cn"===LANG?"正在建立全文索引...":"Full-text indexing..."}function onSearchReady(){document.querySelector(".sidebar-left input[type=search]").placeholder="Search..."}function loadSpecialImg(){document.querySelectorAll("img[src*='+']").forEach((e=>{e.setAttribute("src",URLencode(e.getAttribute("src")))}))}function attachDownload(){setTimeout((()=>{document.querySelectorAll(".internal-embed.file-embed").forEach((e=>{e.onclick=()=>{window.open(e.getAttribute("src"))}}))}),42)}function onScrollIntoViewStart(e,t,o){setTimeout((()=>{const e=document.querySelector(".document-container>.markdown-preview-view");e.scrollLeft>0&&e.scrollTo(0,e.scrollTop)}),1500)}togglePrismTheme("dark"!==localStorage.getItem("theme")),onDomReady((()=>{let e=0;const t=(o=50)=>{const n=document.querySelector(".mod-tree-file .tree-link[href='index.html'] .tree-item-title");if(!(e>6e4)){if(n&&"index"===n.innerHTML)return n.innerHTML="首页",void loadSpecialImg();e+=o,setTimeout((()=>{t(o)}),o)}};"zh-cn"===LANG&&t(),initWaline(),toggleWalineTheme("dark"!==localStorage.getItem("theme")),copyright(),document.querySelector(".document-container").classList.remove("hide");const o=setInterval((()=>{const e=document.querySelector(".nav-file.mod-active");e&&e.parentElement&&(o&&clearInterval(o),setTimeout((()=>{if(setTimeout((()=>{const e=document.querySelectorAll(".tree-container .collapse-icon");e.length>0&&void 0===e[0].style.translate&&e.forEach((e=>{e.style.left=0}))}),50),SHOW_FILE_NUMBER&&(setTreeCount(),observeTreeAreaResize(),onSearch()),FILE_COLORS&&USE_FILE_COLOR_PLUGIN&&Object.getOwnPropertyNames(FILE_COLORS).length)for(const e in FILE_COLORS){const t=document.querySelector(".sidebar-left .tree-link[data-path='"+e+"'] .tree-item-title");t&&(t.style.color=FILE_COLORS[e])}attachDownload()}),42))}),50),n=document.createElement("div");n.id="sidebarMask",n.style="position:fixed;top:0;left:0;opacity:0;z-index:9;width:100%;height:100%;display:none;",n.onclick=function(){this.style.display="none"},document.body.appendChild(n),initImgZoom(),document.querySelector(".webpage-container input[type=search]").addEventListener("input",(e=>{searchReady||EasyNotice&&EasyNotice.createNotice("zh-cn"===LANG?"正在建立全文索引，请稍后重试...":"Full-text indexing, please try again later.",1500,"left:12px;top:12px;",!0,!1)}))}))</script></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon AT-row"><script defer="">let theme=localStorage.getItem("theme")||DEFAULT_THEME||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html?v=1.8.03&amp;t=1749830987720"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-c.mjx-c28.TEX-S3::before{padding:1.45em .736em .949em 0;content:"("}mjx-c.mjx-c29.TEX-S3::before{padding:1.45em .736em .949em 0;content:")"}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"×"}mjx-mtext{display:inline-block;text-align:left}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c1D43B.TEX-I::before{padding:.683em .888em 0 0;content:"H"}mjx-c.mjx-c2217::before{padding:.465em .5em 0 0;content:"∗"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-cB7::before{padding:.31em .278em 0 0;content:"⋅"}mjx-c.mjx-c2228::before{padding:.598em .667em .022em 0;content:"∨"}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}mjx-c.mjx-c1D439.TEX-I::before{padding:.68em .749em 0 0;content:"F"}mjx-c.mjx-c1D462.TEX-I::before{padding:.442em .572em .011em 0;content:"u"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-c.mjx-c1D44D.TEX-I::before{padding:.683em .723em 0 0;content:"Z"}mjx-c.mjx-c2026::before{padding:.12em 1.172em 0 0;content:"…"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-msub{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-c.mjx-c5B::before{padding:.75em .278em .25em 0;content:"["}mjx-c.mjx-c1D434.TEX-I::before{padding:.716em .75em 0 0;content:"A"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c5D::before{padding:.75em .278em .25em 0;content:"]"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-cAC::before{padding:.356em .667em 0 0;content:"¬"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c2295::before{padding:.583em .778em .083em 0;content:"⊕"}mjx-c.mjx-c1D44B.TEX-I::before{padding:.683em .852em 0 0;content:"X"}mjx-c.mjx-c1D44C.TEX-I::before{padding:.683em .763em 0 0;content:"Y"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c1D448.TEX-I::before{padding:.683em .767em .022em 0;content:"U"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c2F::before{padding:.75em .5em .25em 0;content:"/"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="什么是内存、有什么作用"><p dir="auto">什么是内存、有什么作用</p></h1><div class="el-h1 heading-wrapper"><div class="heading-children"><div class="el-p"><p dir="auto">——内存的作用就是存放数据，程序需要放在内存中才能够被 CPU 给处理，因为硬盘的速度和 CPU 之间相差太多</p></div><div class="el-p"><p dir="auto">但是很多程序公用内存空间，OS 如何区分各个程序的数据放在什么地方呢<br>
答：</p></div><div class="el-p"><p dir="auto">程序编译之后都从 0 号单元开始编址，这就称为目标模块的相对地址，当链接程序将各个模块链接成一个完整的可执行目标之后，链接程序按照顺序依次按各个模块的逻辑地址依次执行指令，<strong>进程在运行的之后使用和操作的都是逻辑地址，但是实际操作的还是物理地址，其中需要使用内存管理部件进行地址的转化</strong>，因此不同的进程可以拥有相同的逻辑地址，因为这些地址可以映射到不同的物理地址，也就是在内存中的实际地址，将逻辑地址转换为物理地址的过程称为地址重定位</p></div></div></div><div class="el-h1 heading-wrapper"><h1 data-heading="逻辑地址与物理地址的转换" dir="auto" class="heading" id="逻辑地址与物理地址的转换">逻辑地址与物理地址的转换</h1><div class="heading-children"><div class="el-h2 heading-wrapper"><h2 data-heading="绝对装入——已知装入地址" dir="auto" class="heading" id="绝对装入——已知装入地址"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>绝对装入——已知装入地址</h2><div class="heading-children"><div class="el-p"><p dir="auto">在程序编译时，如果知道程序将要放在内存中的哪个位置，编译程序就会产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存<br>
<strong>绝对装入只适合单道程序环境，此时还没有 OS 的概念，所以这个地址转换是由编译器完成的</strong></p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="可重定位装入" dir="auto" class="heading" id="可重定位装入"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>可重定位装入</h2><div class="heading-children"><div class="el-p"><p dir="auto">在编译链接的时候地址都是按照 0 为基准地址进行编译和链接，但是在装入内存的过程中，再对其中的地址进行修改，将逻辑地址转换为物理地址</p></div><div class="el-p"><p dir="auto"><strong>静态重定位的特点就是，需要一次性将作业装入内存，如果内存空间不足，就不能装入该作业，在程序运行的整个期间都不能修改程序，也不能再申请空间</strong><br>
适用于早期多道批处理操作系统</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="动态运行时装入" dir="auto" class="heading" id="动态运行时装入"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>动态运行时装入</h2><div class="heading-children"><div class="el-p"><p dir="auto">也成为动态重定位，在程序编译、链接装入模块都是从 0 开始的，装入程序把装入模块装入内存之后，并不会立即把逻辑地址转为物理地址，而是需要通过一个地址转换表，将逻辑地址和物理地址进行一一对应，这种方式需要一个寄存器来实现，使用重定位寄存器(基址寄存器)，来进行地址之间的转换<br>
优点：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">可以将程序分配到不同的连续区，在程序运行前只需要装入它的部分代码就可以投入运行，然后在程序运行期间可以根据需要动态分配内存，便于程序段的共享<br>
适用于现代的操作系统</li>
</ul></div></div></div></div></div><div class="el-h1 heading-wrapper"><h1 data-heading="链接的三种方式" dir="auto" class="heading" id="链接的三种方式">链接的三种方式</h1><div class="heading-children"><div class="el-h2 heading-wrapper"><h2 data-heading="静态链接" dir="auto" class="heading" id="静态链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>静态链接</h2><div class="heading-children"><div class="el-p"><p dir="auto">在程序运行之前将它们所需要的库函数链接成一个完成的装入模块，以后不再拆开，</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="装入时动态链接" dir="auto" class="heading" id="装入时动态链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>装入时动态链接</h2><div class="heading-children"><div class="el-p"><p dir="auto">在将目标模块装入内存时，边装入边链接的链接方式，优点是便于修改和更新，便于实现对目标模块的共享</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="运行时动态链接" dir="auto" class="heading" id="运行时动态链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>运行时动态链接</h2><div class="heading-children"><div class="el-p"><p dir="auto">在程序运行时需要使用到对应的模块时，才对他进行连接，优点是能加快程序的装入过程，还可以节省内存空间</p></div></div></div></div></div><div class="el-h1 heading-wrapper"><h1 data-heading="内存管理" dir="auto" class="heading" id="内存管理">内存管理</h1><div class="heading-children"><div class="el-h2 heading-wrapper"><h2 data-heading="进程的内存映像" dir="auto" class="heading" id="进程的内存映像"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>进程的内存映像</h2><div class="heading-children"><div class="el-p"><p dir="auto">一个进程在内存中的存放主要有</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">代码段：进程的二进制代码，代码段是只读的，可以被多个进程共享</li>
<li data-line="1" dir="auto">数据段：程序运行时处理的对象，包括全局变量、静态变量</li>
<li data-line="2" dir="auto">堆：存放动态内存分配的变量</li>
<li data-line="3" dir="auto">栈：用来实现函数调用，从用户空间的最大地址往低地址方向增长</li>
<li data-line="4" dir="auto">进程控制块：放在系统去，OS 通过 PCB 来控制和管理进程<br>
<span alt="Pasted image 20250605182554.png" src="Pasted image 20250605182554.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250605182554.png" src="review/操作系统/3.内存/img/pasted-image-20250605182554.png"></span></li>
</ul></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="内存保护" dir="auto" class="heading" id="内存保护"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>内存保护</h2><div class="heading-children"><div class="el-p"><p dir="auto">——确保每个用户进程都有一个单独的用户空间，分配之前需要保护 OS 不受用户进程的影响</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="上下限寄存器" dir="auto" class="heading" id="上下限寄存器"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>上下限寄存器</h3><div class="heading-children"><div class="el-p"><p dir="auto">——在内存中设置上下限寄存器，用来表示进程可以在主存中可以分配到的上下限地址，当 CPU 需要访问一个地址时，判断是否超过上下限寄存器中的值，判断有无越界</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="重定位寄存器" dir="auto" class="heading" id="重定位寄存器"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>重定位寄存器</h3><div class="heading-children"><div class="el-p"><p dir="auto">——设置一个基地址寄存器（重定位寄存器）和界地址寄存器（限长寄存器），基地址寄存器表示进程存放的基准地址，界地址寄存器表示的是可以访问的最大逻辑地址长度<br>
访问地址时首先判断逻辑地址是否超过界地址寄存器，如果超过则抛出越界异常，否则就加上基地址寄存器中的值，去访问对应的物理地址</p></div><div class="el-p"><p dir="auto"><strong>操作上述两种寄存器都需要在内核态进行，OS 可以改变上述寄存器中的值，但是不允许用户进程修改上述寄存器的值</strong></p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="内存空间的扩充" dir="auto" class="heading" id="内存空间的扩充"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>内存空间的扩充</h2><div class="heading-children"><div class="el-h3 heading-wrapper"><h3 data-heading="覆盖技术" dir="auto" class="heading" id="覆盖技术"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>覆盖技术</h3><div class="heading-children"><div class="el-p"><p dir="auto">——程序大小超过内存总和的问题<br>
思想：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">将程序分成多个段（模块），常用的常驻内存，不常用的在需要时调入内存</li>
<li data-line="1" dir="auto">内存分为固定区和若干个覆盖区，将需要常驻在内存中的放在固定区，调入之后就不再调出（除非运行结束）</li>
<li data-line="2" dir="auto">将不常用的段放在覆盖区中，需要时调入内存，不需要时调出内存<br>
如果程序本身有明显的调用结构的话，可以按照自身逻辑结构让那些不能同时被访问的程序段共享一段覆盖区<br>
<strong>适用于早期的操作系统</strong></li>
</ul></div><div class="el-p"><p dir="auto">必须由程序员声明覆盖结构，操作系统自动完成覆盖<br>
缺点：<br>
对用户不透明，增加了用户编程负担</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="交换技术" dir="auto" class="heading" id="交换技术"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>交换技术</h3><div class="heading-children"><div class="el-p"><p dir="auto">——在内存空间紧张时，将某些进程暂时的移除内存，把外存中的某些已经具备运行条件的进程换入内存（进程在内存于磁盘之间调度）</p></div><div class="el-p"><p dir="auto"><strong>此方法进程的 PCB 是常驻内存的，因为需要通过 PCB 管理集成，将外存中的进程唤醒到内存</strong></p></div><div class="el-blockquote"><blockquote dir="auto">
<p>在外存的什么位置保存被换出的进程呢？<br>
答：在具有交换功能的操作系统中，通常把磁盘分为文件区和交换区，文件区主要存放文件，更注重存储空间的利用率，所以采用离散的方式存储，交换区需要存放进程数据，交换速度直接影响到系统运行速度，所以交换区更加注重速度，因此采用连续分配方式，总而言之交换区的 IO 速度要比文件区要快</p>
</blockquote></div><div class="el-blockquote"><blockquote dir="auto">
<p>应该在什么时候交换？<br>
答：交换通常发生在许多进程同时运行并且内存资源不够的情况下，知道系统负载明显降低<br>
例如：如果在进程运行的时候经常发生缺页现象，说明内存空间不够，此时将其他进程交换出内存，缺页次数明显降低，此时可以暂停换出</p>
</blockquote></div><div class="el-p"><p dir="auto">应该换出什么进程？</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>答：可以有限换出阻塞的进程，换出优先级比较低的进程，为了防止优先级低的进程在被调出内存之后很快被调出，有时还需考虑进程在内存中的驻留时间</p>
</blockquote></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="内存空间的分配与回收" dir="auto" class="heading" id="内存空间的分配与回收"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>内存空间的分配与回收</h2><div class="heading-children"><div class="el-h3 heading-wrapper"><h3 data-heading="连续分配管理方式" dir="auto" class="heading" id="连续分配管理方式"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>连续分配管理方式</h3><div class="heading-children"><div class="el-p"><p dir="auto">——系统为用户分配的必须是一个连续的内存空间</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="单一连续分配方式" dir="auto" class="heading" id="单一连续分配方式"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>单一连续分配方式</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>采用静态重定位</strong><br>
——将内存分为系统区和用户区<br>
为进程分配整个用户区，用户区中只有一道作业，也就是说，不能加载多道用户程序</p></div><div class="el-p"><p dir="auto">优点：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">简单、无外部碎片</li>
<li data-line="1" dir="auto">不一定需要进行内存保护</li>
</ul></div><div class="el-p"><p dir="auto">缺点：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">只能单用户、单任务的操作系统</li>
<li data-line="1" dir="auto">有内部碎片（为其分配的空间中有一部分没有用上）</li>
<li data-line="2" dir="auto">内存利用率极低</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="固定分区分配" dir="auto" class="heading" id="固定分区分配"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>固定分区分配</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>采用静态重定位</strong><br>
——将用户空间划分为若干个固定大小的分区，每个分区只装入一道作业，有空闲分区时就可以在外存的后备作业中选取合适大小的作业装入该分区，划分分区的方法有两种：<br>
<strong>分区大小相等</strong><br>
程序太小会造成浪费、程序太大无法装入、缺乏灵活性<br>
<strong>分区大小不相等</strong><br>
划分多个较小的分区，适量的中等分区和少量大分区，增加了灵活性，可满足不同大小进程的需求</p></div><div class="el-p"><p dir="auto">为了区分分配与回收，建立一张分区使用表，表象包括分区的始址，大小及状态，分配内存时查找是否存在一个能满足进程所需的空间的最小分区，并且将这一分区的状态置为已分配，回收时将其置为未分配即可</p></div><div class="el-p"><p dir="auto">优点：<br>
实现简单，不会产生外部碎片</p></div><div class="el-p"><p dir="auto">缺点：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">当进程很大时，所有的分区都无法满足分配，此时又需要使用覆盖技术，这就会降低性能</li>
<li data-line="1" dir="auto">会产生内部碎片，内存利用率低</li>
</ul></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="动态内存分配" dir="auto" class="heading" id="动态内存分配"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>动态内存分配</h4><div class="heading-children"><div class="el-p"><p dir="auto">——又称为可变分区分配，是指内存装入内存时，根据进程的实际需要，动态的为其分配内存，使得分区大小正好满足进程的需要，因此系统中进程大小和数量都是可变的</p></div><div class="el-p"><p dir="auto">动态分区技术在一开始的表现是很好的，但是随着时间的推移，内存中会产生很多的小内存块（因为在上一个进程退出时，空间释放大小是固定的，很难找到一个进程大小正好的进程装入，只能找到对应比较小的进程装入，所以随着时间的推移会产生很多的内存小碎片）</p></div><div class="el-p"><p dir="auto">系统要使用怎样的数据结构来记录内存的使用情况</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>空闲分区表：类似固定分区分配中的分区表<br>
空闲分区链：每个分区起始部分和末尾部分都设置指针指向对应的前一个分区和后一个分区，起始部分还可以记录分区大小等情况</p>
</blockquote></div><div class="el-p"><p dir="auto">当很多空闲分区满足需求时，需要选择哪个空闲分区进行分配  <strong>动态分区分配算法</strong></p></div><div class="el-blockquote"><blockquote dir="auto">
</blockquote></div><div class="el-p"><p dir="auto">如何进行分区的分配以及回收操作</p></div><div class="el-blockquote"><blockquote dir="auto">
<ol>
<li data-line="0" dir="auto">回收区与插入点的前一个空闲分区相邻，此时将这两个分区合并为一个分区，修改起始地址和分区大小等信息</li>
<li data-line="1" dir="auto">回收区与插入点的后一个空闲分区相邻，此时将这两个分区合并，修改起始地址和分区大小等信息</li>
<li data-line="2" dir="auto">回收区与插入电的前后空闲分区都相邻，将这三个分区合并，修改起始地址和分区大小等信息</li>
<li data-line="3" dir="auto">回收区没有与之相邻的空闲分区，此时就需要新建一个表项，记录对应的起始地址，分区大小，并将其插入空闲分区表（链）</li>
</ol>
</blockquote></div><div class="el-p"><p dir="auto">如何判断前后是否为空闲呢？<br>
在空闲分区链中前后都会记录分区信息，前面包括起始地址，分区大小，是否被分配，后面包括分区大小的信息，后面的节点可以访问前面节点的分区大小信息，计算出分区的头部，访问分配情况判断是否为空闲分区，后面的节点根据其起始地址查看分配情况判断是否被分配</p></div><div class="el-p"><p dir="auto"><strong>内部碎片</strong>：分配给某些进程的内存区域中有些部分没有用上<br>
<strong>外部碎片</strong>：内存中有些很小的空间难以利用</p></div><div class="el-p"><p dir="auto"><strong>紧凑技术</strong>：通过挪动进程在内存中的位置，将外部碎片集中在一起，拼成一块更大的可以利用的空间</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="动态分区分配算法" dir="auto" class="heading" id="动态分区分配算法"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>动态分区分配算法</h4><div class="heading-children"><div class="el-p"><p dir="auto"><strong>基于顺序搜索的分配算法</strong><br>
<strong>1. 首次适应算法</strong><br>
空闲分区按照地址递增的方式进行排序，每次分配空间时，查找空闲分区表，找到的第一个满足条件的分区就进行分配<br>
优点：<br>
保留了内存高地址上的大分区，使得大进程能够装载<br>
缺点：<br>
回使内存低地址部分出现很多小的分区，每次查找都需要经过这些分区，增加了开销</p></div><div class="el-p"><p dir="auto"><strong>2. 邻近适应算法</strong><br>
每次从上一次查找结束的位置开始查找，与首次适应算法一样，只是每次开始的位置不一样，开始的位置是上一次查找结束的位置<br>
优点：<br>
解决了首次适应算法中的在低地址部分出现很多小的空闲分区问题<br>
缺点：<br>
导致高地址中没有大空间可以使用，通常比首次适应算法更坏</p></div><div class="el-p"><p dir="auto"><strong>3. 最佳适应算法</strong><br>
空闲分区链按照空闲分区大小递增的次序来排列，优先选用满足条件的最小的分区，尽可能留下大片的空闲区，以此来保证大进程可以被装入<br>
优点：<br>
算法的效果最佳<br>
缺点：<br>
每次使用的都是最小的分区进行使用，因此这种方法会带来越来越多的很小的外部碎片，难以利用的内存块</p></div><div class="el-p"><p dir="auto"><strong>4. 最大适应算法</strong><br>
空闲分区按照分区大小递减的次序来排列，每次找到大小能满足的第一个空闲分区<br>
缺点：<br>
每次都选择最大的分区进行分配，导致后面的大进程没有空间存放</p></div><div class="el-p"><p dir="auto">总而言之：首次适应算法的开销小，性能最好，回收分区不需要对空闲分区进行重新排布</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250605201148.png" src="Pasted image 20250605201148.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250605201148.png" src="review/操作系统/3.内存/img/pasted-image-20250605201148.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="基于索引的适应算法" dir="auto" class="heading" id="基于索引的适应算法"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>基于索引的适应算法</h4><div class="heading-children"><div class="el-p"><p dir="auto">当系统很大时，空闲分区链可能很长，所以根据空闲分区的大小设置空闲分区链，每一类（分区大小相同）的空闲分区，单独一个空闲分区链，并且设置一张索引表来管理这些空闲分区<br>
<strong>快速适应算法</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">根据进程的长度，在索引表中查找能够容纳它的最小空闲分区链表</li>
<li data-line="1" dir="auto">从链表中取下第一块进行分配<br>
优点：<br>
查找效率高，不会产生内部碎片<br>
缺点：<br>
在回收分区时需要有效的合并空闲分区，算法比较复杂，开销较大</li>
</ol></div><div class="el-p"><p dir="auto"><strong>伙伴系统</strong><br>
将系统中的空闲分区全部设置为 2 的倍数，每一类放在一个分区链中<br>
如果需要大小为 n 的空闲分区</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">查找一个最小的满足大小为 n 的空闲分区，如果有那么就进行分配</li>
<li data-line="1" dir="auto">如果没找到，那么就找下一个更大的分区（此时应该是上一个的 2 倍），将这段分区一分为二，一般用于空间分配，另一半用于空闲分区，将其挂载到对应的分区链上</li>
</ol></div><div class="el-p"><p dir="auto"><strong>哈希算法</strong><br>
构建一张针对空闲分区关键字的哈希表，每个表项记录对应空闲分区的头指针，分配时通过分区大小经过哈希查找找到对应的空闲分区链，从中得到对应的空闲分区</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="非连续存储管理" dir="auto" class="heading" id="非连续存储管理"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>非连续存储管理</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="基本分页存储管理" dir="auto" class="heading" id="基本分页存储管理"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>基本分页存储管理</h4><div class="heading-children"><div class="el-p"><p dir="auto">将内存空间分割为相同大小的页框，每个页框有一个编号，编号从 0 开始<br>
将进程的逻辑地址空间也分为对应大小的部分，每一个部分称为一个页或页面，每一个页面也有编号从 0 开始<br>
分页管理地址结构是一维的</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>注意页和页面指的是进程在逻辑上被划分的部分<br>
页框和页帧指的是内存被划分为相同大小块</p>
</blockquote></div><div class="el-p"><p dir="auto">将进程加载进内存中的页帧中，对应装在的页帧不一定连续，可以将其装在到不同的页帧中</p></div><div class="el-p"><p dir="auto"><strong>为了能知道页面能够装在内存中的哪个页框中，操作系统要为其建立一张页表，页表通常存储在 PCB 中</strong></p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">一个进程对应一张页表</li>
<li data-line="1" dir="auto">每个进程的页面对应一个页表项</li>
<li data-line="2" dir="auto">每个页表项由页号和块号（页框号）组成</li>
<li data-line="3" dir="auto">页表记录进程页面和实际存放内存块（页框）之间的映射关系<br>
注意：答题的时候建议使用页框号</li>
</ul></div><div class="el-p"><p dir="auto">每一个页表项占多少个字节呢？</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>例：假设系统物理内存大小为 4 GB，页面大小为 4 KB，那么对应每个页表项需要多少个字节？<br>
答：页表项记录的是进程页号和页框号之间的映射，所以只需要计算多少字节能够表示对应的页面大小和页号，4 GB 分块可以分为 2^20 个内存块，所以需要 20 位标识页框号，所以需要 3 B 来标识块号，<font color="#ff0000">对于页号是不需要存储空间的</font>，<font color="#ff0000">因为对应表项是连续存放的</font>，<font color="#ff0000">所以可以通过计算得到对应的页号及其对应的块号地址</font>【可以类比数组下标对数组的访问特性】</p>
</blockquote></div><div class="el-p"><p dir="auto">如何根据块号找到对应的实际物理地址呢？</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>答：内存块的起始地址 = 块号* 内存块的大小</p>
</blockquote></div><div class="el-p"><p dir="auto">如何实现地址的转换（操作系统是如何实现逻辑地址到物理地址的转换的）</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>答：首先确定逻辑地址所在的页号（页号 = 逻辑地址 / 页面长度  下取整）<br>
根据确定的页号，查找到对应在内存中的物理块号<br>
确定逻辑地址的<strong>页内偏移量</strong> （页内偏移量 = 逻辑地址%页面长度）<br>
物理地址 = 页面对应页框的首地址 + 页内偏移量</p>
</blockquote></div><div class="el-p"><p dir="auto"><strong>虽然进程页面在内存中是随意存放的，但是在进程内部是连续存放的</strong></p></div><div class="el-p"><p dir="auto">页面大小为 2 的整数倍有什么好处</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>答：页面大小为 2 的整数倍，可以更好的拆分地址，可以很快的根据页框号和页内偏移量得到实际的物理地址，直接对其进行拼接就能得到对应的物理地址，反之也可以很快的通过物理地址得到对应的页块号还有页内偏移量，只需要进行左移和右移就行</p>
</blockquote></div><div class="el-p"><p dir="auto">可以将逻辑地址分为页号和页内偏移量，<br>
其中页号的表示位数表明了进程所占页框的数量<br>
页内偏移量的位数表示页框的大小</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="基本地址变换机构" dir="auto" class="heading" id="基本地址变换机构"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>基本地址变换机构</h5><div class="heading-children"><div class="el-p"><p dir="auto">——用于实现逻辑地址到物理地址转换的一种硬件机构<br>
通常会在系统中设置一个页表寄存器用来存放<font color="#ff0000">页表</font>在内存中的起始地址和页表长度，进程未执行时会存放在 PCB 中，进程开始执行会将其加载进页表寄存器中</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250606175413.png" src="Pasted image 20250606175413.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606175413.png" src="review/操作系统/3.内存/img/pasted-image-20250606175413.png"></span></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">根据逻辑地址计算得到页号和页内偏移量</li>
<li data-line="1" dir="auto">判断页号是否越界，如果页号&gt;=页表长度，则说明越界</li>
<li data-line="2" dir="auto">如果不越界，访问页表对应的起始地址，访问页表查找出对应的页框号</li>
<li data-line="3" dir="auto">通过页框号和页内偏移量去访问对应的物理地址</li>
</ol></div><div class="el-p"><p dir="auto">主要问题：<br>
每次访存都需要进行逻辑地址到物理地址之间的转换，地址转换速度需要足够快，否则访存速度就会降低<br>
每个进程引入页表，页表必须连续存放，用于映射机制，但是页表不能太大，否则内存利用会降低</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="具有快表的地址变换机构" dir="auto" class="heading" id="具有快表的地址变换机构"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>具有快表的地址变换机构</h5><div class="heading-children"><div class="el-p"><p dir="auto">快表：又称联想寄存器，它是一种访问速度比内存快很多的高速缓存（cache，一般集成在 CPU 内部），用来存放最近访问过的表项的副本，, 可以加速地址的转换<br>
内存中的页表称为慢表</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250606182139.png" src="Pasted image 20250606182139.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606182139.png" src="review/操作系统/3.内存/img/pasted-image-20250606182139.png"></span><br>
在引入快表之后，每次进行地址转换的过程都会查看快表是否命中，命中就直接访问内存单元，否则去访问慢表然后再进行地址转换，同时将慢表中的表项放入快表中，如果快表已经存满，那么就通过置换算法来对表项进行置换</p></div><div class="el-p"><p dir="auto">有无快表地址转换对比<br>
<span alt="Pasted image 20250606183526.png" src="Pasted image 20250606183526.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606183526.png" src="review/操作系统/3.内存/img/pasted-image-20250606183526.png"></span></p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="两级页表" dir="auto" class="heading" id="两级页表"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>两级页表</h5><div class="heading-children"><div class="el-p"><p dir="auto">——解决单级页表存在的问题，如果页表项过多，在内存中所需要占用的空间就越多<br>
根据局部性原理可知，进程在一段时间内只需要访问某几个页面就可以正常执行了，因此没必要让所有页表项都常驻内存</p></div><div class="el-p"><p dir="auto"><strong>注意每个表只能存放在内存中的一个页框中，超出的部分需要按照多级页表进行划分<br>
采用 n 级页表需要进行 n+1 次内存的访问</strong></p></div><div class="el-p"><p dir="auto">类比进程分页的方式，可以类比的将页表进行分页，将各个分组分别放入内存块中，为需要分配的页表再建立一个页表，这个表示页表映射关系的表称为<font color="#00b0f0">页目录表</font>或称为<font color="#92d050">外层页表</font>或者<font color="#92d050">顶层页表</font></p></div><div class="el-p"><p dir="auto">原理：<br>
<font color="#92d050">外层页表</font>表示的是对应<font color="#92d050">页表编号</font>存储在内存中的页框号<br>
<font color="#00b0f0">内层页表</font>表示的是<font color="#00b0f0">进程对应分页</font>存储在内存中的页框号</p></div><div class="el-p"><p dir="auto">地址转换的过程：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">根据地址按照地址安排结构将其拆成 3 部分，一级页表、二级页表、页内偏移量</li>
<li data-line="1" dir="auto">从 PCB 一级中读取页表存储的位置，根据一级页号去对应内存中查找对应下一级页表在内存中存放的位置</li>
<li data-line="2" dir="auto">根据二级页号查找最终想要访问的内存块</li>
<li data-line="3" dir="auto">组合页内偏移量组合得到最终访问的地址<br>
<strong>如果想访问的页面不在内存中则会产生缺页中断，然后将目标页面调入内存</strong></li>
</ol></div><div class="el-p"><p dir="auto"><font color="#ff0000">缺页中断与当前执行的指令有关，属于内部中断</font></p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="基本分段式存储管理" dir="auto" class="heading" id="基本分段式存储管理"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>基本分段式存储管理</h4><div class="heading-children"><div class="el-p"><p dir="auto">与分页存储最大的区别就是离散分配的时候所分配的基本单位不同，分页是固定分配的空间，而分段是根据程序的逻辑功能进行分段的，用户进行编程会更加方便，程序的可读性更高<br>
分段存储管理地址结构是二维的</p></div><div class="el-p"><p dir="auto">什么是分段？</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>答：进程按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从 0 开始编址</p>
</blockquote></div><div class="el-p"><p dir="auto">内存分配规则：</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>OS 以段为单位进行分配，每个段在内存中占据连续的内存空间，但是各段之间可以不相邻</p>
</blockquote></div><div class="el-p"><p dir="auto">分段系统的逻辑地址由段号和段内地址组成</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><font color="#00b0f0">段号的位数确定了进程最大可以分为几个段</font></li>
<li data-line="1" dir="auto"><font color="#00b0f0">段内地址决定了段的最大长度为多少</font><br>
在编写分段存储分配程序时按照段名编写，在编译的时候会将其转换为对应的段号</li>
</ol></div><div class="el-p"><p dir="auto">为了保证程序能够正常运行，找到对应段的位置，OS 会建立一张段映射表简称段表</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">段表中包含段号、段长、基址（段在内存中的起始位置）三个字段</li>
<li data-line="1" dir="auto">各个段表项的长度是相同的，段号是可以隐藏的，不占存储空间（类比数组的下标访问，数组下标也不占存储空间）</li>
</ul></div><div class="el-p"><p dir="auto">在进行地址转换的过程中需要使用到段表寄存器，在程序运行开始时，从 PCB 中恢复段表寄存器中的值<br>
<span alt="Pasted image 20250606194109.png" src="Pasted image 20250606194109.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606194109.png" src="review/操作系统/3.内存/img/pasted-image-20250606194109.png"></span></p></div><div class="el-blockquote"><blockquote dir="auto">
<p>访问过程大体和页式存储一致，不一样的是在得到段号之后还需要比较段内偏移量是否越界，因为每个段的长度都是不一样的，所以需要进行判断</p>
</blockquote></div><div class="el-p"><p dir="auto">分段式存储实现简单进程间共享数据的方法如下，使得不同进程的段表中分别指向同一个段对应的物理地址<br>
<span alt="Pasted image 20250606195433.png" src="Pasted image 20250606195433.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606195433.png" src="review/操作系统/3.内存/img/pasted-image-20250606195433.png"></span></p></div><div class="el-p"><p dir="auto">为什么分页不利于实现进程之间数据共享</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>因为在进行分页时，可能会出现多个进程同时访问的代码存在不同的页中，可能共享代码存在的那个页中还存在其他部分不能共享的代码，这显然是不合理的</p>
</blockquote></div><div class="el-p"><p dir="auto"><strong>对应分页存储管理的措施、方法都可以应用到分段存储管理</strong><br>
分段式存储进行地址转化时需要进行两次访存，第一次访问段表，第二次访问对应真实的物理地址</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="段页式管理" dir="auto" class="heading" id="段页式管理"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>段页式管理</h4><div class="heading-children"><div class="el-p"><p dir="auto">——结合分段管理和分页管理的优点，按照逻辑模块进行分段，将各段再进行分页，将内存空间划分为大小相同的各个页框</p></div><div class="el-p"><p dir="auto">按照上述分段之后再分页，所以逻辑地址结构由段号、页号、页内偏移量组成</p></div><div class="el-p"><p dir="auto">段号的位数决定了一个进程最多能分多少段，页号的位数决定了一个段最多能分为多少页，页内偏移量决定了内存块的大小</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>分段对于用户来说是可见的，程序员编程时需要显式的给出段号、段内地址，而将各段分为各个页对于用户来说是不可见的，系统会根据段内地址自动划分页号和页内偏移量</p>
</blockquote></div><div class="el-p"><p dir="auto">此时对于段表的定义需要更新<br>
段表由段号、页表长度、页表存放块号组成，其中页表长度表示的是将一个段分为多少个页，段号页式可以隐式表示的</p></div><div class="el-p"><p dir="auto">段页式和页式管理的页表都是一样的，记录的都是页号到内存中的映射位置</p></div><div class="el-p"><p dir="auto"><strong>对应逻辑地址到物理地址转换的过程</strong><br>
<span alt="Pasted image 20250606201645.png" src="Pasted image 20250606201645.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250606201645.png" src="review/操作系统/3.内存/img/pasted-image-20250606201645.png"></span><br>
需要注意的是段页式存储需要进行两次比较，分别比较段号是否越界，以及段内的页号是否越界</p></div><div class="el-p"><p dir="auto">在段页式存储进行地址的转化过程需要进行三次访存<br>
第一次访问段表<br>
第二次访问页表<br>
第三次访问真实的物理内存</p></div><div class="el-p"><p dir="auto">同样的，也可以引入快表机制，使用块号和页号作为标记进行访问，快表命中就不需要访问段表和页表了，可以直接访问对应真实物理地址</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#什么是内存、有什么作用" data-path=""><div class="tree-item-contents heading-link" heading-name="什么是内存、有什么作用"><span class="tree-item-title">什么是内存、有什么作用</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#逻辑地址与物理地址的转换" data-path=""><div class="tree-item-contents heading-link" heading-name="逻辑地址与物理地址的转换"><span class="tree-item-title">逻辑地址与物理地址的转换</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#绝对装入——已知装入地址" data-path=""><div class="tree-item-contents heading-link" heading-name="绝对装入——已知装入地址"><span class="tree-item-title">绝对装入——已知装入地址</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#可重定位装入" data-path=""><div class="tree-item-contents heading-link" heading-name="可重定位装入"><span class="tree-item-title">可重定位装入</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#动态运行时装入" data-path=""><div class="tree-item-contents heading-link" heading-name="动态运行时装入"><span class="tree-item-title">动态运行时装入</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#链接的三种方式" data-path=""><div class="tree-item-contents heading-link" heading-name="链接的三种方式"><span class="tree-item-title">链接的三种方式</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#静态链接" data-path=""><div class="tree-item-contents heading-link" heading-name="静态链接"><span class="tree-item-title">静态链接</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#装入时动态链接" data-path=""><div class="tree-item-contents heading-link" heading-name="装入时动态链接"><span class="tree-item-title">装入时动态链接</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#运行时动态链接" data-path=""><div class="tree-item-contents heading-link" heading-name="运行时动态链接"><span class="tree-item-title">运行时动态链接</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#内存管理" data-path=""><div class="tree-item-contents heading-link" heading-name="内存管理"><span class="tree-item-title">内存管理</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#进程的内存映像" data-path=""><div class="tree-item-contents heading-link" heading-name="进程的内存映像"><span class="tree-item-title">进程的内存映像</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#内存保护" data-path=""><div class="tree-item-contents heading-link" heading-name="内存保护"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">内存保护</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#上下限寄存器" data-path=""><div class="tree-item-contents heading-link" heading-name="上下限寄存器"><span class="tree-item-title">上下限寄存器</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#重定位寄存器" data-path=""><div class="tree-item-contents heading-link" heading-name="重定位寄存器"><span class="tree-item-title">重定位寄存器</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#内存空间的扩充" data-path=""><div class="tree-item-contents heading-link" heading-name="内存空间的扩充"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">内存空间的扩充</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#覆盖技术" data-path=""><div class="tree-item-contents heading-link" heading-name="覆盖技术"><span class="tree-item-title">覆盖技术</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#交换技术" data-path=""><div class="tree-item-contents heading-link" heading-name="交换技术"><span class="tree-item-title">交换技术</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#内存空间的分配与回收" data-path=""><div class="tree-item-contents heading-link" heading-name="内存空间的分配与回收"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">内存空间的分配与回收</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#连续分配管理方式" data-path=""><div class="tree-item-contents heading-link" heading-name="连续分配管理方式"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">连续分配管理方式</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#单一连续分配方式" data-path=""><div class="tree-item-contents heading-link" heading-name="单一连续分配方式"><span class="tree-item-title">单一连续分配方式</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#固定分区分配" data-path=""><div class="tree-item-contents heading-link" heading-name="固定分区分配"><span class="tree-item-title">固定分区分配</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#动态内存分配" data-path=""><div class="tree-item-contents heading-link" heading-name="动态内存分配"><span class="tree-item-title">动态内存分配</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#动态分区分配算法" data-path=""><div class="tree-item-contents heading-link" heading-name="动态分区分配算法"><span class="tree-item-title">动态分区分配算法</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#基于索引的适应算法" data-path=""><div class="tree-item-contents heading-link" heading-name="基于索引的适应算法"><span class="tree-item-title">基于索引的适应算法</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#非连续存储管理" data-path=""><div class="tree-item-contents heading-link" heading-name="非连续存储管理"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">非连续存储管理</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#基本分页存储管理" data-path=""><div class="tree-item-contents heading-link" heading-name="基本分页存储管理"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">基本分页存储管理</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#基本地址变换机构" data-path=""><div class="tree-item-contents heading-link" heading-name="基本地址变换机构"><span class="tree-item-title">基本地址变换机构</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#具有快表的地址变换机构" data-path=""><div class="tree-item-contents heading-link" heading-name="具有快表的地址变换机构"><span class="tree-item-title">具有快表的地址变换机构</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#两级页表" data-path=""><div class="tree-item-contents heading-link" heading-name="两级页表"><span class="tree-item-title">两级页表</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#基本分段式存储管理" data-path=""><div class="tree-item-contents heading-link" heading-name="基本分段式存储管理"><span class="tree-item-title">基本分段式存储管理</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="review\操作系统\3.内存\3.1：内存的基本知识.html#段页式管理" data-path=""><div class="tree-item-contents heading-link" heading-name="段页式管理"><span class="tree-item-title">段页式管理</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>